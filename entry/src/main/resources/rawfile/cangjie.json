[
  {
    "id": 1,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "在仓颉语言中，打印\"Hello World\"的正确语法是？",
    "options": {
      "A": "print(\"Hello World\")",
      "B": "println(\"Hello World\")",
      "C": "echo \"Hello World\"",
      "D": "printf(\"Hello World\")"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 println 函数输出一行文本并换行。"
  },
  {
    "id": 2,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中定义变量的关键字是什么？",
    "options": {
      "A": "var",
      "B": "let",
      "C": "val",
      "D": "def"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 var 关键字定义可变变量，使用 val 定义不可变变量。"
  },
  {
    "id": 3,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "以下哪个是仓颉语言中的单行注释符号？",
    "options": {
      "A": "//",
      "B": "#",
      "C": "--",
      "D": "/* */"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 // 进行单行注释，使用 /* */ 进行多行注释。"
  },
  {
    "id": 4,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中语句结束通常使用什么符号？",
    "options": {
      "A": "分号(;)",
      "B": "换行符",
      "C": "句号(.)",
      "D": "不需要结束符号"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言通常使用换行符作为语句结束，分号是可选的。"
  },
  {
    "id": 5,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言的源文件扩展名是什么？",
    "options": {
      "A": ".java",
      "B": ".cj",
      "C": ".cangjie",
      "D": ".cjj"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言的源文件通常使用 .cj 作为文件扩展名。"
  },
  {
    "id": 6,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "在仓颉语言中，如何定义常量？",
    "options": {
      "A": "const",
      "B": "val",
      "C": "final",
      "D": "constant"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 val 关键字定义不可变的常量。"
  },
  {
    "id": 7,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中导入模块的关键字是？",
    "options": {
      "A": "import",
      "B": "include",
      "C": "using",
      "D": "require"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 import 关键字导入其他模块。"
  },
  {
    "id": 8,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "以下哪个是仓颉语言的有效标识符？",
    "options": {
      "A": "123variable",
      "B": "var-name",
      "C": "variable_name",
      "D": "var name"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言的标识符可以包含字母、数字和下划线，但不能以数字开头。"
  },
  {
    "id": 9,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中表示空值的关键字是？",
    "options": {
      "A": "null",
      "B": "None",
      "C": "nil",
      "D": "undefined"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 null 表示空值。"
  },
  {
    "id": 10,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言的主函数签名正确的是？",
    "options": {
      "A": "func main()",
      "B": "function main()",
      "C": "def main():",
      "D": "main()"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 function main() 作为程序入口点。"
  },
  {
    "id": 11,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示整数的基本类型是什么？",
    "options": {
      "A": "int",
      "B": "integer",
      "C": "number",
      "D": "Int"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中整数类型为 Int，采用首字母大写的命名约定。"
  },
  {
    "id": 12,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "以下哪个是仓颉语言中的布尔值？",
    "options": {
      "A": "true/false",
      "B": "True/False",
      "C": "1/0",
      "D": "yes/no"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用小写的 true 和 false 作为布尔值。"
  },
  {
    "id": 13,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示浮点数的类型是？",
    "options": {
      "A": "float",
      "B": "double",
      "C": "Float",
      "D": "Decimal"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言使用 Float 表示浮点数，遵循首字母大写的命名规范。"
  },
  {
    "id": 14,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中字符串的类型是什么？",
    "options": {
      "A": "string",
      "B": "String",
      "C": "str",
      "D": "Text"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 String 表示字符串类型。"
  },
  {
    "id": 15,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中字符的类型是什么？",
    "options": {
      "A": "char",
      "B": "Char",
      "C": "character",
      "D": "Character"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Char 表示单个字符。"
  },
  {
    "id": 16,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中数组的声明方式正确的是？",
    "options": {
      "A": "Array<Int>",
      "B": "Int[]",
      "C": "List<Int>",
      "D": "Array[Int]"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Array<Type> 的语法声明数组。"
  },
  {
    "id": 17,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中字典类型的声明方式是？",
    "options": {
      "A": "Dict<K,V>",
      "B": "Map<K,V>",
      "C": "Dictionary<K,V>",
      "D": "HashMap<K,V>"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Map<K,V> 表示键值对集合。"
  },
  {
    "id": 18,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中元组的声明方式正确的是？",
    "options": {
      "A": "(Int, String)",
      "B": "Tuple<Int, String>",
      "C": "Pair<Int, String>",
      "D": "IntStringTuple"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用括号语法 (Type1, Type2) 表示元组。"
  },
  {
    "id": 19,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中可选类型的表示方式是？",
    "options": {
      "A": "Optional<T>",
      "B": "T?",
      "C": "Maybe<T>",
      "D": "Option<T>"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Type? 表示可选类型，表示值可能为 null。"
  },
  {
    "id": 20,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中范围类型的表示方式是？",
    "options": {
      "A": "Range",
      "B": "1..10",
      "C": "Interval",
      "D": "1 to 10"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 start..end 表示范围，包含起始和结束值。"
  },
  {
    "id": 21,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "在仓颉语言中，如何定义无返回值的函数？",
    "options": {
      "A": "func name(): void",
      "B": "function name(): Unit",
      "C": "def name(): None",
      "D": "fn name() -> ()"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 function 关键字定义函数，无返回值时返回 Unit 类型。"
  },
  {
    "id": 22,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中支持哪种参数传递方式？",
    "options": {
      "A": "仅值传递",
      "B": "仅引用传递",
      "C": "值和引用传递",
      "D": "指针传递"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言采用值传递方式，对于对象类型传递的是引用副本。"
  },
  {
    "id": 23,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中定义默认参数值的方式是？",
    "options": {
      "A": "function foo(x = 5)",
      "B": "function foo(x: Int = 5)",
      "C": "function foo(x: Int := 5)",
      "D": "function foo(5)"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 parameter: Type = value 的语法定义默认参数。"
  },
  {
    "id": 24,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中可变参数的表示方式是？",
    "options": {
      "A": "params",
      "B": "...",
      "C": "varargs",
      "D": "*"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言使用 varargs 关键字表示可变数量参数。"
  },
  {
    "id": 25,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中匿名函数的定义方式是？",
    "options": {
      "A": "lambda x: x + 1",
      "B": "function(x) { return x + 1 }",
      "C": "x => x + 1",
      "D": "(x) -> x + 1"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言使用 (parameters) -> expression 语法定义匿名函数。"
  },
  {
    "id": 26,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中高阶函数的特性是指？",
    "options": {
      "A": "函数可以作为参数传递",
      "B": "函数可以返回函数",
      "C": "函数可以嵌套定义",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言支持函数作为参数、返回函数和嵌套函数等高阶函数特性。"
  },
  {
    "id": 27,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中尾递归优化的作用是？",
    "options": {
      "A": "减少内存占用",
      "B": "避免栈溢出",
      "C": "提高执行速度",
      "D": "简化代码"
    },
    "answer": [
      "B"
    ],
    "explanation": "尾递归优化可以将递归调用转换为循环，避免栈溢出错误。"
  },
  {
    "id": 28,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数柯里化的实现方式是？",
    "options": {
      "A": "自动柯里化",
      "B": "使用curry关键字",
      "C": "手动创建部分应用函数",
      "D": "不支持柯里化"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言需要手动创建部分应用函数来实现柯里化效果。"
  },
  {
    "id": 29,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数组合的操作符是？",
    "options": {
      "A": ">>",
      "B": "|>",
      "C": "∘",
      "D": "andThen"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 >> 操作符进行函数组合，f >> g 表示先执行f再执行g。"
  },
  {
    "id": 30,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中偏函数的定义方式是？",
    "options": {
      "A": "使用partial关键字",
      "B": "使用_作为占位符",
      "C": "自动部分应用",
      "D": "不支持偏函数"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用下划线 _ 作为参数占位符来创建偏函数。"
  },
  {
    "id": 31,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中定义类的关键字是什么？",
    "options": {
      "A": "class",
      "B": "struct",
      "C": "object",
      "D": "type"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 class 关键字定义类，支持面向对象编程特性。"
  },
  {
    "id": 32,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "以下关于仓颉语言继承的说法正确的是？",
    "options": {
      "A": "支持多继承",
      "B": "仅支持单继承",
      "C": "不支持继承",
      "D": "通过接口实现继承"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言采用单继承模型，但可以通过接口实现多重继承的效果。"
  },
  {
    "id": 33,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中接口的定义关键字是？",
    "options": {
      "A": "interface",
      "B": "protocol",
      "C": "trait",
      "D": "abstract"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 interface 关键字定义接口。"
  },
  {
    "id": 34,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中抽象类的定义方式是？",
    "options": {
      "A": "abstract class",
      "B": "virtual class",
      "C": "base class",
      "D": "使用abstract关键字标记方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 abstract class 定义抽象类。"
  },
  {
    "id": 35,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中访问修饰符不包括以下哪个？",
    "options": {
      "A": "public",
      "B": "private",
      "C": "protected",
      "D": "internal"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言的访问修饰符包括 public、private 和 internal，没有 protected。"
  },
  {
    "id": 36,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中属性的getter和setter如何定义？",
    "options": {
      "A": "自动生成",
      "B": "使用get和set关键字",
      "C": "使用property关键字",
      "D": "需要手动实现"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言会自动为属性生成getter和setter方法。"
  },
  {
    "id": 37,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中伴生对象的作用是？",
    "options": {
      "A": "实现单例模式",
      "B": "存放静态成员",
      "C": "实现工厂模式",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "伴生对象可以用于实现单例、存放静态成员和工厂方法等。"
  },
  {
    "id": 38,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中数据类的定义关键字是？",
    "options": {
      "A": "data class",
      "B": "record",
      "C": "struct",
      "D": "value class"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 data class 定义数据类，自动生成equals、hashCode等方法。"
  },
  {
    "id": 39,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中密封类的作用是？",
    "options": {
      "A": "限制类继承",
      "B": "实现模式匹配",
      "C": "定义有限集合的子类",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "密封类用于限制继承、实现模式匹配和定义有限的子类集合。"
  },
  {
    "id": 40,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中扩展函数的作用是？",
    "options": {
      "A": "为已有类添加新方法",
      "B": "扩展现有函数的功能",
      "C": "增加函数参数",
      "D": "修改函数返回值"
    },
    "answer": [
      "A"
    ],
    "explanation": "扩展函数允许为已有类添加新方法，而不需要继承或修改原始类。"
  },
  {
    "id": 41,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中轻量级线程的创建关键字是什么？",
    "options": {
      "A": "async",
      "B": "spawn",
      "C": "go",
      "D": "coroutine"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 spawn 关键字创建轻量级线程（协程）。"
  },
  {
    "id": 42,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中通道的主要作用是？",
    "options": {
      "A": "协程间通信",
      "B": "数据序列化",
      "C": "网络传输",
      "D": "文件读写"
    },
    "answer": [
      "A"
    ],
    "explanation": "通道用于协程之间的安全通信和数据传递。"
  },
  {
    "id": 43,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中select语句的作用是？",
    "options": {
      "A": "多路复用通道操作",
      "B": "数据库查询",
      "C": "条件选择",
      "D": "模式匹配"
    },
    "answer": [
      "A"
    ],
    "explanation": "select语句用于同时监听多个通道操作，选择第一个就绪的操作执行。"
  },
  {
    "id": 44,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中原子操作的类型是？",
    "options": {
      "A": "Atomic",
      "B": "Mutex",
      "C": "Sync",
      "D": "Lock"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言提供 Atomic 类型用于实现原子操作。"
  },
  {
    "id": 45,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中异步函数的定义关键字是？",
    "options": {
      "A": "async",
      "B": "await",
      "C": "future",
      "D": "promise"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 async 关键字定义异步函数。"
  },
  {
    "id": 46,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言采用的内存管理方式是？",
    "options": {
      "A": "手动管理",
      "B": "自动垃圾回收",
      "C": "引用计数",
      "D": "所有权系统"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用自动垃圾回收机制管理内存。"
  },
  {
    "id": 47,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中弱引用的作用是？",
    "options": {
      "A": "避免循环引用",
      "B": "提高访问速度",
      "C": "减少内存占用",
      "D": "强制对象回收"
    },
    "answer": [
      "A"
    ],
    "explanation": "弱引用不会阻止垃圾回收器回收对象，常用于避免循环引用。"
  },
  {
    "id": 48,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中内存屏障的作用是？",
    "options": {
      "A": "保证内存访问顺序",
      "B": "提高内存分配速度",
      "C": "减少内存碎片",
      "D": "优化缓存使用"
    },
    "answer": [
      "A"
    ],
    "explanation": "内存屏障用于保证多线程环境下的内存访问顺序一致性。"
  },
  {
    "id": 49,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中数学函数库的导入方式是？",
    "options": {
      "A": "import math",
      "B": "import Math",
      "C": "using math",
      "D": "include Math"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 import Math 导入数学函数库。"
  },
  {
    "id": 50,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中文件操作的主要类是什么？",
    "options": {
      "A": "File",
      "B": "FileSystem",
      "C": "IO",
      "D": "Stream"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 File 类进行文件操作。"
  },
  {
    "id": 51,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中字符串分割的方法是什么？",
    "options": {
      "A": "split()",
      "B": "divide()",
      "C": "separate()",
      "D": "partition()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 split() 方法分割字符串。"
  },
  {
    "id": 52,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中获取当前时间的方法是什么？",
    "options": {
      "A": "Time.now()",
      "B": "DateTime.current()",
      "C": "System.currentTime()",
      "D": "Clock.now()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Time.now() 获取当前时间。"
  },
  {
    "id": 53,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中正则表达式的类是什么？",
    "options": {
      "A": "Regex",
      "B": "Pattern",
      "C": "RegExp",
      "D": "Matcher"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Regex 类处理正则表达式。"
  },
  {
    "id": 54,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中JSON序列化的方法是？",
    "options": {
      "A": "toJson()",
      "B": "serialize()",
      "C": "encode()",
      "D": "stringify()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 toJson() 方法将对象序列化为JSON字符串。"
  },
  {
    "id": 55,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中网络请求的库是什么？",
    "options": {
      "A": "HttpClient",
      "B": "Net",
      "C": "Web",
      "D": "Request"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 HttpClient 类进行HTTP网络请求。"
  },
  {
    "id": 56,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中数据库连接的主要类是什么？",
    "options": {
      "A": "Database",
      "B": "DB",
      "C": "Connection",
      "D": "SQL"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Database 类管理数据库连接。"
  },
  {
    "id": 57,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中日志记录的方法是？",
    "options": {
      "A": "Logger.log()",
      "B": "Console.log()",
      "C": "System.out()",
      "D": "print()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Logger 类进行日志记录。"
  },
  {
    "id": 58,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中泛型的主要作用是什么？",
    "options": {
      "A": "类型安全",
      "B": "代码复用",
      "C": "性能优化",
      "D": "A和B"
    },
    "answer": [
      "D"
    ],
    "explanation": "泛型提供类型安全和代码复用的好处。"
  },
  {
    "id": 59,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中注解的定义方式是？",
    "options": {
      "A": "@annotation",
      "B": "[Annotation]",
      "C": "annotation",
      "D": "#annotation"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 @ 符号定义注解。"
  },
  {
    "id": 60,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中反射API的主要类是什么？",
    "options": {
      "A": "Reflect",
      "B": "Mirror",
      "C": "Class",
      "D": "Type"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Mirror 类进行反射操作。"
  },
  {
    "id": 61,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中条件语句的关键字是什么？",
    "options": {
      "A": "if",
      "B": "when",
      "C": "switch",
      "D": "case"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 if 作为条件语句的关键字。"
  },
  {
    "id": 62,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中循环语句不包括以下哪个？",
    "options": {
      "A": "for",
      "B": "while",
      "C": "do-while",
      "D": "loop"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言支持 for、while 和 do-while 循环，没有 loop 关键字。"
  },
  {
    "id": 63,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中异常处理的关键字是什么？",
    "options": {
      "A": "try-catch",
      "B": "try-rescue",
      "C": "try-except",
      "D": "try-handle"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 try-catch 进行异常处理。"
  },
  {
    "id": 64,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中模式匹配的关键字是什么？",
    "options": {
      "A": "match",
      "B": "switch",
      "C": "case",
      "D": "pattern"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 match 关键字进行模式匹配。"
  },
  {
    "id": 65,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中类型断言的操作符是？",
    "options": {
      "A": "as",
      "B": "is",
      "C": "instanceof",
      "D": "typeof"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 as 操作符进行类型断言。"
  },
  {
    "id": 66,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中枚举的定义关键字是？",
    "options": {
      "A": "enum",
      "B": "Enum",
      "C": "enumeration",
      "D": "type"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 enum 关键字定义枚举类型。"
  },
  {
    "id": 67,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中集合类型的表示方式是？",
    "options": {
      "A": "Set<T>",
      "B": "Collection<T>",
      "C": "HashSet<T>",
      "D": "ListSet<T>"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Set<T> 表示集合类型。"
  },
  {
    "id": 68,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中链表的表示方式是？",
    "options": {
      "A": "LinkedList<T>",
      "B": "List<T>",
      "C": "Seq<T>",
      "D": "Chain<T>"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 List<T> 表示链表结构。"
  },
  {
    "id": 69,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中内联函数的关键字是？",
    "options": {
      "A": "inline",
      "B": "macro",
      "C": "direct",
      "D": "fast"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 inline 关键字定义内联函数。"
  },
  {
    "id": 70,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中函数重载的支持情况是？",
    "options": {
      "A": "支持",
      "B": "不支持",
      "C": "部分支持",
      "D": "仅支持运算符重载"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言支持函数重载，允许同名函数有不同参数列表。"
  },
  {
    "id": 71,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中构造函数的名称是？",
    "options": {
      "A": "constructor",
      "B": "init",
      "C": "new",
      "D": "与类名相同"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 init 作为构造函数名。"
  },
  {
    "id": 72,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中析构函数的名称是？",
    "options": {
      "A": "destructor",
      "B": "dispose",
      "C": "finalize",
      "D": "没有析构函数"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言使用自动垃圾回收，没有显式的析构函数。"
  },
  {
    "id": 73,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中静态成员的关键字是？",
    "options": {
      "A": "static",
      "B": "class",
      "C": "shared",
      "D": "global"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 static 关键字定义静态成员。"
  },
  {
    "id": 74,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中互斥锁的类是什么？",
    "options": {
      "A": "Mutex",
      "B": "Lock",
      "C": "Sync",
      "D": "Monitor"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Mutex 类实现互斥锁。"
  },
  {
    "id": 75,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中信号量的类是什么？",
    "options": {
      "A": "Semaphore",
      "B": "Signal",
      "C": "Event",
      "D": "Barrier"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Semaphore 类实现信号量。"
  },
  {
    "id": 76,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中手动内存分配的方法是什么？",
    "options": {
      "A": "allocate()",
      "B": "malloc()",
      "C": "new",
      "D": "不支持手动分配"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言完全依赖自动垃圾回收，不支持手动内存分配。"
  },
  {
    "id": 77,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中内存池的作用是？",
    "options": {
      "A": "提高内存分配效率",
      "B": "减少内存碎片",
      "C": "优化缓存使用",
      "D": "A和B"
    },
    "answer": [
      "D"
    ],
    "explanation": "内存池可以提高内存分配效率并减少内存碎片。"
  },
  {
    "id": 78,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中随机数生成的类是？",
    "options": {
      "A": "Random",
      "B": "Math.random()",
      "C": "Randomizer",
      "D": "Rand"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Random 类生成随机数。"
  },
  {
    "id": 79,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中压缩解压的库是什么？",
    "options": {
      "A": "Zip",
      "B": "Compress",
      "C": "Archive",
      "D": "Package"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Zip 类进行压缩解压操作。"
  },
  {
    "id": 80,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中加密解密的库是什么？",
    "options": {
      "A": "Crypto",
      "B": "Encrypt",
      "C": "Security",
      "D": "Cipher"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Crypto 库进行加密解密操作。"
  },
  {
    "id": 81,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中元编程的主要方式是？",
    "options": {
      "A": "宏",
      "B": "注解处理器",
      "C": "反射",
      "D": "模板"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言主要通过注解处理器实现元编程。"
  },
  {
    "id": 82,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中DSL（领域特定语言）的支持方式是？",
    "options": {
      "A": "扩展函数",
      "B": "中缀表达式",
      "C": "运算符重载",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言通过多种特性支持DSL创建。"
  },
  {
    "id": 83,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中协变和逆变的支持情况是？",
    "options": {
      "A": "支持协变",
      "B": "支持逆变",
      "C": "都支持",
      "D": "都不支持"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言通过声明处型变支持协变和逆变。"
  },
  {
    "id": 84,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中运算符重载的限制是？",
    "options": {
      "A": "只能重载已有运算符",
      "B": "不能创建新运算符",
      "C": "不能改变优先级",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言的运算符重载有诸多限制以保证代码可读性。"
  },
  {
    "id": 85,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中类型别名的定义关键字是？",
    "options": {
      "A": "type",
      "B": "alias",
      "C": "typedef",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 type 关键字定义类型别名。"
  },
  {
    "id": 86,
    "type": "single",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中位字段的定义方式是？",
    "options": {
      "A": "bitfield",
      "B": "flags",
      "C": "使用普通枚举",
      "D": "不支持位字段"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 flags 注解定义位字段枚举。"
  },
  {
    "id": 87,
    "type": "single",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中区间类型的特性是？",
    "options": {
      "A": "包含边界值",
      "B": "排除边界值",
      "C": "可自定义包含/排除",
      "D": "只能是整数区间"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言的区间类型可以自定义包含或排除边界值。"
  },
  {
    "id": 88,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数式接口的要求是？",
    "options": {
      "A": "只有一个抽象方法",
      "B": "有@FunctionalInterface注解",
      "C": "必须是接口",
      "D": "以上都是"
    },
    "answer": [
      "A"
    ],
    "explanation": "函数式接口只需要满足只有一个抽象方法的条件。"
  },
  {
    "id": 89,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中方法引用的语法是？",
    "options": {
      "A": "::",
      "B": ".",
      "C": "->",
      "D": "#"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 :: 语法进行方法引用。"
  },
  {
    "id": 90,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中代理模式的实现方式是？",
    "options": {
      "A": "使用proxy关键字",
      "B": "通过接口和委托",
      "C": "使用@Delegate注解",
      "D": "自动代理"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言通过接口和委托模式实现代理。"
  },
  {
    "id": 91,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中建造者模式的简化方式是？",
    "options": {
      "A": "使用@Builder注解",
      "B": "DSL语法",
      "C": "命名参数",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言提供多种方式简化建造者模式的实现。"
  },
  {
    "id": 92,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中Actor模型的主要类是？",
    "options": {
      "A": "Actor",
      "B": "Agent",
      "C": "Process",
      "D": "Worker"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Actor 类实现Actor模型。"
  },
  {
    "id": 93,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中事务内存的支持情况是？",
    "options": {
      "A": "完全支持",
      "B": "部分支持",
      "C": "实验性支持",
      "D": "不支持"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言提供实验性的事务内存支持。"
  },
  {
    "id": 94,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中内存泄漏的检测工具是？",
    "options": {
      "A": "内置分析器",
      "B": "第三方工具",
      "C": "日志分析",
      "D": "没有专门工具"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言内置内存分析器用于检测内存泄漏。"
  },
  {
    "id": 95,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中对象池的模式是？",
    "options": {
      "A": "享元模式",
      "B": "对象池模式",
      "C": "单例模式",
      "D": "原型模式"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言通过对象池模式管理频繁创建销毁的对象。"
  },
  {
    "id": 96,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中国际化支持的库是？",
    "options": {
      "A": "I18n",
      "B": "Locale",
      "C": "Globalize",
      "D": "International"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 I18n 库支持国际化。"
  },
  {
    "id": 97,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中测试框架的主要类是？",
    "options": {
      "A": "Test",
      "B": "TestCase",
      "C": "Spec",
      "D": "Assert"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 TestCase 类作为测试框架的基础。"
  },
  {
    "id": 98,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中性能剖析的API是？",
    "options": {
      "A": "Profiler",
      "B": "Benchmark",
      "C": "Performance",
      "D": "Metric"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Profiler 类进行性能剖析。"
  },
  {
    "id": 99,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中插件系统的架构基于？",
    "options": {
      "A": "OSGi",
      "B": "SPI",
      "C": "自定义架构",
      "D": "微内核"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言的插件系统基于SPI（Service Provider Interface）架构。"
  },
  {
    "id": 100,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中热代码替换的支持情况是？",
    "options": {
      "A": "完全支持",
      "B": "开发环境支持",
      "C": "部分支持",
      "D": "不支持"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言在开发环境中支持热代码替换，便于快速迭代。"
  },
  {
    "id": 101,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中声明常量的关键字是？",
    "options": {
      "A": "const",
      "B": "val",
      "C": "final",
      "D": "constant"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 val 关键字声明不可变的常量。"
  },
  {
    "id": 102,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中三元条件运算符的语法是？",
    "options": {
      "A": "a ? b : c",
      "B": "if a then b else c",
      "C": "a -> b : c",
      "D": "不支持三元运算符"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言不支持三元运算符，使用 if-else 表达式代替。"
  },
  {
    "id": 103,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中字符串连接的运算符是？",
    "options": {
      "A": "+",
      "B": "&",
      "C": "++",
      "D": "concat"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 + 运算符进行字符串连接。"
  },
  {
    "id": 104,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中数组长度的获取方法是？",
    "options": {
      "A": "length",
      "B": "size",
      "C": "count",
      "D": "len"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 size 方法获取数组长度。"
  },
  {
    "id": 105,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中范围运算符的语法是？",
    "options": {
      "A": "..",
      "B": "...",
      "C": "to",
      "D": "range"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 .. 运算符创建范围。"
  },
  {
    "id": 106,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中空安全运算符的语法是？",
    "options": {
      "A": "?.",
      "B": "!!",
      "C": "?:",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言提供 ?.、!! 和 ?: 等多种空安全运算符。"
  },
  {
    "id": 107,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中 Elvis 运算符的作用是？",
    "options": {
      "A": "空值检查",
      "B": "提供默认值",
      "C": "类型转换",
      "D": "条件判断"
    },
    "answer": [
      "B"
    ],
    "explanation": "Elvis 运算符 ?: 用于在值为空时提供默认值。"
  },
  {
    "id": 108,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中安全转换运算符的语法是？",
    "options": {
      "A": "as?",
      "B": "as",
      "C": "cast",
      "D": "convert"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 as? 进行安全类型转换，转换失败返回 null。"
  },
  {
    "id": 109,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中标签语法的用途是？",
    "options": {
      "A": "标记循环",
      "B": "标记代码块",
      "C": "配合 break/continue 使用",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "标签用于标记代码块，配合 break 和 continue 实现跳转。"
  },
  {
    "id": 110,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中委托属性的关键字是？",
    "options": {
      "A": "by",
      "B": "delegate",
      "C": "with",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 by 关键字实现委托属性。"
  },
  {
    "id": 111,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中字节类型的表示是？",
    "options": {
      "A": "byte",
      "B": "Byte",
      "C": "char",
      "D": "int8"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Byte 表示字节类型。"
  },
  {
    "id": 112,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中短整型的表示是？",
    "options": {
      "A": "short",
      "B": "Short",
      "C": "int16",
      "D": "smallint"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Short 表示短整型。"
  },
  {
    "id": 113,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中长整型的表示是？",
    "options": {
      "A": "long",
      "B": "Long",
      "C": "int64",
      "D": "bigint"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Long 表示长整型。"
  },
  {
    "id": 114,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中双精度浮点型的表示是？",
    "options": {
      "A": "double",
      "B": "Double",
      "C": "float64",
      "D": "decimal"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Double 表示双精度浮点型。"
  },
  {
    "id": 115,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中任意类型的表示是？",
    "options": {
      "A": "any",
      "B": "Any",
      "C": "object",
      "D": "Object"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Any 表示任意类型，是所有类型的超类。"
  },
  {
    "id": 116,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中单位类型的表示是？",
    "options": {
      "A": "void",
      "B": "Unit",
      "C": "None",
      "D": "Null"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Unit 表示没有有意义返回值的函数返回类型。"
  },
  {
    "id": 117,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中 Nothing 类型的作用是？",
    "options": {
      "A": "表示函数从不返回",
      "B": "表示空集合",
      "C": "表示未初始化",
      "D": "表示错误状态"
    },
    "answer": [
      "A"
    ],
    "explanation": "Nothing 类型表示函数永远不会正常返回（总是抛出异常）。"
  },
  {
    "id": 118,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中可空类型的表示是？",
    "options": {
      "A": "Nullable<T>",
      "B": "T?",
      "C": "Optional<T>",
      "D": "Maybe<T>"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 T? 表示可空类型。"
  },
  {
    "id": 119,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中数组的初始化语法是？",
    "options": {
      "A": "arrayOf(1, 2, 3)",
      "B": "[1, 2, 3]",
      "C": "Array(1, 2, 3)",
      "D": "new Array(1, 2, 3)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 arrayOf 函数初始化数组。"
  },
  {
    "id": 120,
    "type": "single",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中只读列表的接口是？",
    "options": {
      "A": "List",
      "B": "MutableList",
      "C": "ReadOnlyList",
      "D": "ImmutableList"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 List 接口表示只读列表，MutableList 表示可变列表。"
  },
  {
    "id": 121,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中函数定义的关键字是？",
    "options": {
      "A": "func",
      "B": "function",
      "C": "def",
      "D": "fn"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 function 关键字定义函数。"
  },
  {
    "id": 122,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中返回值类型的声明位置是？",
    "options": {
      "A": "函数名前",
      "B": "参数列表后",
      "C": "函数体前",
      "D": "可选的"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言在参数列表后使用冒号声明返回值类型。"
  },
  {
    "id": 123,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中单表达式函数的简化语法是？",
    "options": {
      "A": "function add(a, b) = a + b",
      "B": "function add(a, b) => a + b",
      "C": "function add(a, b): a + b",
      "D": "function add(a, b) { a + b }"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 = 符号简化单表达式函数。"
  },
  {
    "id": 124,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中命名参数的调用语法是？",
    "options": {
      "A": "function(param = value)",
      "B": "function(param: value)",
      "C": "function{param = value}",
      "D": "function<param = value>"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 param = value 语法调用命名参数。"
  },
  {
    "id": 125,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中扩展函数的定义语法是？",
    "options": {
      "A": "function Type.method()",
      "B": "function Type::method()",
      "C": "function method(this Type)",
      "D": "Type.function method()"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言使用 function method(this Type) 语法定义扩展函数。"
  },
  {
    "id": 126,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中中缀函数的标记是？",
    "options": {
      "A": "infix",
      "B": "operator",
      "C": "inline",
      "D": "tailrec"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 infix 关键字标记中缀函数。"
  },
  {
    "id": 127,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中局部函数的定义位置是？",
    "options": {
      "A": "其他函数内部",
      "B": "类内部",
      "C": "文件顶层",
      "D": "以上都可以"
    },
    "answer": [
      "A"
    ],
    "explanation": "局部函数定义在其他函数内部，只能在该函数内访问。"
  },
  {
    "id": 128,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数类型的表示是？",
    "options": {
      "A": "(参数类型) -> 返回类型",
      "B": "Function<参数类型, 返回类型>",
      "C": "参数类型 => 返回类型",
      "D": "func(参数类型): 返回类型"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 (参数类型) -> 返回类型 表示函数类型。"
  },
  {
    "id": 129,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中带接收者的函数类型语法是？",
    "options": {
      "A": "接收者类型.(参数类型) -> 返回类型",
      "B": "接收者类型 -> (参数类型) -> 返回类型",
      "C": "(接收者类型, 参数类型) -> 返回类型",
      "D": "接收者类型.函数类型"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 接收者类型.(参数类型) -> 返回类型 表示带接收者的函数类型。"
  },
  {
    "id": 130,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中 SAM 转换的支持情况是？",
    "options": {
      "A": "支持",
      "B": "不支持",
      "C": "部分支持",
      "D": "仅支持Java接口"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言支持SAM（Single Abstract Method）转换，允许将函数字面量转换为接口实例。"
  },
  {
    "id": 131,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中实例化对象的关键字是？",
    "options": {
      "A": "new",
      "B": "create",
      "C": "instance",
      "D": "不需要关键字"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言直接使用类名加括号实例化对象，不需要 new 关键字。"
  },
  {
    "id": 132,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中访问当前对象的引用是？",
    "options": {
      "A": "this",
      "B": "self",
      "C": "me",
      "D": "current"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 this 引用当前对象。"
  },
  {
    "id": 133,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中访问父类方法的引用是？",
    "options": {
      "A": "super",
      "B": "base",
      "C": "parent",
      "D": "upper"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 super 引用父类的方法和属性。"
  },
  {
    "id": 134,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中初始化块的关键字是？",
    "options": {
      "A": "init",
      "B": "static",
      "C": "block",
      "D": "constructor"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 init 关键字定义初始化块。"
  },
  {
    "id": 135,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中次级构造函数的定义关键字是？",
    "options": {
      "A": "constructor",
      "B": "init",
      "C": "secondary",
      "D": "auxiliary"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 constructor 关键字定义次级构造函数。"
  },
  {
    "id": 136,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中对象表达式的关键字是？",
    "options": {
      "A": "object",
      "B": "anonymous",
      "C": "new",
      "D": "instance"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 object 关键字创建匿名对象（对象表达式）。"
  },
  {
    "id": 137,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中对象声明的关键字是？",
    "options": {
      "A": "object",
      "B": "singleton",
      "C": "static",
      "D": "global"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 object 关键字声明单例对象（对象声明）。"
  },
  {
    "id": 138,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中内联类的关键字是？",
    "options": {
      "A": "inline class",
      "B": "value class",
      "C": "data class",
      "D": "primitive class"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 inline class 定义内联类，用于类型安全包装基本类型。"
  },
  {
    "id": 139,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中委托类的关键字是？",
    "options": {
      "A": "by",
      "B": "delegate",
      "C": "with",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 by 关键字实现类委托。"
  },
  {
    "id": 140,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中属性委托的常用类是？",
    "options": {
      "A": "Delegates",
      "B": "Properties",
      "C": "Attributes",
      "D": "Values"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言标准库提供 Delegates 类包含常用的属性委托实现。"
  },
  {
    "id": 141,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中创建协程的作用域函数是？",
    "options": {
      "A": "coroutineScope",
      "B": "asyncScope",
      "C": "launchScope",
      "D": "runBlocking"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 coroutineScope 函数创建协程作用域。"
  },
  {
    "id": 142,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中启动新协程的函数是？",
    "options": {
      "A": "launch",
      "B": "async",
      "C": "spawn",
      "D": "start"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 launch 函数启动不返回结果的新协程。"
  },
  {
    "id": 143,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中启动异步计算的函数是？",
    "options": {
      "A": "async",
      "B": "launch",
      "C": "future",
      "D": "promise"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 async 函数启动返回 Deferred 结果的异步计算。"
  },
  {
    "id": 144,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中等待异步结果的关键字是？",
    "options": {
      "A": "await",
      "B": "wait",
      "C": "block",
      "D": "get"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 await 关键字等待异步计算的结果。"
  },
  {
    "id": 145,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中协程调度器的接口是？",
    "options": {
      "A": "Dispatcher",
      "B": "Scheduler",
      "C": "Executor",
      "D": "CoroutineContext"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Dispatcher 接口管理协程的调度。"
  },
  {
    "id": 146,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中通道的关闭方法是？",
    "options": {
      "A": "close()",
      "B": "shutdown()",
      "C": "end()",
      "D": "finish()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 close() 方法关闭通道。"
  },
  {
    "id": 147,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中 select 表达式的作用是？",
    "options": {
      "A": "多路复用多个挂起函数",
      "B": "数据库查询",
      "C": "条件选择",
      "D": "模式匹配"
    },
    "answer": [
      "A"
    ],
    "explanation": "select 表达式用于同时等待多个挂起操作，选择第一个可用的结果。"
  },
  {
    "id": 148,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中流(Flow)的创建函数是？",
    "options": {
      "A": "flow",
      "B": "stream",
      "C": "sequence",
      "D": "pipeline"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 flow 函数创建异步数据流。"
  },
  {
    "id": 149,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中共享流的函数是？",
    "options": {
      "A": "shareIn",
      "B": "broadcast",
      "C": "publish",
      "D": "multicast"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 shareIn 函数将冷流转换为热流（共享流）。"
  },
  {
    "id": 150,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中状态流(StateFlow)的特点是？",
    "options": {
      "A": "有当前值",
      "B": "可被多个收集器共享",
      "C": "支持并发更新",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "StateFlow 是有当前值的、可共享的、支持并发更新的热数据流。"
  },
  {
    "id": 151,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中垃圾回收的主要算法是？",
    "options": {
      "A": "标记-清除",
      "B": "引用计数",
      "C": "分代收集",
      "D": "增量回收"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言采用分代垃圾回收算法，根据不同代的对象采用不同的回收策略。"
  },
  {
    "id": 152,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中如何手动触发垃圾回收？",
    "options": {
      "A": "System.gc()",
      "B": "Runtime.getRuntime().gc()",
      "C": "GC.collect()",
      "D": "不支持手动触发"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言不提供手动触发垃圾回收的接口，由运行时自动管理。"
  },
  {
    "id": 153,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中弱引用的类名是？",
    "options": {
      "A": "WeakReference",
      "B": "SoftReference",
      "C": "PhantomReference",
      "D": "Weak"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 WeakReference 类表示弱引用。"
  },
  {
    "id": 154,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中对象生命周期的最后阶段是？",
    "options": {
      "A": "可达性分析",
      "B": "终结阶段",
      "C": "回收阶段",
      "D": "清理阶段"
    },
    "answer": [
      "B"
    ],
    "explanation": "对象在垃圾回收前会经历终结阶段（finalization），允许对象执行清理操作。"
  },
  {
    "id": 155,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中内存泄漏的常见原因是？",
    "options": {
      "A": "静态集合类持有对象引用",
      "B": "连接未关闭",
      "C": "监听器未移除",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "静态集合、未关闭的连接和未移除的监听器都可能导致内存泄漏。"
  },
  {
    "id": 156,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中如何检测内存泄漏？",
    "options": {
      "A": "使用内存分析工具",
      "B": "查看日志",
      "C": "代码审查",
      "D": "性能测试"
    },
    "answer": [
      "A"
    ],
    "explanation": "内存泄漏通常使用内存分析工具（如堆转储分析）来检测。"
  },
  {
    "id": 157,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中软引用(SoftReference)的特点是？",
    "options": {
      "A": "只有弱引用指向的对象会被回收",
      "B": "在内存不足时会被回收",
      "C": "永远不会被回收",
      "D": "必须手动释放"
    },
    "answer": [
      "B"
    ],
    "explanation": "软引用指向的对象在内存不足时会被垃圾回收器回收。"
  },
  {
    "id": 158,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中幻象引用(PhantomReference)的主要用途是？",
    "options": {
      "A": "对象复活",
      "B": "跟踪对象被回收的时间",
      "C": "缓存实现",
      "D": "避免循环引用"
    },
    "answer": [
      "B"
    ],
    "explanation": "幻象引用用于跟踪对象被垃圾回收的时间，通常用于执行清理操作。"
  },
  {
    "id": 159,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中读取控制台输入的函数是？",
    "options": {
      "A": "readLine()",
      "B": "Console.read()",
      "C": "System.in.read()",
      "D": "Scanner.next()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 readLine() 函数从控制台读取一行输入。"
  },
  {
    "id": 160,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中数学常量π的表示是？",
    "options": {
      "A": "Math.PI",
      "B": "Math.pi",
      "C": "Math.Pi",
      "D": "Math.PI_2"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Math.PI 表示数学常量π。"
  },
  {
    "id": 161,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中生成随机数的类是？",
    "options": {
      "A": "Random",
      "B": "Math.random()",
      "C": "Randomizer",
      "D": "Rand"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Random 类生成随机数。"
  },
  {
    "id": 162,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中字符串格式化的函数是？",
    "options": {
      "A": "format()",
      "B": "printf()",
      "C": "String.format()",
      "D": "Formatter.format()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 format() 函数格式化字符串。"
  },
  {
    "id": 163,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中正则表达式匹配的函数是？",
    "options": {
      "A": "matches()",
      "B": "match()",
      "C": "find()",
      "D": "search()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 matches() 函数进行正则表达式匹配。"
  },
  {
    "id": 164,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中日期时间处理的类库是？",
    "options": {
      "A": "DateTime",
      "B": "Calendar",
      "C": "Time",
      "D": "LocalDateTime"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 DateTime 类处理日期和时间。"
  },
  {
    "id": 165,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中文件读写的类库是？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "FileSystem",
      "D": "IO"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 File 类进行文件操作。"
  },
  {
    "id": 166,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中网络编程的类库是？",
    "options": {
      "A": "Net",
      "B": "Socket",
      "C": "Network",
      "D": "Web"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Socket 类进行网络编程。"
  },
  {
    "id": 167,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中数据库连接的标准接口是？",
    "options": {
      "A": "Database",
      "B": "Connection",
      "C": "DataSource",
      "D": "DB"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Connection 接口表示数据库连接。"
  },
  {
    "id": 168,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中并发集合的包名是？",
    "options": {
      "A": "concurrent",
      "B": "atomic",
      "C": "sync",
      "D": "thread"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的并发集合位于 concurrent 包中。"
  },
  {
    "id": 169,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中注解的定义关键字是？",
    "options": {
      "A": "@annotation",
      "B": "annotation",
      "C": "@interface",
      "D": "annotation class"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言使用 'annotation class' 定义注解。"
  },
  {
    "id": 170,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中泛型类型参数的通配符是？",
    "options": {
      "A": "?",
      "B": "*",
      "C": "T",
      "D": "Any"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ? 作为泛型通配符。"
  },
  {
    "id": 171,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中类型投影的关键字是？",
    "options": {
      "A": "out",
      "B": "in",
      "C": "projected",
      "D": "variant"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 out 关键字进行协变类型投影。"
  },
  {
    "id": 172,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中逆变类型投影的关键字是？",
    "options": {
      "A": "in",
      "B": "out",
      "C": "contra",
      "D": "negative"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 in 关键字进行逆变类型投影。"
  },
  {
    "id": 173,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中反射API的入口类是？",
    "options": {
      "A": "Class",
      "B": "Type",
      "C": "Reflect",
      "D": "Mirror"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Class 类作为反射的入口。"
  },
  {
    "id": 174,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中动态代理的接口是？",
    "options": {
      "A": "Proxy",
      "B": "Delegate",
      "C": "InvocationHandler",
      "D": "DynamicProxy"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Proxy 接口创建动态代理。"
  },
  {
    "id": 175,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中元注解的作用是？",
    "options": {
      "A": "注解其他注解",
      "B": "元编程",
      "C": "编译时处理",
      "D": "运行时反射"
    },
    "answer": [
      "A"
    ],
    "explanation": "元注解用于注解其他注解，定义注解的行为。"
  },
  {
    "id": 176,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中编译时注解处理器的基类是？",
    "options": {
      "A": "AnnotationProcessor",
      "B": "AbstractProcessor",
      "C": "Processor",
      "D": "CompileProcessor"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言中编译时注解处理器继承 AbstractProcessor 类。"
  },
  {
    "id": 177,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中类型擦除的含义是？",
    "options": {
      "A": "泛型类型信息在运行时不可用",
      "B": "删除未使用的类型",
      "C": "优化类型存储",
      "D": "类型安全检查"
    },
    "answer": [
      "A"
    ],
    "explanation": "类型擦除指泛型类型信息在编译后会被擦除，运行时不可用。"
  },
  {
    "id": 178,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中内联函数的作用是？",
    "options": {
      "A": "减少函数调用开销",
      "B": "代码展开",
      "C": "性能优化",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "内联函数通过将函数体插入调用处来减少调用开销，优化性能。"
  },
  {
    "id": 179,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中不等于运算符是？",
    "options": {
      "A": "!=",
      "B": "<>",
      "C": "≠",
      "D": "!=="
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 != 表示不等于。"
  },
  {
    "id": 180,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑与运算符是？",
    "options": {
      "A": "&&",
      "B": "and",
      "C": "&",
      "D": "AND"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 && 表示逻辑与。"
  },
  {
    "id": 181,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑或运算符是？",
    "options": {
      "A": "||",
      "B": "or",
      "C": "|",
      "D": "OR"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 || 表示逻辑或。"
  },
  {
    "id": 182,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑非运算符是？",
    "options": {
      "A": "!",
      "B": "not",
      "C": "~",
      "D": "NOT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ! 表示逻辑非。"
  },
  {
    "id": 183,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位与运算符是？",
    "options": {
      "A": "&",
      "B": "and",
      "C": "&&",
      "D": "BITAND"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 & 表示位与运算。"
  },
  {
    "id": 184,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位或运算符是？",
    "options": {
      "A": "|",
      "B": "or",
      "C": "||",
      "D": "BITOR"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 | 表示位或运算。"
  },
  {
    "id": 185,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位异或运算符是？",
    "options": {
      "A": "^",
      "B": "xor",
      "C": "^^",
      "D": "BITXOR"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ^ 表示位异或运算。"
  },
  {
    "id": 186,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位取反运算符是？",
    "options": {
      "A": "~",
      "B": "!",
      "C": "not",
      "D": "BITNOT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ~ 表示位取反运算。"
  },
  {
    "id": 187,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中左移运算符是？",
    "options": {
      "A": "<<",
      "B": ">>",
      "C": ">>>",
      "D": "LSHIFT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 << 表示左移运算。"
  },
  {
    "id": 188,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中右移运算符是？",
    "options": {
      "A": ">>",
      "B": "<<",
      "C": ">>>",
      "D": "RSHIFT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 >> 表示带符号右移运算。"
  },
  {
    "id": 189,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中无符号右移运算符是？",
    "options": {
      "A": ">>>",
      "B": ">>",
      "C": "<<",
      "D": "URSHIFT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 >>> 表示无符号右移运算。"
  },
  {
    "id": 190,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中运算符的优先级最高的是？",
    "options": {
      "A": "括号",
      "B": "乘除",
      "C": "加减",
      "D": "赋值"
    },
    "answer": [
      "A"
    ],
    "explanation": "括号运算符的优先级最高，可以改变表达式的计算顺序。"
  },
  {
    "id": 191,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中函数返回值的指定关键字是？",
    "options": {
      "A": "return",
      "B": "result",
      "C": "yield",
      "D": "back"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 return 关键字指定函数返回值。"
  },
  {
    "id": 192,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中函数参数的默认传递方式是？",
    "options": {
      "A": "值传递",
      "B": "引用传递",
      "C": "指针传递",
      "D": "依类型而定"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言函数参数默认采用值传递方式。"
  },
  {
    "id": 193,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中可变参数的关键字是？",
    "options": {
      "A": "varargs",
      "B": "params",
      "C": "args",
      "D": "..."
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 varargs 关键字声明可变参数。"
  },
  {
    "id": 194,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中高阶函数是指？",
    "options": {
      "A": "接受函数作为参数或返回函数的函数",
      "B": "执行效率高的函数",
      "C": "代码复杂的函数",
      "D": "递归函数"
    },
    "answer": [
      "A"
    ],
    "explanation": "高阶函数是接受函数作为参数或返回函数的函数。"
  },
  {
    "id": 195,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中Lambda表达式的语法是？",
    "options": {
      "A": "{ 参数 -> 表达式 }",
      "B": "(参数) -> 表达式",
      "C": "参数 => 表达式",
      "D": "函数(参数) = 表达式"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 { 参数 -> 表达式 } 语法定义Lambda表达式。"
  },
  {
    "id": 196,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中尾递归优化的关键字是？",
    "options": {
      "A": "tailrec",
      "B": "inline",
      "C": "optimize",
      "D": "recursive"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 tailrec 关键字标记尾递归函数以进行优化。"
  },
  {
    "id": 197,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数组合的标准库函数是？",
    "options": {
      "A": "compose",
      "B": "andThen",
      "C": "pipe",
      "D": "flow"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 compose 函数进行函数组合。"
  },
  {
    "id": 198,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中部分应用函数的创建方法是？",
    "options": {
      "A": "使用下划线 _ 占位",
      "B": "使用partial函数",
      "C": "使用bind函数",
      "D": "使用curry函数"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用下划线 _ 作为参数占位符创建部分应用函数。"
  },
  {
    "id": 199,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数柯里化的实现方式是？",
    "options": {
      "A": "手动创建返回函数的函数",
      "B": "使用curry关键字",
      "C": "自动柯里化",
      "D": "不支持柯里化"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言需要手动创建返回函数的函数来实现柯里化。"
  },
  {
    "id": 200,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数记忆化(Memoization)的实现方式是？",
    "options": {
      "A": "使用缓存装饰器",
      "B": "自动记忆",
      "C": "使用memoize函数",
      "D": "手动缓存"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言可以通过装饰器模式实现函数记忆化，缓存函数结果。"
  },
  {
    "id": 201,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中垃圾回收的主要算法是？",
    "options": {
      "A": "标记-清除",
      "B": "引用计数",
      "C": "分代收集",
      "D": "增量回收"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言采用分代垃圾回收算法，根据不同代的对象采用不同的回收策略。"
  },
  {
    "id": 202,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中如何手动触发垃圾回收？",
    "options": {
      "A": "System.gc()",
      "B": "Runtime.getRuntime().gc()",
      "C": "GC.collect()",
      "D": "不支持手动触发"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言不提供手动触发垃圾回收的接口，由运行时自动管理。"
  },
  {
    "id": 203,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中弱引用的类名是？",
    "options": {
      "A": "WeakReference",
      "B": "SoftReference",
      "C": "PhantomReference",
      "D": "Weak"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 WeakReference 类表示弱引用。"
  },
  {
    "id": 204,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中对象生命周期的最后阶段是？",
    "options": {
      "A": "可达性分析",
      "B": "终结阶段",
      "C": "回收阶段",
      "D": "清理阶段"
    },
    "answer": [
      "B"
    ],
    "explanation": "对象在垃圾回收前会经历终结阶段（finalization），允许对象执行清理操作。"
  },
  {
    "id": 205,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中内存泄漏的常见原因是？",
    "options": {
      "A": "静态集合类持有对象引用",
      "B": "连接未关闭",
      "C": "监听器未移除",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "静态集合、未关闭的连接和未移除的监听器都可能导致内存泄漏。"
  },
  {
    "id": 206,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中如何检测内存泄漏？",
    "options": {
      "A": "使用内存分析工具",
      "B": "查看日志",
      "C": "代码审查",
      "D": "性能测试"
    },
    "answer": [
      "A"
    ],
    "explanation": "内存泄漏通常使用内存分析工具（如堆转储分析）来检测。"
  },
  {
    "id": 207,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中软引用(SoftReference)的特点是？",
    "options": {
      "A": "只有弱引用指向的对象会被回收",
      "B": "在内存不足时会被回收",
      "C": "永远不会被回收",
      "D": "必须手动释放"
    },
    "answer": [
      "B"
    ],
    "explanation": "软引用指向的对象在内存不足时会被垃圾回收器回收。"
  },
  {
    "id": 208,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中幻象引用(PhantomReference)的主要用途是？",
    "options": {
      "A": "对象复活",
      "B": "跟踪对象被回收的时间",
      "C": "缓存实现",
      "D": "避免循环引用"
    },
    "answer": [
      "B"
    ],
    "explanation": "幻象引用用于跟踪对象被垃圾回收的时间，通常用于执行清理操作。"
  },
  {
    "id": 209,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中读取控制台输入的函数是？",
    "options": {
      "A": "readLine()",
      "B": "Console.read()",
      "C": "System.in.read()",
      "D": "Scanner.next()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 readLine() 函数从控制台读取一行输入。"
  },
  {
    "id": 210,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中数学常量π的表示是？",
    "options": {
      "A": "Math.PI",
      "B": "Math.pi",
      "C": "Math.Pi",
      "D": "Math.PI_2"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Math.PI 表示数学常量π。"
  },
  {
    "id": 211,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中集合操作的高阶函数不包括？",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "reduce",
      "D": "loop"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言提供 map、filter、reduce 等高阶函数，但没有 loop 函数。"
  },
  {
    "id": 212,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中字符串格式化的函数是？",
    "options": {
      "A": "format()",
      "B": "printf()",
      "C": "String.format()",
      "D": "Formatter.format()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 format() 函数格式化字符串。"
  },
  {
    "id": 213,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中正则表达式匹配的函数是？",
    "options": {
      "A": "matches()",
      "B": "match()",
      "C": "find()",
      "D": "search()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 matches() 函数进行正则表达式匹配。"
  },
  {
    "id": 214,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中日期时间处理的类库是？",
    "options": {
      "A": "DateTime",
      "B": "Calendar",
      "C": "Time",
      "D": "LocalDateTime"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 DateTime 类处理日期和时间。"
  },
  {
    "id": 215,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中文件读写的类库是？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "FileSystem",
      "D": "IO"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 File 类进行文件操作。"
  },
  {
    "id": 216,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中网络编程的类库是？",
    "options": {
      "A": "Net",
      "B": "Socket",
      "C": "Network",
      "D": "Web"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Socket 类进行网络编程。"
  },
  {
    "id": 217,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中数据库连接的标准接口是？",
    "options": {
      "A": "Database",
      "B": "Connection",
      "C": "DataSource",
      "D": "DB"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 Connection 接口表示数据库连接。"
  },
  {
    "id": 218,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中并发集合的包名是？",
    "options": {
      "A": "concurrent",
      "B": "atomic",
      "C": "sync",
      "D": "thread"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的并发集合位于 concurrent 包中。"
  },
  {
    "id": 219,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中注解的定义关键字是？",
    "options": {
      "A": "@annotation",
      "B": "annotation",
      "C": "@interface",
      "D": "annotation class"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言使用 'annotation class' 定义注解。"
  },
  {
    "id": 220,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中泛型类型参数的通配符是？",
    "options": {
      "A": "?",
      "B": "*",
      "C": "T",
      "D": "Any"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ? 作为泛型通配符。"
  },
  {
    "id": 221,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中类型投影的关键字是？",
    "options": {
      "A": "out",
      "B": "in",
      "C": "projected",
      "D": "variant"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 out 关键字进行协变类型投影。"
  },
  {
    "id": 222,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中逆变类型投影的关键字是？",
    "options": {
      "A": "in",
      "B": "out",
      "C": "contra",
      "D": "negative"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 in 关键字进行逆变类型投影。"
  },
  {
    "id": 223,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中反射API的入口类是？",
    "options": {
      "A": "Class",
      "B": "Type",
      "C": "Reflect",
      "D": "Mirror"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Class 类作为反射的入口。"
  },
  {
    "id": 224,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中动态代理的接口是？",
    "options": {
      "A": "Proxy",
      "B": "Delegate",
      "C": "InvocationHandler",
      "D": "DynamicProxy"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Proxy 接口创建动态代理。"
  },
  {
    "id": 225,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中元注解的作用是？",
    "options": {
      "A": "注解其他注解",
      "B": "元编程",
      "C": "编译时处理",
      "D": "运行时反射"
    },
    "answer": [
      "A"
    ],
    "explanation": "元注解用于注解其他注解，定义注解的行为。"
  },
  {
    "id": 226,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中编译时注解处理器的基类是？",
    "options": {
      "A": "AnnotationProcessor",
      "B": "AbstractProcessor",
      "C": "Processor",
      "D": "CompileProcessor"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言中编译时注解处理器继承 AbstractProcessor 类。"
  },
  {
    "id": 227,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中类型擦除的含义是？",
    "options": {
      "A": "泛型类型信息在运行时不可用",
      "B": "删除未使用的类型",
      "C": "优化类型存储",
      "D": "类型安全检查"
    },
    "answer": [
      "A"
    ],
    "explanation": "类型擦除指泛型类型信息在编译后会被擦除，运行时不可用。"
  },
  {
    "id": 228,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中内联函数的作用是？",
    "options": {
      "A": "减少函数调用开销",
      "B": "代码展开",
      "C": "性能优化",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "内联函数通过将函数体插入调用处来减少调用开销，优化性能。"
  },
  {
    "id": 229,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中不等于运算符是？",
    "options": {
      "A": "!=",
      "B": "<>",
      "C": "≠",
      "D": "!=="
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 != 表示不等于。"
  },
  {
    "id": 230,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑与运算符是？",
    "options": {
      "A": "&&",
      "B": "and",
      "C": "&",
      "D": "AND"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 && 表示逻辑与。"
  },
  {
    "id": 231,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑或运算符是？",
    "options": {
      "A": "||",
      "B": "or",
      "C": "|",
      "D": "OR"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 || 表示逻辑或。"
  },
  {
    "id": 232,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑非运算符是？",
    "options": {
      "A": "!",
      "B": "not",
      "C": "~",
      "D": "NOT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ! 表示逻辑非。"
  },
  {
    "id": 233,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位与运算符是？",
    "options": {
      "A": "&",
      "B": "and",
      "C": "&&",
      "D": "BITAND"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 & 表示位与运算。"
  },
  {
    "id": 234,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位或运算符是？",
    "options": {
      "A": "|",
      "B": "or",
      "C": "||",
      "D": "BITOR"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 | 表示位或运算。"
  },
  {
    "id": 235,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位异或运算符是？",
    "options": {
      "A": "^",
      "B": "xor",
      "C": "^^",
      "D": "BITXOR"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ^ 表示位异或运算。"
  },
  {
    "id": 236,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中位取反运算符是？",
    "options": {
      "A": "~",
      "B": "!",
      "C": "not",
      "D": "BITNOT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ~ 表示位取反运算。"
  },
  {
    "id": 237,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中左移运算符是？",
    "options": {
      "A": "<<",
      "B": ">>",
      "C": ">>>",
      "D": "LSHIFT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 << 表示左移运算。"
  },
  {
    "id": 238,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中右移运算符是？",
    "options": {
      "A": ">>",
      "B": "<<",
      "C": ">>>",
      "D": "RSHIFT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 >> 表示带符号右移运算。"
  },
  {
    "id": 239,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中无符号右移运算符是？",
    "options": {
      "A": ">>>",
      "B": ">>",
      "C": "<<",
      "D": "URSHIFT"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 >>> 表示无符号右移运算。"
  },
  {
    "id": 240,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中运算符的优先级最高的是？",
    "options": {
      "A": "括号",
      "B": "乘除",
      "C": "加减",
      "D": "赋值"
    },
    "answer": [
      "A"
    ],
    "explanation": "括号运算符的优先级最高，可以改变表达式的计算顺序。"
  },
  {
    "id": 241,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中函数返回值的指定关键字是？",
    "options": {
      "A": "return",
      "B": "result",
      "C": "yield",
      "D": "back"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 return 关键字指定函数返回值。"
  },
  {
    "id": 242,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中函数参数的默认传递方式是？",
    "options": {
      "A": "值传递",
      "B": "引用传递",
      "C": "指针传递",
      "D": "依类型而定"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言函数参数默认采用值传递方式。"
  },
  {
    "id": 243,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中可变参数的关键字是？",
    "options": {
      "A": "varargs",
      "B": "params",
      "C": "args",
      "D": "..."
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 varargs 关键字声明可变参数。"
  },
  {
    "id": 244,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中高阶函数是指？",
    "options": {
      "A": "接受函数作为参数或返回函数的函数",
      "B": "执行效率高的函数",
      "C": "代码复杂的函数",
      "D": "递归函数"
    },
    "answer": [
      "A"
    ],
    "explanation": "高阶函数是接受函数作为参数或返回函数的函数。"
  },
  {
    "id": 245,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中Lambda表达式的语法是？",
    "options": {
      "A": "{ 参数 -> 表达式 }",
      "B": "(参数) -> 表达式",
      "C": "参数 => 表达式",
      "D": "函数(参数) = 表达式"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 { 参数 -> 表达式 } 语法定义Lambda表达式。"
  },
  {
    "id": 246,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中尾递归优化的关键字是？",
    "options": {
      "A": "tailrec",
      "B": "inline",
      "C": "optimize",
      "D": "recursive"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 tailrec 关键字标记尾递归函数以进行优化。"
  },
  {
    "id": 247,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数组合的标准库函数是？",
    "options": {
      "A": "compose",
      "B": "andThen",
      "C": "pipe",
      "D": "flow"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 compose 函数进行函数组合。"
  },
  {
    "id": 248,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中部分应用函数的创建方法是？",
    "options": {
      "A": "使用下划线 _ 占位",
      "B": "使用partial函数",
      "C": "使用bind函数",
      "D": "使用curry函数"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用下划线 _ 作为参数占位符创建部分应用函数。"
  },
  {
    "id": 249,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数柯里化的实现方式是？",
    "options": {
      "A": "手动创建返回函数的函数",
      "B": "使用curry关键字",
      "C": "自动柯里化",
      "D": "不支持柯里化"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言需要手动创建返回函数的函数来实现柯里化。"
  },
  {
    "id": 250,
    "type": "single",
    "category": "函数",
    "difficulty": "困难",
    "question": "仓颉语言中函数记忆化(Memoization)的实现方式是？",
    "options": {
      "A": "使用缓存装饰器",
      "B": "自动记忆",
      "C": "使用memoize函数",
      "D": "手动缓存"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言可以通过装饰器模式实现函数记忆化，缓存函数结果。"
  },
  {
    "id": 251,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中类的实例化方式是什么？",
    "options": {
      "A": "new ClassName()",
      "B": "ClassName()",
      "C": "ClassName.new()",
      "D": "create ClassName()"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言直接使用类名加括号实例化对象，不需要 new 关键字。"
  },
  {
    "id": 252,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中如何定义类的属性？",
    "options": {
      "A": "在类体内直接声明变量",
      "B": "使用property关键字",
      "C": "在构造函数中声明",
      "D": "使用attr关键字"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言在类体内直接声明变量即可定义属性。"
  },
  {
    "id": 253,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中接口的默认方法实现使用什么关键字？",
    "options": {
      "A": "default",
      "B": "impl",
      "C": "body",
      "D": "不需要关键字"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 default 关键字为接口方法提供默认实现。"
  },
  {
    "id": 254,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中密封类(sealed class)的作用是？",
    "options": {
      "A": "限制类的继承",
      "B": "定义有限子类集合",
      "C": "增强模式匹配安全性",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "密封类用于限制继承、定义有限子类集合并增强模式匹配的安全性。"
  },
  {
    "id": 255,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中内部类访问外部类成员的引用是？",
    "options": {
      "A": "this@OuterClass",
      "B": "outer.this",
      "C": "OuterClass.this",
      "D": "parent.this"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 this@OuterClass 语法访问外部类成员。"
  },
  {
    "id": 256,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中委托模式(Delegation)的主要优点是？",
    "options": {
      "A": "代码复用",
      "B": "组合优于继承",
      "C": "运行时灵活性",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "委托模式支持代码复用、组合优于继承的原则和运行时灵活性。"
  },
  {
    "id": 257,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中属性委托的lazy函数的作用是？",
    "options": {
      "A": "延迟初始化",
      "B": "缓存计算结果",
      "C": "线程安全初始化",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "lazy函数用于延迟初始化、缓存计算结果并提供线程安全的初始化。"
  },
  {
    "id": 258,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中创建线程的方式是？",
    "options": {
      "A": "Thread()",
      "B": "thread()函数",
      "C": "new Thread()",
      "D": "createThread()"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 thread() 函数快捷创建并启动线程。"
  },
  {
    "id": 259,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中同步代码块的关键字是？",
    "options": {
      "A": "synchronized",
      "B": "lock",
      "C": "sync",
      "D": "monitor"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 synchronized 关键字实现同步代码块。"
  },
  {
    "id": 260,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中读写锁的类是？",
    "options": {
      "A": "ReadWriteLock",
      "B": "ReentrantReadWriteLock",
      "C": "RWLock",
      "D": "ReadWriteMutex"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言使用 ReentrantReadWriteLock 类实现读写锁。"
  },
  {
    "id": 261,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中条件变量的类是？",
    "options": {
      "A": "Condition",
      "B": "WaitNotify",
      "C": "Signal",
      "D": "Event"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Condition 类实现条件变量。"
  },
  {
    "id": 262,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中线程池的创建函数是？",
    "options": {
      "A": "Executors.newFixedThreadPool()",
      "B": "ThreadPool()",
      "C": "new ThreadPoolExecutor()",
      "D": "createThreadPool()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Executors 工具类创建线程池。"
  },
  {
    "id": 263,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中CompletableFuture的作用是？",
    "options": {
      "A": "异步编程",
      "B": "组合多个异步操作",
      "C": "异常处理",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "CompletableFuture用于异步编程、组合多个异步操作和异常处理。"
  },
  {
    "id": 264,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中StampedLock的特点是？",
    "options": {
      "A": "乐观读锁",
      "B": "锁升级降级",
      "C": "更高的性能",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "StampedLock支持乐观读锁、锁升级降级，通常比读写锁性能更高。"
  },
  {
    "id": 265,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中对象创建在内存的哪个区域？",
    "options": {
      "A": "堆",
      "B": "栈",
      "C": "方法区",
      "D": "直接内存"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中的对象实例创建在堆内存中。"
  },
  {
    "id": 266,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中局部变量存储在内存的哪个区域？",
    "options": {
      "A": "栈",
      "B": "堆",
      "C": "方法区",
      "D": "寄存器"
    },
    "answer": [
      "A"
    ],
    "explanation": "局部变量存储在栈内存中，随着方法调用结束而自动释放。"
  },
  {
    "id": 267,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中内存溢出(OutOfMemoryError)的常见原因是？",
    "options": {
      "A": "内存泄漏",
      "B": "堆大小设置过小",
      "C": "创建过大对象",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "内存泄漏、堆大小设置过小和创建过大对象都可能导致内存溢出。"
  },
  {
    "id": 268,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中栈溢出(StackOverflowError)的常见原因是？",
    "options": {
      "A": "无限递归",
      "B": "方法调用层次过深",
      "C": "局部变量过多",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "无限递归、方法调用层次过深和局部变量过多都可能导致栈溢出。"
  },
  {
    "id": 269,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中逃逸分析的作用是？",
    "options": {
      "A": "优化对象分配",
      "B": "栈上分配对象",
      "C": "消除同步锁",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "逃逸分析可以优化对象分配、实现栈上分配和消除不必要的同步锁。"
  },
  {
    "id": 270,
    "type": "single",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中TLAB(Thread Local Allocation Buffer)的作用是？",
    "options": {
      "A": "提高对象分配效率",
      "B": "减少线程竞争",
      "C": "内存分配本地化",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "TLAB通过为每个线程分配独立的缓存区域来提高分配效率、减少竞争。"
  },
  {
    "id": 271,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中集合排序的函数是？",
    "options": {
      "A": "sort()",
      "B": "orderBy()",
      "C": "sorted()",
      "D": "arrange()"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言使用 sorted() 函数对集合进行排序。"
  },
  {
    "id": 272,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中查找集合元素的函数是？",
    "options": {
      "A": "find()",
      "B": "search()",
      "C": "locate()",
      "D": "indexOf()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 find() 函数查找集合中满足条件的元素。"
  },
  {
    "id": 273,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中分组集合元素的函数是？",
    "options": {
      "A": "groupBy()",
      "B": "partition()",
      "C": "categorize()",
      "D": "split()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 groupBy() 函数按条件对集合元素进行分组。"
  },
  {
    "id": 274,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中扁平化集合的函数是？",
    "options": {
      "A": "flatten()",
      "B": "flatMap()",
      "C": "merge()",
      "D": "combine()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 flatten() 函数将嵌套集合扁平化为一维集合。"
  },
  {
    "id": 275,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中压缩两个集合的函数是？",
    "options": {
      "A": "zip()",
      "B": "combine()",
      "C": "pair()",
      "D": "merge()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 zip() 函数将两个集合的元素配对组合。"
  },
  {
    "id": 276,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中序列(Sequence)的特点是？",
    "options": {
      "A": "惰性求值",
      "B": "中间操作不立即执行",
      "C": "节省内存",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "序列支持惰性求值，中间操作延迟执行，可以节省内存提高性能。"
  },
  {
    "id": 277,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中范围(Range)的创建方式是？",
    "options": {
      "A": "1..10",
      "B": "1 until 10",
      "C": "1..<10",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言支持多种范围创建方式，包括闭区间、半开区间等。"
  },
  {
    "id": 278,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中类型别名的关键字是？",
    "options": {
      "A": "type",
      "B": "alias",
      "C": "typedef",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 type 关键字定义类型别名。"
  },
  {
    "id": 279,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中交叉类型(Intersection Type)的表示是？",
    "options": {
      "A": "A & B",
      "B": "A | B",
      "C": "A and B",
      "D": "A intersect B"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 A & B 表示交叉类型，要求同时满足A和B的类型。"
  },
  {
    "id": 280,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中联合类型(Union Type)的表示是？",
    "options": {
      "A": "A | B",
      "B": "A & B",
      "C": "A or B",
      "D": "A union B"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 A | B 表示联合类型，要求满足A或B的类型。"
  },
  {
    "id": 281,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中条件类型的语法是？",
    "options": {
      "A": "T extends U ? X : Y",
      "B": "if T extends U then X else Y",
      "C": "T is U ? X : Y",
      "D": "when T extends U then X else Y"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 T extends U ? X : Y 语法定义条件类型。"
  },
  {
    "id": 282,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中映射类型(Mapped Type)的作用是？",
    "options": {
      "A": "基于旧类型创建新类型",
      "B": "批量修改属性类型",
      "C": "类型转换",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "映射类型用于基于现有类型创建新类型，可以批量修改属性类型。"
  },
  {
    "id": 283,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中模板字符串的类型安全实现是？",
    "options": {
      "A": "标签模板函数",
      "B": "字符串插值",
      "C": "类型守卫",
      "D": "模式匹配"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言通过标签模板函数实现类型安全的模板字符串。"
  },
  {
    "id": 284,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中装饰器(Decorator)的语法是？",
    "options": {
      "A": "@decorator",
      "B": "[decorator]",
      "C": "decorator()",
      "D": "decorate with"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 @decorator 语法应用装饰器。"
  },
  {
    "id": 285,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中元组解构的语法是？",
    "options": {
      "A": "val (a, b) = tuple",
      "B": "let [a, b] = tuple",
      "C": "const {a, b} = tuple",
      "D": "unpack (a, b) from tuple"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 val (a, b) = tuple 语法进行元组解构。"
  },
  {
    "id": 286,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中when表达式的作用是？",
    "options": {
      "A": "替代复杂的if-else链",
      "B": "模式匹配",
      "C": "多分支条件判断",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "when表达式用于替代复杂if-else链，支持模式匹配和多分支判断。"
  },
  {
    "id": 287,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中 Elvis 运算符的语法是？",
    "options": {
      "A": "?:",
      "B": "??",
      "C": "!!",
      "D": "?."
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ?: 作为Elvis运算符，在值为空时提供默认值。"
  },
  {
    "id": 288,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中安全调用运算符的语法是？",
    "options": {
      "A": "?.",
      "B": "!!",
      "C": "?:",
      "D": "?->"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ?. 进行安全调用，在对象为空时避免空指针异常。"
  },
  {
    "id": 289,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中非空断言运算符的语法是？",
    "options": {
      "A": "!!",
      "B": "?.",
      "C": "?:",
      "D": "!."
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 !! 进行非空断言，明确告诉编译器值不为空。"
  },
  {
    "id": 290,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中类型检查运算符的语法是？",
    "options": {
      "A": "is",
      "B": "instanceof",
      "C": "typeof",
      "D": "as"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 is 运算符进行类型检查。"
  },
  {
    "id": 291,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中智能类型转换的条件是？",
    "options": {
      "A": "使用is检查后",
      "B": "在when分支中",
      "C": "编译器能推断出类型",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "在is检查后、when分支中或编译器能推断类型时，仓颉语言会自动进行智能类型转换。"
  },
  {
    "id": 292,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中带标签的break语句的作用是？",
    "options": {
      "A": "跳出指定循环",
      "B": "跳出多层嵌套循环",
      "C": "提高代码可读性",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "带标签的break可以跳出指定循环、处理多层嵌套循环并提高代码可读性。"
  },
  {
    "id": 293,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中带标签的continue语句的作用是？",
    "options": {
      "A": "跳到指定循环的下一次迭代",
      "B": "跳过当前迭代继续下一次",
      "C": "处理复杂循环逻辑",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "带标签的continue用于跳到指定循环的下一次迭代，处理复杂循环逻辑。"
  },
  {
    "id": 294,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中return@label语法的用途是？",
    "options": {
      "A": "从带标签的lambda返回",
      "B": "从嵌套函数返回",
      "C": "指定返回位置",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "return@label用于从带标签的lambda、嵌套函数返回，指定具体的返回位置。"
  },
  {
    "id": 295,
    "type": "single",
    "category": "综合应用",
    "difficulty": "中等",
    "question": "仓颉语言中实现单例模式的最佳方式是？",
    "options": {
      "A": "对象声明(object)",
      "B": "双重检查锁",
      "C": "静态内部类",
      "D": "枚举"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中对象声明是实现单例模式最简洁和安全的方式。"
  },
  {
    "id": 296,
    "type": "single",
    "category": "综合应用",
    "difficulty": "中等",
    "question": "仓颉语言中构建器模式的最佳实现是？",
    "options": {
      "A": "使用命名参数和默认参数",
      "B": "传统的构建器类",
      "C": "DSL风格构建器",
      "D": "以上都是"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的命名参数和默认参数可以简化构建器模式的实现。"
  },
  {
    "id": 297,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中实现观察者模式的最佳方式是？",
    "options": {
      "A": "使用委托属性",
      "B": "使用标准库的Observable",
      "C": "自定义事件系统",
      "D": "使用响应式流"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的委托属性可以优雅地实现观察者模式。"
  },
  {
    "id": 298,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中策略模式的最佳实现是？",
    "options": {
      "A": "使用函数类型",
      "B": "接口和实现类",
      "C": "枚举策略",
      "D": "注解处理器"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的函数类型可以简洁地实现策略模式。"
  },
  {
    "id": 299,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中实现依赖注入的方式是？",
    "options": {
      "A": "使用构造函数注入",
      "B": "使用属性委托",
      "C": "使用第三方框架",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言支持多种依赖注入方式，包括构造函数注入、属性委托和使用框架。"
  },
  {
    "id": 300,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中性能优化的最佳实践不包括？",
    "options": {
      "A": "过度使用内联函数",
      "B": "合理使用集合操作",
      "C": "避免不必要的对象创建",
      "D": "使用序列处理大数据集"
    },
    "answer": [
      "A"
    ],
    "explanation": "过度使用内联函数可能导致代码膨胀，不是性能优化的最佳实践。"
  },
  {
    "id": 301,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的变量声明方式？",
    "options": {
      "A": "var name = \"张三\"",
      "B": "val age = 25",
      "C": "const PI = 3.14",
      "D": "let count = 100"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "仓颉语言使用var声明可变变量，val声明不可变变量。const和let不是仓颉语言的关键字。"
  },
  {
    "id": 302,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些控制流语句支持多分支选择？",
    "options": {
      "A": "if-else",
      "B": "when",
      "C": "switch",
      "D": "match"
    },
    "answer": [
      "B",
      "D"
    ],
    "explanation": "when表达式和match语句都支持多分支选择，if-else主要用于双分支，switch不是仓颉语言的关键字。"
  },
  {
    "id": 303,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中哪些运算符具有短路特性？",
    "options": {
      "A": "&&",
      "B": "||",
      "C": "&",
      "D": "|"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "逻辑与(&&)和逻辑或(||)具有短路特性，位运算符(&和|)没有短路特性。"
  },
  {
    "id": 304,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是数值类型？",
    "options": {
      "A": "Int",
      "B": "Float",
      "C": "Double",
      "D": "Decimal"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Int、Float、Double都是数值类型，Decimal不是仓颉语言的基本数值类型。"
  },
  {
    "id": 305,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些集合类型是可变的？",
    "options": {
      "A": "MutableList",
      "B": "MutableSet",
      "C": "MutableMap",
      "D": "Array"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "MutableList、MutableSet、MutableMap都是可变集合，Array在仓颉语言中大小固定但内容可变，但通常不被视为完全可变集合。"
  },
  {
    "id": 306,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持空安全？",
    "options": {
      "A": "可空类型(T?)",
      "B": "安全调用运算符(?.)",
      "C": "Elvis运算符(?:)",
      "D": "非空断言(!!)"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言通过可空类型、安全调用、Elvis运算符和非空断言全面支持空安全。"
  },
  {
    "id": 307,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是高阶函数的特点？",
    "options": {
      "A": "接受函数作为参数",
      "B": "返回函数作为结果",
      "C": "可以赋值给变量",
      "D": "支持函数组合"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "高阶函数可以接受函数参数、返回函数、赋值给变量，并支持函数组合。"
  },
  {
    "id": 308,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些函数可以用于集合处理？",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "reduce",
      "D": "forEach"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "map用于转换，filter用于过滤，reduce用于归约，forEach用于遍历，都是常用的集合处理函数。"
  },
  {
    "id": 309,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持函数式编程？",
    "options": {
      "A": "Lambda表达式",
      "B": "高阶函数",
      "C": "不可变集合",
      "D": "尾递归优化"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Lambda表达式、高阶函数、不可变集合和尾递归优化都是函数式编程的重要特性。"
  },
  {
    "id": 310,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是类的成员？",
    "options": {
      "A": "属性",
      "B": "方法",
      "C": "构造函数",
      "D": "初始化块"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "类的成员包括属性、方法、构造函数和初始化块。"
  },
  {
    "id": 311,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些可以包含抽象方法？",
    "options": {
      "A": "抽象类",
      "B": "接口",
      "C": "数据类",
      "D": "密封类"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "抽象类和接口可以包含抽象方法，数据类和密封类不能包含抽象方法。"
  },
  {
    "id": 312,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些设计模式有语言层面的直接支持？",
    "options": {
      "A": "单例模式（对象声明）",
      "B": "委托模式（by关键字）",
      "C": "观察者模式（委托属性）",
      "D": "工厂模式（伴生对象）"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言通过对象声明支持单例，by关键字支持委托，委托属性支持观察者，伴生对象支持工厂模式。"
  },
  {
    "id": 313,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是协程的构建器？",
    "options": {
      "A": "launch",
      "B": "async",
      "C": "runBlocking",
      "D": "coroutineScope"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "launch、async和runBlocking都是协程构建器，coroutineScope是作用域函数不是构建器。"
  },
  {
    "id": 314,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些可以用于线程同步？",
    "options": {
      "A": "Mutex",
      "B": "Semaphore",
      "C": "Atomic变量",
      "D": "Channel"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Mutex、Semaphore和Atomic变量都用于线程同步，Channel主要用于协程间通信。"
  },
  {
    "id": 315,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是结构化并发的好处？",
    "options": {
      "A": "自动取消传播",
      "B": "避免协程泄漏",
      "C": "简化错误处理",
      "D": "提高性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "结构化并发提供自动取消传播、避免协程泄漏和简化错误处理，但不直接提高性能。"
  },
  {
    "id": 316,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些会导致内存泄漏？",
    "options": {
      "A": "静态集合持有对象引用",
      "B": "未关闭的资源（文件、连接）",
      "C": "匿名内部类持有外部类引用",
      "D": "循环引用"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "静态集合、未关闭资源和匿名内部类持有引用会导致内存泄漏，但垃圾回收可以处理循环引用。"
  },
  {
    "id": 317,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是垃圾回收的算法？",
    "options": {
      "A": "标记-清除",
      "B": "复制算法",
      "C": "标记-整理",
      "D": "分代收集"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "标记-清除、复制算法、标记-整理都是基本垃圾回收算法，分代收集是综合策略。"
  },
  {
    "id": 318,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些可以优化内存使用？",
    "options": {
      "A": "使用对象池",
      "B": "避免创建不必要的对象",
      "C": "使用基本类型而非包装类",
      "D": "使用懒加载"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "对象池、避免不必要对象、使用基本类型和懒加载都可以优化内存使用。"
  },
  {
    "id": 319,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合操作的高阶函数？",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "fold",
      "D": "groupBy"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "map用于转换，filter用于过滤，fold用于累积，groupBy用于分组，都是集合高阶函数。"
  },
  {
    "id": 320,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些用于文件操作？",
    "options": {
      "A": "File.readText()",
      "B": "File.writeText()",
      "C": "Files.copy()",
      "D": "Paths.get()"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "File.readText()、File.writeText()和Files.copy()用于文件操作，Paths.get()用于路径操作。"
  },
  {
    "id": 321,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是序列(Sequence)的优势？",
    "options": {
      "A": "惰性求值",
      "B": "中间操作不创建中间集合",
      "C": "适合处理大数据集",
      "D": "操作顺序影响性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "序列支持惰性求值、避免中间集合、适合大数据集，操作顺序确实影响性能但不是优势。"
  },
  {
    "id": 322,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是泛型的好处？",
    "options": {
      "A": "类型安全",
      "B": "代码复用",
      "C": "消除强制类型转换",
      "D": "提高性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "泛型提供类型安全、代码复用和消除强制类型转换，但不直接提高性能。"
  },
  {
    "id": 323,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些注解可以用于元编程？",
    "options": {
      "A": "@Target",
      "B": "@Retention",
      "C": "@Repeatable",
      "D": "@MustBeDocumented"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些元注解都用于定义注解的行为，支持元编程。"
  },
  {
    "id": 324,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持DSL创建？",
    "options": {
      "A": "扩展函数",
      "B": "中缀调用",
      "C": "运算符重载",
      "D": "带接收者的Lambda"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "扩展函数、中缀调用、运算符重载和带接收者的Lambda都支持创建领域特定语言(DSL)。"
  },
  {
    "id": 325,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的循环语句？",
    "options": {
      "A": "for",
      "B": "while",
      "C": "do-while",
      "D": "loop"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持for、while和do-while循环，没有loop关键字。"
  },
  {
    "id": 326,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中哪些运算符可以重载？",
    "options": {
      "A": "+",
      "B": "==",
      "C": "[]",
      "D": "()"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言允许重载算术运算符、比较运算符、索引运算符和调用运算符等。"
  },
  {
    "id": 327,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是基本数据类型？",
    "options": {
      "A": "Int",
      "B": "String",
      "C": "Boolean",
      "D": "Char"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Int、Boolean、Char是基本数据类型，String是引用类型。"
  },
  {
    "id": 328,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些集合操作是终端操作？",
    "options": {
      "A": "toList()",
      "B": "forEach()",
      "C": "count()",
      "D": "filter()"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "toList()、forEach()、count()是终端操作，filter()是中间操作。"
  },
  {
    "id": 329,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是函数引用的方式？",
    "options": {
      "A": "::函数名",
      "B": "::类名.函数名",
      "C": "对象::函数名",
      "D": "类名::函数名"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持顶层函数引用、对象函数引用和类函数引用。"
  },
  {
    "id": 330,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些场景适合使用内联函数？",
    "options": {
      "A": "高阶函数参数",
      "B": "性能敏感代码",
      "C": "递归函数",
      "D": "泛型函数"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "内联函数适合高阶函数参数（避免函数对象创建）和性能敏感代码，但递归函数和泛型函数不适合内联。"
  },
  {
    "id": 331,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些类不能被继承？",
    "options": {
      "A": "final类",
      "B": "密封类",
      "C": "数据类",
      "D": "枚举类"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "final类、密封类和枚举类不能被继承，数据类默认是final但可以标记为open。"
  },
  {
    "id": 332,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是属性委托的用途？",
    "options": {
      "A": "懒加载",
      "B": "观察属性变化",
      "C": "映射属性到Map",
      "D": "提供默认值"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "属性委托可用于懒加载、观察变化和映射到Map，但不能直接提供默认值。"
  },
  {
    "id": 333,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是协程的调度器？",
    "options": {
      "A": "Dispatchers.IO",
      "B": "Dispatchers.Main",
      "C": "Dispatchers.Default",
      "D": "Dispatchers.Unconfined"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "IO调度器用于IO操作，Main调度器用于UI线程，Default用于CPU密集型任务，Unconfined不限制线程。"
  },
  {
    "id": 334,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是通道的特点？",
    "options": {
      "A": "线程安全",
      "B": "支持多个发送者和接收者",
      "C": "可以缓冲",
      "D": "支持选择表达式"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "通道是线程安全的，支持多发送者/接收者，可以设置缓冲区，并且可以与select表达式配合使用。"
  },
  {
    "id": 335,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是强引用的特点？",
    "options": {
      "A": "阻止垃圾回收",
      "B": "最常见的引用类型",
      "C": "可能导致内存泄漏",
      "D": "在内存不足时被回收"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "强引用阻止垃圾回收，是最常见的引用类型，不当使用可能导致内存泄漏，但不会在内存不足时被回收（那是软引用）。"
  },
  {
    "id": 336,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些技术可以减少内存占用？",
    "options": {
      "A": "使用基本类型数组",
      "B": "对象池",
      "C": "避免装箱拆箱",
      "D": "使用稀疏数组"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "基本类型数组减少对象头开销，对象池复用对象，避免装箱减少内存分配，稀疏数组节省空间。"
  },
  {
    "id": 337,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是字符串模板的功能？",
    "options": {
      "A": "变量插值",
      "B": "表达式计算",
      "C": "格式化数字",
      "D": "多行字符串"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "字符串模板支持变量插值、表达式计算和多行字符串，但格式化数字需要调用特定函数。"
  },
  {
    "id": 338,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是序列(Sequence)的终端操作？",
    "options": {
      "A": "toList()",
      "B": "first()",
      "C": "map()",
      "D": "filter()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "toList()和first()是序列的终端操作，map()和filter()是中间操作。"
  },
  {
    "id": 339,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是反射API的用途？",
    "options": {
      "A": "运行时获取类信息",
      "B": "动态创建对象",
      "C": "调用私有方法",
      "D": "代码生成"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "反射用于运行时获取类信息、动态创建对象和调用方法，但代码生成通常使用注解处理器。"
  },
  {
    "id": 340,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是内联类的限制？",
    "options": {
      "A": "只能有一个属性",
      "B": "不能继承其他类",
      "C": "不能实现接口",
      "D": "不能是泛型类"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "内联类只能有一个属性，不能继承其他类，但可以实现接口，也可以是泛型类。"
  },
  {
    "id": 341,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的跳转语句？",
    "options": {
      "A": "break",
      "B": "continue",
      "C": "return",
      "D": "goto"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "break用于跳出循环，continue用于跳过本次迭代，return用于返回，goto不是仓颉语言的关键字。"
  },
  {
    "id": 342,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中哪些表达式可以用于空安全处理？",
    "options": {
      "A": "?.安全调用",
      "B": "?:Elvis运算符",
      "C": "!!非空断言",
      "D": "as?安全转换"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "安全调用、Elvis运算符、非空断言和安全转换都是仓颉语言空安全处理的重要表达式。"
  },
  {
    "id": 343,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是函数类型的特点？",
    "options": {
      "A": "可以作为参数类型",
      "B": "可以作为返回类型",
      "C": "可以赋值给变量",
      "D": "可以继承"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "函数类型可以作为参数类型、返回类型，可以赋值给变量，但不能被继承。"
  },
  {
    "id": 344,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是泛型型变的方式？",
    "options": {
      "A": "协变(out)",
      "B": "逆变(in)",
      "C": "不变",
      "D": "型变投影"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "协变、逆变、不变和型变投影都是泛型型变的重要概念。"
  },
  {
    "id": 345,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是Lambda表达式的特性？",
    "options": {
      "A": "简洁的语法",
      "B": "可以访问外部变量",
      "C": "自动推断类型",
      "D": "支持函数式接口"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Lambda表达式语法简洁，可以访问外部变量，支持类型推断，并且可以转换为函数式接口。"
  },
  {
    "id": 346,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是尾递归优化的条件？",
    "options": {
      "A": "递归调用是最后操作",
      "B": "使用tailrec关键字",
      "C": "不能有额外的计算",
      "D": "必须是单参数函数"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "尾递归要求递归调用是最后操作，使用tailrec关键字标记，且不能有额外的计算，但不限制参数数量。"
  },
  {
    "id": 347,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是接口可以包含的成员？",
    "options": {
      "A": "抽象方法",
      "B": "默认方法",
      "C": "属性",
      "D": "常量"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "接口可以包含抽象方法、默认方法、属性和常量。"
  },
  {
    "id": 348,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是委托模式的优点？",
    "options": {
      "A": "代码复用",
      "B": "运行时灵活性",
      "C": "解耦",
      "D": "减少继承层次"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "委托模式支持代码复用、运行时灵活性、解耦和减少继承层次。"
  },
  {
    "id": 349,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是异步编程的方式？",
    "options": {
      "A": "回调函数",
      "B": "Future/Promise",
      "C": "协程",
      "D": "反应式流"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "回调函数、Future/Promise、协程和反应式流都是异步编程的常见方式。"
  },
  {
    "id": 350,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是避免竞态条件的方法？",
    "options": {
      "A": "使用同步锁",
      "B": "使用原子变量",
      "C": "使用不可变对象",
      "D": "使用线程局部变量"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "同步锁、原子变量、不可变对象和线程局部变量都可以帮助避免竞态条件。"
  },
  {
    "id": 351,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些情况可能触发垃圾回收？",
    "options": {
      "A": "内存不足时",
      "B": "调用System.gc()时",
      "C": "对象失去所有引用时",
      "D": "程序启动时"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "内存不足时JVM会自动触发GC，调用System.gc()可建议GC执行（但不保证立即执行）；对象失去引用只是成为回收候选，程序启动时一般不触发GC。"
  },
  {
    "id": 352,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些方法可用于集合排序？",
    "options": {
      "A": "sorted()",
      "B": "sortedBy()",
      "C": "sort()",
      "D": "sortedWith()"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "sorted()按自然顺序排序，sortedBy()按指定属性排序，sortedWith()按自定义比较器排序；sort()是Java集合的方法，仓颉中更常用前三者。"
  },
  {
    "id": 353,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是密封类(sealed class)的特点？",
    "options": {
      "A": "子类必须在同一文件中定义",
      "B": "可被继承但限制子类范围",
      "C": "默认是final类",
      "D": "常用于替代枚举类"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "密封类的子类必须与密封类在同一文件中，限制了继承范围；密封类本身不是final（允许被指定子类继承），与枚举类用途不同（枚举是单例，密封类可多实例）。"
  },
  {
    "id": 354,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的注释方式？",
    "options": {
      "A": "// 单行注释",
      "B": "/* 多行注释 */",
      "C": "/** 文档注释 */",
      "D": "''' 注释 '''"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉支持单行注释（//）、多行注释（/* */）和文档注释（/** */）；'''是多行字符串定界符，不是注释。"
  },
  {
    "id": 355,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是不可变集合的创建方法？",
    "options": {
      "A": "listOf()",
      "B": "mutableListOf()",
      "C": "mapOf()",
      "D": "setOf()"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "listOf()、mapOf()、setOf()创建不可变集合（元素不可增删）；mutableListOf()创建可变集合。"
  },
  {
    "id": 356,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些高阶函数用于聚合操作？",
    "options": {
      "A": "reduce()",
      "B": "fold()",
      "C": "sum()",
      "D": "average()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "reduce()和fold()是通用聚合函数（从集合元素计算单一结果）；sum()和average()是特定聚合（仅数值型），不算高阶函数。"
  },
  {
    "id": 357,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中数据类(data class)的自动生成方法包括？",
    "options": {
      "A": "equals()",
      "B": "hashCode()",
      "C": "toString()",
      "D": "copy()"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据类会自动生成equals()、hashCode()、toString()（包含所有属性）和copy()方法，方便对象的比较、复制和打印。"
  },
  {
    "id": 358,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中协程的取消方式有哪些？",
    "options": {
      "A": "调用cancel()方法",
      "B": "使用withTimeout()",
      "C": "抛出CancellationException",
      "D": "关闭协程上下文"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "协程可通过cancel()主动取消、withTimeout()超时取消，或内部抛出CancellationException取消；协程上下文无法直接关闭。"
  },
  {
    "id": 359,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中处理日期时间的类包括？",
    "options": {
      "A": "LocalDate",
      "B": "LocalTime",
      "C": "ZonedDateTime",
      "D": "Date"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "LocalDate（日期）、LocalTime（时间）、ZonedDateTime（带时区的日期时间）是仓颉标准库推荐的日期时间类；Date是旧版API，不推荐使用。"
  },
  {
    "id": 360,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是注解的保留策略？",
    "options": {
      "A": "SOURCE",
      "B": "CLASS",
      "C": "RUNTIME",
      "D": "COMPILE"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "注解的保留策略包括SOURCE（仅源码中保留）、CLASS（编译为class文件保留）、RUNTIME（运行时可通过反射获取），无COMPILE策略。"
  },
  {
    "id": 361,
    "type": "single",
    "category": "基础知识",
    "difficulty": "简单",
    "question": "仓颉语言的设计目标不包括以下哪项？",
    "options": {
      "A": "兼顾开发效率与运行性能",
      "B": "完全兼容C语言语法",
      "C": "支持面向对象与函数式编程",
      "D": "提供完善的内存安全机制"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言设计目标包括多编程范式支持、内存安全和效率平衡，但并不以兼容C语言语法为目标。"
  },
  {
    "id": 362,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中三元条件运算符的正确语法是？",
    "options": {
      "A": "condition ? expr1 : expr2",
      "B": "if condition then expr1 else expr2",
      "C": "condition ?? expr1 : expr2",
      "D": "expr1 if condition else expr2"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 `condition ? expr1 : expr2` 作为三元条件运算符，与多数C系语言语法一致。"
  },
  {
    "id": 363,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "关于仓颉语言闭包的描述，正确的是？",
    "options": {
      "A": "闭包不能访问外部作用域的变量",
      "B": "闭包可以修改外部作用域的var变量",
      "C": "闭包只能捕获不可变变量（val）",
      "D": "闭包必须显式声明捕获的变量"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言的闭包可以访问并修改外部作用域中用var定义的可变变量，无需显式声明捕获。"
  },
  {
    "id": 364,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中类实现接口的关键字是？",
    "options": {
      "A": "implements",
      "B": "extends",
      "C": "with",
      "D": "use"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 `implements` 关键字表示类对接口的实现，如 `class MyClass implements MyInterface`。"
  },
  {
    "id": 365,
    "type": "single",
    "category": "数据结构",
    "difficulty": "简单",
    "question": "仓颉语言中栈（Stack）的入栈操作方法是？",
    "options": {
      "A": "push()",
      "B": "add()",
      "C": "insert()",
      "D": "append()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的Stack数据结构使用 `push()` 方法进行入栈操作，`pop()` 方法进行出栈操作。"
  },
  {
    "id": 366,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中泛型约束的语法是？",
    "options": {
      "A": "<T where T: Constraint>",
      "B": "<T extends Constraint>",
      "C": "<T : Constraint>",
      "D": "<Constraint T>"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 `where` 关键字定义泛型约束，语法为 `<T where T: Constraint>`，表示类型参数T必须满足Constraint约束。"
  },
  {
    "id": 367,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于线程等待的方法是？",
    "options": {
      "A": "wait()",
      "B": "sleep()",
      "C": "pause()",
      "D": "hold()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 `wait()` 方法用于使当前线程进入等待状态，需配合锁机制使用，`sleep()` 仅用于暂停指定时间。"
  },
  {
    "id": 368,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "以下哪种方法不能有效优化仓颉程序的执行速度？",
    "options": {
      "A": "使用内联函数减少函数调用开销",
      "B": "将频繁访问的变量声明为局部变量",
      "C": "增加对象创建次数以简化代码",
      "D": "使用基本类型替代包装类型"
    },
    "answer": [
      "C"
    ],
    "explanation": "频繁创建对象会增加垃圾回收压力，降低程序性能，其他选项均为有效的性能优化手段。"
  },
  {
    "id": 369,
    "type": "multiple",
    "category": "基础知识",
    "difficulty": "中等",
    "question": "仓颉语言的特点包括哪些？",
    "options": {
      "A": "静态类型检查",
      "B": "自动垃圾回收",
      "C": "解释型执行",
      "D": "支持跨平台编译"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "仓颉语言是静态类型、编译型语言，具备自动垃圾回收和跨平台编译能力，不属于解释型语言。"
  },
  {
    "id": 370,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中复合赋值运算符 `+=` 的作用是？",
    "options": {
      "A": "将右边值赋值给左边变量",
      "B": "左边变量值加上右边值后再赋值给左边",
      "C": "左边变量与右边值按位或后赋值",
      "D": "判断左右值是否相等"
    },
    "answer": [
      "B"
    ],
    "explanation": "`a += b` 等价于 `a = a + b`，表示将左边变量与右边值相加后的结果赋回左边变量。"
  },
  {
    "id": 371,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中函数参数的默认值必须放在参数列表的哪个位置？",
    "options": {
      "A": "任意位置",
      "B": "参数列表开头",
      "C": "参数列表末尾",
      "D": "仅允许第一个参数有默认值"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言要求带默认值的参数必须放在参数列表末尾，以便正确解析位置参数。"
  },
  {
    "id": 372,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中类的继承关键字是？",
    "options": {
      "A": "extends",
      "B": "inherits",
      "C": "derive",
      "D": "subclass"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 `extends` 关键字表示类的继承关系，如 `class Child extends Parent`。"
  },
  {
    "id": 373,
    "type": "single",
    "category": "数据结构",
    "difficulty": "中等",
    "question": "仓颉语言中获取列表（List）长度的属性是？",
    "options": {
      "A": "length",
      "B": "size",
      "C": "count",
      "D": "len"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言的List数据结构通过 `size` 属性获取元素数量，如 `myList.size`。"
  },
  {
    "id": 374,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中注解（Annotation）的作用不包括？",
    "options": {
      "A": "在编译期提供元数据",
      "B": "直接修改代码逻辑",
      "C": "生成额外代码",
      "D": "进行编译期检查"
    },
    "answer": [
      "B"
    ],
    "explanation": "注解用于提供元数据，可用于代码生成或编译检查，但不能直接修改代码逻辑。"
  },
  {
    "id": 375,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "以下哪些是仓颉语言中解决并发安全问题的机制？",
    "options": {
      "A": "Mutex（互斥锁）",
      "B": "Atomic（原子操作）",
      "C": "Channel（通道）",
      "D": "GlobalLock（全局锁）"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言提供Mutex、Atomic和Channel等机制解决并发安全问题，没有GlobalLock这一机制。"
  },
  {
    "id": 376,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "仓颉语言中使用 `inline` 关键字修饰函数的主要目的是？",
    "options": {
      "A": "减少函数调用的栈开销",
      "B": "允许函数返回多个值",
      "C": "使函数可以被继承重写",
      "D": "增加函数的执行优先级"
    },
    "answer": [
      "A"
    ],
    "explanation": "`inline` 关键字会使编译器在调用处直接展开函数体，从而减少函数调用的栈操作开销。"
  },
  {
    "id": 377,
    "type": "single",
    "category": "基础知识",
    "difficulty": "简单",
    "question": "仓颉语言的官方编译器名称是？",
    "options": {
      "A": "cjcc",
      "B": "javac",
      "C": "gcc",
      "D": "rustc"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的官方编译器通常命名为 `cjcc`（CangJie Compiler Collection）。"
  },
  {
    "id": 378,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中 `break` 语句的作用是？",
    "options": {
      "A": "退出当前循环",
      "B": "跳过本次循环，进入下一次",
      "C": "结束当前函数执行",
      "D": "抛出异常"
    },
    "answer": [
      "A"
    ],
    "explanation": "`break` 语句用于立即退出当前所在的循环结构，`continue` 用于跳过本次循环剩余部分。"
  },
  {
    "id": 379,
    "type": "single",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中高阶函数 `map` 的作用是？",
    "options": {
      "A": "过滤集合中的元素",
      "B": "将函数应用于集合每个元素并返回新集合",
      "C": "对集合元素进行排序",
      "D": "计算集合元素的累加结果"
    },
    "answer": [
      "B"
    ],
    "explanation": "`map` 函数接收一个转换函数和一个集合，将转换函数应用于每个元素，返回包含转换结果的新集合。"
  },
  {
    "id": 380,
    "type": "single",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中 `override` 关键字的作用是？",
    "options": {
      "A": "定义一个新的类方法",
      "B": "重写父类中的方法",
      "C": "禁止方法被继承",
      "D": "将方法声明为抽象方法"
    },
    "answer": [
      "B"
    ],
    "explanation": "`override` 关键字用于显式声明当前方法是重写父类中的方法，增强代码可读性并让编译器进行检查。"
  },
  {
    "id": 381,
    "type": "multiple",
    "category": "数据结构",
    "difficulty": "中等",
    "question": "以下哪些是仓颉语言中常用的线性数据结构？",
    "options": {
      "A": "List（链表）",
      "B": "Stack（栈）",
      "C": "HashMap（哈希表）",
      "D": "Queue（队列）"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "线性数据结构具有线性存储特性，包括List、Stack、Queue等；HashMap是非线性的键值对结构。"
  },
  {
    "id": 382,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中反射机制可以实现的功能是？",
    "options": {
      "A": "在运行时获取类的方法信息",
      "B": "提高代码的执行速度",
      "C": "避免编译错误",
      "D": "自动修复程序bug"
    },
    "answer": [
      "A"
    ],
    "explanation": "反射机制允许程序在运行时获取类的结构信息（如方法、属性等），但会降低性能，不能避免错误或修复bug。"
  },
  {
    "id": 383,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中 `spawn` 关键字创建的协程属于哪种调度方式？",
    "options": {
      "A": "内核级调度",
      "B": "用户级调度",
      "C": "实时调度",
      "D": "优先级调度"
    },
    "answer": [
      "B"
    ],
    "explanation": "`spawn` 创建的轻量级线程（协程）由用户态调度器管理，属于用户级调度，而非内核直接调度。"
  },
  {
    "id": 384,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "以下哪种数据结构适合频繁进行插入和删除操作？",
    "options": {
      "A": "Array（数组）",
      "B": "List（链表）",
      "C": "Set（集合）",
      "D": "Map（映射）"
    },
    "answer": [
      "B"
    ],
    "explanation": "链表在插入和删除操作时只需修改指针，时间复杂度为O(1)，而数组需要移动元素，效率较低。"
  },
  {
    "id": 385,
    "type": "single",
    "category": "基础知识",
    "difficulty": "简单",
    "question": "仓颉语言的开发公司是？",
    "options": {
      "A": "华为",
      "B": "阿里巴巴",
      "C": "腾讯",
      "D": "字节跳动"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言是华为公司研发的编程语言，主要用于鸿蒙生态开发。"
  },
  {
    "id": 386,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中支持的循环结构有哪些？",
    "options": {
      "A": "for循环",
      "B": "while循环",
      "C": "do-while循环",
      "D": "repeat循环"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持for、while和do-while三种循环结构，没有repeat循环关键字。"
  },
  {
    "id": 387,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中匿名函数可以作为参数传递给其他函数的原因是？",
    "options": {
      "A": "匿名函数是一等公民",
      "B": "匿名函数没有名称",
      "C": "匿名函数只能在局部使用",
      "D": "匿名函数执行速度更快"
    },
    "answer": [
      "A"
    ],
    "explanation": "在函数式编程中，函数作为一等公民可以被当作参数传递、作为返回值或赋值给变量，匿名函数也具备这一特性。"
  },
  {
    "id": 388,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中接口与抽象类的主要区别是？",
    "options": {
      "A": "接口不能有方法声明",
      "B": "抽象类不能被继承",
      "C": "接口不能包含实现代码，抽象类可以",
      "D": "抽象类需要使用interface关键字定义"
    },
    "answer": [
      "C"
    ],
    "explanation": "接口中的方法默认都是抽象的（无实现），而抽象类可以包含已实现的方法；两者都可以被继承/实现。"
  },
  {
    "id": 389,
    "type": "single",
    "category": "数据结构",
    "difficulty": "困难",
    "question": "仓颉语言中 `HashMap` 的查找操作平均时间复杂度是？",
    "options": {
      "A": "O(1)",
      "B": "O(n)",
      "C": "O(log n)",
      "D": "O(n log n)"
    },
    "answer": [
      "A"
    ],
    "explanation": "HashMap通过哈希函数直接定位元素位置，平均查找时间复杂度为O(1)，最坏情况为O(n)。"
  },
  {
    "id": 390,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中 `yield` 关键字的作用是？",
    "options": {
      "A": "从函数返回值",
      "B": "暂停函数执行并返回中间结果",
      "C": "抛出异常",
      "D": "终止程序运行"
    },
    "answer": [
      "B"
    ],
    "explanation": "`yield` 用于生成器函数中，暂停函数执行并返回一个中间结果，下次调用时从暂停处继续执行。"
  },
  {
    "id": 391,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "以下哪些可能导致并发程序出现死锁？",
    "options": {
      "A": "多个线程循环等待彼此持有的资源",
      "B": "线程持有锁的时间过长",
      "C": "使用try-catch语句处理异常",
      "D": "未正确释放锁资源"
    },
    "answer": [
      "A",
      "D"
    ],
    "explanation": "死锁的典型场景是多个线程循环等待资源且不释放已持有的锁；未释放锁会增加死锁风险。"
  },
  {
    "id": 392,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "仓颉语言中JIT（即时编译）的作用是？",
    "options": {
      "A": "将源代码直接转换为机器码",
      "B": "在运行时将热点代码编译为机器码",
      "C": "优化代码的语法结构",
      "D": "检查代码中的语法错误"
    },
    "answer": [
      "B"
    ],
    "explanation": "JIT编译在程序运行时识别并将频繁执行的热点代码编译为机器码，平衡解释执行的灵活性和编译执行的效率。"
  },
  {
    "id": 393,
    "type": "single",
    "category": "基础知识",
    "difficulty": "简单",
    "question": "仓颉语言主要应用于哪个生态系统？",
    "options": {
      "A": "鸿蒙（HarmonyOS）",
      "B": "安卓（Android）",
      "C": "iOS",
      "D": "Windows"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言是华为为鸿蒙生态系统开发的编程语言，用于构建鸿蒙应用和服务。"
  },
  {
    "id": 394,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中逻辑与运算符是？",
    "options": {
      "A": "&&",
      "B": "||",
      "C": "&",
      "D": "|"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 `&&` 作为逻辑与运算符，`||` 作为逻辑或运算符，`&` 和 `|` 是位运算符。"
  },
  {
    "id": 395,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中 `filter` 函数的返回结果是？",
    "options": {
      "A": "满足条件的元素组成的新集合",
      "B": "集合中第一个满足条件的元素",
      "C": "元素是否满足条件的布尔值",
      "D": "满足条件的元素数量"
    },
    "answer": [
      "A"
    ],
    "explanation": "`filter` 函数接收一个谓词（返回布尔值的函数），返回包含所有满足谓词条件的元素的新集合。"
  },
  {
    "id": 396,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中 `static` 关键字修饰的方法属于？",
    "options": {
      "A": "实例方法",
      "B": "类方法",
      "C": "抽象方法",
      "D": "私有方法"
    },
    "answer": [
      "B"
    ],
    "explanation": "`static` 修饰的方法属于类本身，而非类的实例，可直接通过类名调用，无需创建对象。"
  },
  {
    "id": 397,
    "type": "multiple",
    "category": "数据结构",
    "difficulty": "中等",
    "question": "以下哪些数据结构允许重复元素？",
    "options": {
      "A": "List（链表）",
      "B": "Set（集合）",
      "C": "Queue（队列）",
      "D": "Array（数组）"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "List、Queue和Array都允许存储重复元素，而Set的特性是不允许元素重复。"
  },
  {
    "id": 398,
    "type": "single",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中类型擦除发生在哪个阶段？",
    "options": {
      "A": "编译期",
      "B": "运行期",
      "C": "链接期",
      "D": "加载期"
    },
    "answer": [
      "A"
    ],
    "explanation": "类型擦除是泛型实现的一种方式，在编译期移除泛型类型信息，使生成的字节码不包含具体类型参数。"
  },
  {
    "id": 399,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中通道（Channel）的默认行为是？",
    "options": {
      "A": "无缓冲，发送和接收操作同步",
      "B": "有缓冲，默认容量为10",
      "C": "仅允许单向数据传输",
      "D": "自动关闭闲置通道"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的通道默认是无缓冲的，发送操作会阻塞直到有接收方接收数据，接收操作会阻塞直到有数据发送。"
  },
  {
    "id": 400,
    "type": "multiple",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "以下哪些是仓颉程序的常见性能瓶颈？",
    "options": {
      "A": "频繁的垃圾回收",
      "B": "过多的嵌套循环",
      "C": "使用不可变数据结构",
      "D": "大量的字符串拼接"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "频繁GC、嵌套循环和字符串拼接都会导致性能问题；不可变数据结构通常不会直接成为瓶颈，且有利于并发安全。"
  },
  {
    "id": 401,
    "type": "single",
    "category": "控制流",
    "difficulty": "简单",
    "question": "仓颉语言中if语句的条件表达式是否需要用括号包裹？",
    "options": {
      "A": "必须用括号()包裹",
      "B": "不能用括号包裹",
      "C": "可选项，用不用都可以",
      "D": "必须用大括号{}包裹"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中if语句的条件表达式必须用括号()包裹，如if (x > 0) { ... }。"
  },
  {
    "id": 402,
    "type": "single",
    "category": "控制流",
    "difficulty": "简单",
    "question": "仓颉语言中for循环遍历数组的正确语法是？",
    "options": {
      "A": "for item in array",
      "B": "for (i = 0; i < array.length; i++)",
      "C": "foreach (item in array)",
      "D": "loop item from array"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用for item in array的语法遍历数组元素，属于增强型for循环。"
  },
  {
    "id": 403,
    "type": "single",
    "category": "控制流",
    "difficulty": "简单",
    "question": "仓颉语言中while循环的终止条件满足时，会执行什么操作？",
    "options": {
      "A": "继续执行循环体",
      "B": "退出循环",
      "C": "跳过本次循环",
      "D": "抛出异常"
    },
    "answer": [
      "B"
    ],
    "explanation": "while循环当条件为false（终止条件满足）时，会退出循环，不再执行循环体。"
  },
  {
    "id": 404,
    "type": "single",
    "category": "控制流",
    "difficulty": "中等",
    "question": "仓颉语言中switch语句的默认分支关键字是？",
    "options": {
      "A": "default",
      "B": "else",
      "C": "otherwise",
      "D": "case default"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中switch语句使用default关键字定义默认分支，当所有case都不匹配时执行。"
  },
  {
    "id": 405,
    "type": "single",
    "category": "控制流",
    "difficulty": "中等",
    "question": "以下关于仓颉语言break语句的说法正确的是？",
    "options": {
      "A": "只能用于循环",
      "B": "只能用于switch",
      "C": "可用于循环和switch",
      "D": "仓颉语言不支持break"
    },
    "answer": [
      "C"
    ],
    "explanation": "break语句在仓颉语言中可用于跳出当前循环或switch语句，终止其执行。"
  },
  {
    "id": 406,
    "type": "single",
    "category": "异常处理",
    "difficulty": "中等",
    "question": "仓颉语言中捕获异常的关键字是？",
    "options": {
      "A": "catch",
      "B": "except",
      "C": "try",
      "D": "handle"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用try-catch结构处理异常，catch用于捕获并处理异常。"
  },
  {
    "id": 407,
    "type": "single",
    "category": "异常处理",
    "difficulty": "中等",
    "question": "仓颉语言中抛出异常的关键字是？",
    "options": {
      "A": "throw",
      "B": "raise",
      "C": "throwException",
      "D": "error"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用throw关键字手动抛出异常，如throw new Exception(\"错误信息\")。"
  },
  {
    "id": 408,
    "type": "single",
    "category": "异常处理",
    "difficulty": "困难",
    "question": "仓颉语言中finally块的作用是？",
    "options": {
      "A": "处理特定类型的异常",
      "B": "无论是否发生异常都会执行",
      "C": "定义可能发生异常的代码",
      "D": "替代catch块"
    },
    "answer": [
      "B"
    ],
    "explanation": "finally块中的代码无论try块是否发生异常、是否被捕获，都会执行，常用于资源释放。"
  },
  {
    "id": 409,
    "type": "single",
    "category": "泛型",
    "difficulty": "中等",
    "question": "仓颉语言中定义泛型类的正确语法是？",
    "options": {
      "A": "class MyClass<T>",
      "B": "generic class MyClass<T>",
      "C": "class MyClass<T: Any>",
      "D": "class MyClass[type T]"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用class ClassName<T>的语法定义泛型类，T为类型参数。"
  },
  {
    "id": 410,
    "type": "single",
    "category": "泛型",
    "difficulty": "中等",
    "question": "仓颉语言中泛型约束的关键字是？",
    "options": {
      "A": "where",
      "B": "extends",
      "C": ":",
      "D": "constraint"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言使用冒号:指定泛型约束，如class MyClass<T: Number>表示T必须是Number的子类。"
  },
  {
    "id": 411,
    "type": "single",
    "category": "集合操作",
    "difficulty": "简单",
    "question": "仓颉语言中向List添加元素的方法是？",
    "options": {
      "A": "add()",
      "B": "push()",
      "C": "append()",
      "D": "insert()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的List集合使用add()方法添加元素，如list.add(5)。"
  },
  {
    "id": 412,
    "type": "single",
    "category": "集合操作",
    "difficulty": "简单",
    "question": "仓颉语言中获取List元素个数的属性是？",
    "options": {
      "A": "size",
      "B": "length",
      "C": "count",
      "D": "length()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中List的size属性用于获取元素个数，如list.size。"
  },
  {
    "id": 413,
    "type": "single",
    "category": "集合操作",
    "difficulty": "中等",
    "question": "仓颉语言中Map通过什么方法根据键获取值？",
    "options": {
      "A": "getKey()",
      "B": "getValue()",
      "C": "get()",
      "D": "find()"
    },
    "answer": [
      "C"
    ],
    "explanation": "Map集合使用get(key)方法根据键获取对应的值，如map.get(\"name\")。"
  },
  {
    "id": 414,
    "type": "single",
    "category": "集合操作",
    "difficulty": "中等",
    "question": "仓颉语言中过滤集合元素的高阶函数是？",
    "options": {
      "A": "filter",
      "B": "map",
      "C": "reduce",
      "D": "forEach"
    },
    "answer": [
      "A"
    ],
    "explanation": "filter函数用于根据条件过滤集合元素，返回满足条件的元素组成的新集合。"
  },
  {
    "id": 415,
    "type": "single",
    "category": "模块化",
    "difficulty": "简单",
    "question": "仓颉语言中声明包的关键字是？",
    "options": {
      "A": "package",
      "B": "module",
      "C": "namespace",
      "D": "package name"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用package关键字声明包，如package com.example。"
  },
  {
    "id": 416,
    "type": "single",
    "category": "模块化",
    "difficulty": "中等",
    "question": "仓颉语言中导出模块成员的关键字是？",
    "options": {
      "A": "export",
      "B": "public",
      "C": "exported",
      "D": "expose"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用export关键字可以将模块中的成员导出，供其他模块导入使用。"
  },
  {
    "id": 417,
    "type": "single",
    "category": "类型转换",
    "difficulty": "简单",
    "question": "仓颉语言中安全类型转换的运算符是？",
    "options": {
      "A": "as?",
      "B": "as",
      "C": "cast",
      "D": "to"
    },
    "answer": [
      "A"
    ],
    "explanation": "as?运算符用于安全类型转换，转换失败时返回null，而非抛出异常。"
  },
  {
    "id": 418,
    "type": "single",
    "category": "类型转换",
    "difficulty": "中等",
    "question": "将String类型转换为Int类型的方法是？",
    "options": {
      "A": "String.toInt()",
      "B": "Int.parse(String)",
      "C": "convert(String, Int)",
      "D": "cast(String as Int)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中String类型提供toInt()方法，用于将字符串转换为整数。"
  },
  {
    "id": 419,
    "type": "single",
    "category": "运算符",
    "difficulty": "简单",
    "question": "仓颉语言中用于字符串拼接的运算符是？",
    "options": {
      "A": "+",
      "B": "&",
      "C": "++",
      "D": "concat"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用+运算符进行字符串拼接，如\"Hello\" + \" World\"。"
  },
  {
    "id": 420,
    "type": "single",
    "category": "运算符",
    "difficulty": "中等",
    "question": "仓颉语言中 Elvis 运算符的作用是？",
    "options": {
      "A": "空值判断并返回默认值",
      "B": "逻辑或运算",
      "C": "三元运算符的简化",
      "D": "位运算"
    },
    "answer": [
      "A"
    ],
    "explanation": "Elvis运算符（?:）用于判断左侧表达式是否为null，是则返回右侧默认值，如x ?: 0。"
  },
  {
    "id": 421,
    "type": "single",
    "category": "接口",
    "difficulty": "中等",
    "question": "仓颉语言中类实现接口的关键字是？",
    "options": {
      "A": "implements",
      "B": "extends",
      "C": "implements interface",
      "D": "use"
    },
    "answer": [
      "A"
    ],
    "explanation": "类使用implements关键字实现接口，如class MyClass implements MyInterface。"
  },
  {
    "id": 422,
    "type": "single",
    "category": "接口",
    "difficulty": "困难",
    "question": "仓颉语言中接口的默认方法使用什么关键字定义？",
    "options": {
      "A": "default",
      "B": "base",
      "C": "impl",
      "D": "default func"
    },
    "answer": [
      "A"
    ],
    "explanation": "接口中可以使用default关键字定义默认方法，实现类可直接继承无需重写。"
  },
  {
    "id": 423,
    "type": "single",
    "category": "枚举",
    "difficulty": "简单",
    "question": "仓颉语言中定义枚举的关键字是？",
    "options": {
      "A": "enum",
      "B": "enumerate",
      "C": "enum class",
      "D": "enumeration"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用enum关键字定义枚举类型，如enum Color { RED, GREEN, BLUE }。"
  },
  {
    "id": 424,
    "type": "single",
    "category": "枚举",
    "difficulty": "中等",
    "question": "以下关于仓颉语言枚举的说法正确的是？",
    "options": {
      "A": "枚举值可以有参数",
      "B": "枚举不能实现接口",
      "C": "枚举不能有方法",
      "D": "枚举值必须是整数"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的枚举支持为枚举值定义参数和方法，增强枚举的灵活性。"
  },
  {
    "id": 425,
    "type": "single",
    "category": "注解",
    "difficulty": "中等",
    "question": "仓颉语言中注解的声明关键字是？",
    "options": {
      "A": "@interface",
      "B": "annotation",
      "C": "@annotation",
      "D": "anno"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用@interface关键字声明注解类型，如@interface MyAnnotation。"
  },
  {
    "id": 426,
    "type": "single",
    "category": "注解",
    "difficulty": "中等",
    "question": "在仓颉语言中，如何使用注解？",
    "options": {
      "A": "#MyAnnotation",
      "B": "@MyAnnotation",
      "C": "use MyAnnotation",
      "D": "[MyAnnotation]"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用@符号加注解名的方式应用注解，如@Deprecated class MyClass。"
  },
  {
    "id": 427,
    "type": "single",
    "category": "文件操作",
    "difficulty": "困难",
    "question": "仓颉语言中读取文件内容的类是？",
    "options": {
      "A": "FileReader",
      "B": "ReadFile",
      "C": "FileInputStream",
      "D": "FileReaderUtil"
    },
    "answer": [
      "A"
    ],
    "explanation": "FileReader类提供了读取文件内容的方法，是仓颉语言中常用的文件读取工具。"
  },
  {
    "id": 428,
    "type": "single",
    "category": "文件操作",
    "difficulty": "困难",
    "question": "仓颉语言中写入文件时，追加内容的模式是？",
    "options": {
      "A": "append",
      "B": "write",
      "C": "add",
      "D": "update"
    },
    "answer": [
      "A"
    ],
    "explanation": "以append模式打开文件写入时，新内容会追加到文件末尾，而非覆盖原有内容。"
  },
  {
    "id": 429,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中线程同步的关键字是？",
    "options": {
      "A": "synchronized",
      "B": "lock",
      "C": "sync",
      "D": "atomic"
    },
    "answer": [
      "A"
    ],
    "explanation": "synchronized关键字用于实现线程同步，确保多线程环境下临界区代码的原子性。"
  },
  {
    "id": 430,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中CountDownLatch的作用是？",
    "options": {
      "A": "让线程等待其他线程完成",
      "B": "控制线程执行顺序",
      "C": "限制并发线程数量",
      "D": "实现线程间通信"
    },
    "answer": [
      "A"
    ],
    "explanation": "CountDownLatch通过计数器让一个或多个线程等待其他线程完成指定操作后再继续执行。"
  },
  {
    "id": 431,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中多行字符串的表示方式是？",
    "options": {
      "A": "使用三个双引号\"\"\"",
      "B": "使用反斜杠\\换行",
      "C": "使用单引号''",
      "D": "使用换行符直接换行"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用三个双引号\"\"\"包裹多行字符串，保留字符串中的换行和格式。"
  },
  {
    "id": 432,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中是否区分大小写？",
    "options": {
      "A": "完全不区分",
      "B": "关键字区分，变量名不区分",
      "C": "完全区分",
      "D": "仅类名区分"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言是大小写敏感的语言，变量名、关键字、类名等均区分大小写。"
  },
  {
    "id": 433,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示字节类型的是？",
    "options": {
      "A": "Byte",
      "B": "byte",
      "C": "Bytes",
      "D": "ByteType"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中Byte类型表示8位有符号整数，遵循首字母大写的类型命名规范。"
  },
  {
    "id": 434,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中布尔类型的默认值是？",
    "options": {
      "A": "true",
      "B": "false",
      "C": "null",
      "D": "未定义"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言中布尔类型变量未初始化时，默认值为false。"
  },
  {
    "id": 435,
    "type": "single",
    "category": "函数",
    "difficulty": "简单",
    "question": "仓颉语言中函数参数的默认值必须放在参数列表的哪个位置？",
    "options": {
      "A": "开头",
      "B": "中间",
      "C": "结尾",
      "D": "任意位置"
    },
    "answer": [
      "C"
    ],
    "explanation": "带有默认值的参数必须放在参数列表的结尾，以便正确解析函数调用时的参数传递。"
  },
  {
    "id": 436,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中递归函数的必要条件是？",
    "options": {
      "A": "有返回值",
      "B": "有终止条件",
      "C": "调用自身",
      "D": "参数不变"
    },
    "answer": [
      "B"
    ],
    "explanation": "递归函数必须包含终止条件，否则会导致无限递归和栈溢出错误。"
  },
  {
    "id": 437,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中类的构造函数定义在哪个位置？",
    "options": {
      "A": "类名后",
      "B": "类体中用constructor关键字",
      "C": "类体外",
      "D": "不需要定义，自动生成"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言中使用constructor关键字在类体中定义构造函数，如class MyClass { constructor() {} }。"
  },
  {
    "id": 438,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中重写父类方法的关键字是？",
    "options": {
      "A": "override",
      "B": "overwrite",
      "C": "replace",
      "D": "redefine"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用override关键字标记重写父类的方法，确保方法签名与父类一致。"
  },
  {
    "id": 439,
    "type": "single",
    "category": "控制流",
    "difficulty": "中等",
    "question": "仓颉语言中do-while循环的特点是？",
    "options": {
      "A": "先判断条件再执行循环体",
      "B": "至少执行一次循环体",
      "C": "不能嵌套使用",
      "D": "没有终止条件"
    },
    "answer": [
      "B"
    ],
    "explanation": "do-while循环先执行一次循环体，再判断条件，因此循环体至少执行一次。"
  },
  {
    "id": 440,
    "type": "single",
    "category": "控制流",
    "difficulty": "中等",
    "question": "仓颉语言中continue语句的作用是？",
    "options": {
      "A": "退出整个循环",
      "B": "跳过本次循环剩余部分，进入下一次循环",
      "C": "终止程序执行",
      "D": "返回函数调用处"
    },
    "answer": [
      "B"
    ],
    "explanation": "continue语句用于跳过当前循环中剩余的代码，直接进入下一次循环的判断或执行。"
  },
  {
    "id": 441,
    "type": "single",
    "category": "异常处理",
    "difficulty": "中等",
    "question": "仓颉语言中自定义异常的正确方式是？",
    "options": {
      "A": "继承Exception类",
      "B": "使用exception关键字",
      "C": "实现Exception接口",
      "D": "定义普通类即可"
    },
    "answer": [
      "A"
    ],
    "explanation": "自定义异常需继承Exception类或其子类，以便使用try-catch结构捕获处理。"
  },
  {
    "id": 442,
    "type": "single",
    "category": "异常处理",
    "difficulty": "困难",
    "question": "仓颉语言中try-with-resources的作用是？",
    "options": {
      "A": "自动关闭资源",
      "B": "简化try-catch语法",
      "C": "提高异常处理效率",
      "D": "捕获多种异常"
    },
    "answer": [
      "A"
    ],
    "explanation": "try-with-resources语句会在代码块执行完毕后自动关闭实现了AutoCloseable接口的资源，无需手动关闭。"
  },
  {
    "id": 443,
    "type": "single",
    "category": "泛型",
    "difficulty": "困难",
    "question": "仓颉语言中泛型通配符的表示方式是？",
    "options": {
      "A": "?",
      "B": "*",
      "C": "Any",
      "D": "T"
    },
    "answer": [
      "A"
    ],
    "explanation": "泛型通配符用?表示，可用于表示未知类型，如List<?>表示元素类型未知的列表。"
  },
  {
    "id": 444,
    "type": "single",
    "category": "泛型",
    "difficulty": "困难",
    "question": "仓颉语言中泛型方法的定义位置是？",
    "options": {
      "A": "只能在泛型类中",
      "B": "只能在普通类中",
      "C": "泛型类和普通类中均可",
      "D": "不能定义泛型方法"
    },
    "answer": [
      "C"
    ],
    "explanation": "泛型方法可在泛型类和普通类中定义，通过在方法名前声明类型参数实现，如function <T> foo(t: T)。"
  },
  {
    "id": 445,
    "type": "single",
    "category": "集合操作",
    "difficulty": "中等",
    "question": "仓颉语言中对集合元素进行映射转换的函数是？",
    "options": {
      "A": "map",
      "B": "flatMap",
      "C": "transform",
      "D": "convert"
    },
    "answer": [
      "A"
    ],
    "explanation": "map函数通过传入的转换函数对集合中的每个元素进行处理，返回转换后的新集合。"
  },
  {
    "id": 446,
    "type": "single",
    "category": "集合操作",
    "difficulty": "中等",
    "question": "仓颉语言中判断集合是否为空的方法是？",
    "options": {
      "A": "isEmpty()",
      "B": "isNull()",
      "C": "isBlank()",
      "D": "hasElements()"
    },
    "answer": [
      "A"
    ],
    "explanation": "集合的isEmpty()方法用于判断集合中是否包含元素，无元素则返回true。"
  },
  {
    "id": 447,
    "type": "single",
    "category": "模块化",
    "difficulty": "中等",
    "question": "仓颉语言中导入模块中特定成员的语法是？",
    "options": {
      "A": "import com.example.MyClass",
      "B": "import com.example.*",
      "C": "import MyClass from com.example",
      "D": "use com.example.MyClass"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用import 包名.类名的语法导入模块中的特定成员，避免导入不必要的内容。"
  },
  {
    "id": 448,
    "type": "single",
    "category": "模块化",
    "difficulty": "困难",
    "question": "仓颉语言中模块的依赖声明在哪个文件中？",
    "options": {
      "A": "module.cj",
      "B": "deps.json",
      "C": "package.json",
      "D": "project.cj"
    },
    "answer": [
      "A"
    ],
    "explanation": "module.cj文件用于声明模块的依赖关系、导出内容等模块信息。"
  },
  {
    "id": 449,
    "type": "single",
    "category": "类型转换",
    "difficulty": "中等",
    "question": "仓颉语言中强制类型转换可能抛出的异常是？",
    "options": {
      "A": "TypeCastException",
      "B": "CastException",
      "C": "ConversionException",
      "D": "TypeException"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用as进行强制类型转换时，若转换失败会抛出TypeCastException异常。"
  },
  {
    "id": 450,
    "type": "single",
    "category": "类型转换",
    "difficulty": "中等",
    "question": "判断一个对象是否为某个类型的运算符是？",
    "options": {
      "A": "is",
      "B": "instanceof",
      "C": "typeof",
      "D": "typeis"
    },
    "answer": [
      "A"
    ],
    "explanation": "is运算符用于判断对象是否为指定类型的实例，如obj is String返回布尔值。"
  },
  {
    "id": 451,
    "type": "single",
    "category": "运算符",
    "difficulty": "中等",
    "question": "仓颉语言中复合赋值运算符+=的作用是？",
    "options": {
      "A": "x = x + y",
      "B": "x = y + x",
      "C": "x = x + 1",
      "D": "x = y"
    },
    "answer": [
      "A"
    ],
    "explanation": "x += y等价于x = x + y，是加法与赋值的复合运算符，简化代码书写。"
  },
  {
    "id": 452,
    "type": "single",
    "category": "运算符",
    "difficulty": "中等",
    "question": "仓颉语言中逻辑与运算符是？",
    "options": {
      "A": "&&",
      "B": "&",
      "C": "and",
      "D": "AND"
    },
    "answer": [
      "A"
    ],
    "explanation": "&&是逻辑与运算符，具有短路特性，当左侧为false时，右侧不再执行。"
  },
  {
    "id": 453,
    "type": "single",
    "category": "接口",
    "difficulty": "中等",
    "question": "仓颉语言中一个类可以实现几个接口？",
    "options": {
      "A": "1个",
      "B": "2个",
      "C": "多个",
      "D": "0个"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言支持一个类实现多个接口，用逗号分隔接口名，如class A implements B, C。"
  },
  {
    "id": 454,
    "type": "single",
    "category": "接口",
    "difficulty": "困难",
    "question": "仓颉语言中接口之间的继承使用什么关键字？",
    "options": {
      "A": "extends",
      "B": "implements",
      "C": "inherits",
      "D": "extends interface"
    },
    "answer": [
      "A"
    ],
    "explanation": "接口之间的继承使用extends关键字，一个接口可以继承多个其他接口。"
  },
  {
    "id": 455,
    "type": "single",
    "category": "枚举",
    "difficulty": "中等",
    "question": "获取枚举值名称的方法是？",
    "options": {
      "A": "name()",
      "B": "toString()",
      "C": "getValue()",
      "D": "getName()"
    },
    "answer": [
      "A"
    ],
    "explanation": "枚举类型的name()方法返回枚举常量的名称，如Color.RED.name()返回\"RED\"。"
  },
  {
    "id": 456,
    "type": "single",
    "category": "枚举",
    "difficulty": "中等",
    "question": "根据名称获取枚举值的方法是？",
    "options": {
      "A": "valueOf()",
      "B": "fromName()",
      "C": "getEnum()",
      "D": "parse()"
    },
    "answer": [
      "A"
    ],
    "explanation": "枚举类的valueOf(String name)方法根据名称获取对应的枚举值，如Color.valueOf(\"RED\")。"
  },
  {
    "id": 457,
    "type": "single",
    "category": "注解",
    "difficulty": "困难",
    "question": "仓颉语言中注解的保留策略通过哪个元注解指定？",
    "options": {
      "A": "@Retention",
      "B": "@Keep",
      "C": "@RetentionPolicy",
      "D": "@Preserve"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Retention元注解用于指定注解的保留策略，如源代码、类文件或运行时。"
  },
  {
    "id": 458,
    "type": "single",
    "category": "注解",
    "difficulty": "困难",
    "question": "可用于字段的注解需要添加哪个元注解？",
    "options": {
      "A": "@Target(FIELD)",
      "B": "@FieldAnnotation",
      "C": "@Target(FIELD_TYPE)",
      "D": "@ApplyToField"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Target元注解指定注解的适用目标，FIELD表示该注解可用于字段。"
  },
  {
    "id": 459,
    "type": "single",
    "category": "文件操作",
    "difficulty": "中等",
    "question": "仓颉语言中获取文件路径的方法是？",
    "options": {
      "A": "getPath()",
      "B": "getAbsolutePath()",
      "C": "getPathName()",
      "D": "filePath()"
    },
    "answer": [
      "A"
    ],
    "explanation": "File类的getPath()方法返回文件的路径字符串，可能是相对路径或绝对路径。"
  },
  {
    "id": 460,
    "type": "single",
    "category": "文件操作",
    "difficulty": "中等",
    "question": "判断文件是否存在的方法是？",
    "options": {
      "A": "exists()",
      "B": "isExist()",
      "C": "existsFile()",
      "D": "fileExists()"
    },
    "answer": [
      "A"
    ],
    "explanation": "File类的exists()方法用于判断文件或目录是否存在，返回布尔值。"
  },
  {
    "id": 461,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中线程的休眠方法是？",
    "options": {
      "A": "sleep()",
      "B": "wait()",
      "C": "pause()",
      "D": "delay()"
    },
    "answer": [
      "A"
    ],
    "explanation": "Thread类的sleep(long millis)方法使当前线程休眠指定的毫秒数。"
  },
  {
    "id": 462,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中线程池的核心接口是？",
    "options": {
      "A": "ExecutorService",
      "B": "ThreadPool",
      "C": "Executor",
      "D": "ThreadPoolExecutor"
    },
    "answer": [
      "A"
    ],
    "explanation": "ExecutorService是线程池的核心接口，提供了管理线程池和提交任务的方法。"
  },
  {
    "id": 463,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中数组的初始化方式正确的是？",
    "options": {
      "A": "val arr = [1, 2, 3]",
      "B": "val arr = Array<Int>(1, 2, 3)",
      "C": "val arr = new Array(1, 2, 3)",
      "D": "val arr = arrayOf(1, 2, 3)"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言使用arrayOf()函数初始化数组，如arrayOf(1, 2, 3)创建包含三个整数的数组。"
  },
  {
    "id": 464,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中块注释的符号是？",
    "options": {
      "A": "/* */",
      "B": "//",
      "C": "'''",
      "D": "<!-- -->"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用/*开头、*/结尾的符号进行块注释，可注释多行内容。"
  },
  {
    "id": 465,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示长整数的类型是？",
    "options": {
      "A": "Long",
      "B": "long",
      "C": "Int64",
      "D": "LongInt"
    },
    "answer": [
      "A"
    ],
    "explanation": "Long类型表示64位有符号整数，用于存储较大的整数值，如123L表示长整数。"
  },
  {
    "id": 466,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中字符串的长度属性是？",
    "options": {
      "A": "length",
      "B": "size",
      "C": "length()",
      "D": "count"
    },
    "answer": [
      "A"
    ],
    "explanation": "String类型的length属性用于获取字符串的长度，即字符个数。"
  },
  {
    "id": 467,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中函数的返回值类型声明在哪个位置？",
    "options": {
      "A": "函数名前",
      "B": "参数列表后，用:分隔",
      "C": "函数体前",
      "D": "不需要声明"
    },
    "answer": [
      "B"
    ],
    "explanation": "函数返回值类型声明在参数列表后，用冒号分隔，如function add(a: Int, b: Int): Int { ... }。"
  },
  {
    "id": 468,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中函数参数的类型是否必须声明？",
    "options": {
      "A": "必须声明",
      "B": "可选，可自动推断",
      "C": "仅简单类型需要声明",
      "D": "仅复杂类型需要声明"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言是强类型语言，函数参数必须显式声明类型，无法自动推断。"
  },
  {
    "id": 469,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中类的静态成员属于？",
    "options": {
      "A": "类的实例",
      "B": "类本身",
      "C": "伴生对象",
      "D": "父类"
    },
    "answer": [
      "B"
    ],
    "explanation": "静态成员属于类本身，而非类的实例，可通过类名直接访问，无需创建对象。"
  },
  {
    "id": 470,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中final关键字修饰的类的特点是？",
    "options": {
      "A": "不能被继承",
      "B": "不能创建实例",
      "C": "只能有一个实例",
      "D": "不能有方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "final关键字修饰的类为最终类，不能被其他类继承，确保类的实现不被修改。"
  },
  {
    "id": 471,
    "type": "single",
    "category": "控制流",
    "difficulty": "中等",
    "question": "仓颉语言中switch语句支持的类型不包括？",
    "options": {
      "A": "Int",
      "B": "String",
      "C": "Boolean",
      "D": "枚举"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言的switch语句支持整数、字符串、枚举等类型，但不支持布尔类型。"
  },
  {
    "id": 472,
    "type": "single",
    "category": "控制流",
    "difficulty": "中等",
    "question": "仓颉语言中for循环的范围遍历语法是？",
    "options": {
      "A": "for i in 1..10",
      "B": "for (i = 1; i <= 10; i++)",
      "C": "for i from 1 to 10",
      "D": "loop i = 1 to 10"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用for i in 1..10语法遍历1到10的范围，包含起始值和结束值。"
  },
  {
    "id": 473,
    "type": "single",
    "category": "异常处理",
    "difficulty": "中等",
    "question": "仓颉语言中可以同时捕获多个异常的方式是？",
    "options": {
      "A": "用逗号分隔异常类型",
      "B": "多个catch块",
      "C": "使用|分隔异常类型",
      "D": "只能捕获一个异常"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过定义多个catch块可以捕获不同类型的异常，每个catch块处理一种异常。"
  },
  {
    "id": 474,
    "type": "single",
    "category": "异常处理",
    "difficulty": "中等",
    "question": "仓颉语言中Error类与Exception类的关系是？",
    "options": {
      "A": "Error继承自Exception",
      "B": "Exception继承自Error",
      "C": "两者无继承关系",
      "D": "两者是同一类的不同名称"
    },
    "answer": [
      "A"
    ],
    "explanation": "Error类是Exception的子类，通常表示严重错误，如OutOfMemoryError。"
  },
  {
    "id": 475,
    "type": "single",
    "category": "泛型",
    "difficulty": "困难",
    "question": "仓颉语言中泛型的类型擦除发生在哪个阶段？",
    "options": {
      "A": "编译期",
      "B": "运行期",
      "C": "链接期",
      "D": "加载期"
    },
    "answer": [
      "A"
    ],
    "explanation": "泛型的类型擦除在编译期进行，将泛型类型替换为其边界类型，运行时不保留泛型信息。"
  },
  {
    "id": 476,
    "type": "single",
    "category": "泛型",
    "difficulty": "困难",
    "question": "仓颉语言中上限通配符的表示方式是？",
    "options": {
      "A": "? extends T",
      "B": "? super T",
      "C": "T extends ?",
      "D": "? superclass T"
    },
    "answer": [
      "A"
    ],
    "explanation": "上限通配符? extends T表示未知类型是T的子类，限制了元素的类型范围。"
  },
  {
    "id": 477,
    "type": "single",
    "category": "集合操作",
    "difficulty": "中等",
    "question": "仓颉语言中对集合进行排序的方法是？",
    "options": {
      "A": "sort()",
      "B": "order()",
      "C": "sorted()",
      "D": "arrange()"
    },
    "answer": [
      "A"
    ],
    "explanation": "集合的sort()方法用于对元素进行排序，会修改原集合；sorted()返回排序后的新集合。"
  },
  {
    "id": 478,
    "type": "single",
    "category": "集合操作",
    "difficulty": "中等",
    "question": "仓颉语言中获取集合第一个元素的方法是？",
    "options": {
      "A": "first()",
      "B": "getFirst()",
      "C": "head()",
      "D": "top()"
    },
    "answer": [
      "A"
    ],
    "explanation": "first()方法返回集合中的第一个元素，若集合为空可能抛出异常。"
  },
  {
    "id": 479,
    "type": "single",
    "category": "模块化",
    "difficulty": "中等",
    "question": "仓颉语言中导入整个模块的语法是？",
    "options": {
      "A": "import com.example.*",
      "B": "import com.example",
      "C": "import all from com.example",
      "D": "use com.example.*"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用import 包名.*的语法导入指定包中的所有成员，简化导入语句。"
  },
  {
    "id": 480,
    "type": "single",
    "category": "模块化",
    "difficulty": "中等",
    "question": "仓颉语言中模块的名称通常与什么保持一致？",
    "options": {
      "A": "目录结构",
      "B": "文件名",
      "C": "主类名",
      "D": "项目名"
    },
    "answer": [
      "A"
    ],
    "explanation": "模块名称通常与文件系统的目录结构保持一致，便于编译器查找和导入模块。"
  },
  {
    "id": 481,
    "type": "single",
    "category": "类型转换",
    "difficulty": "中等",
    "question": "将Int类型转换为String类型的方法是？",
    "options": {
      "A": "Int.toString()",
      "B": "String.valueOf(Int)",
      "C": "Int.toText()",
      "D": "convert(Int, String)"
    },
    "answer": [
      "A"
    ],
    "explanation": "Int类型的toString()方法用于将整数转换为对应的字符串表示。"
  },
  {
    "id": 482,
    "type": "single",
    "category": "类型转换",
    "difficulty": "中等",
    "question": "仓颉语言中隐式类型转换的规则是？",
    "options": {
      "A": "小范围类型可转换为大范围类型",
      "B": "大范围类型可转换为小范围类型",
      "C": "任意类型间均可隐式转换",
      "D": "不支持隐式类型转换"
    },
    "answer": [
      "A"
    ],
    "explanation": "隐式类型转换允许小范围类型（如Int）自动转换为大范围类型（如Long），避免数据丢失。"
  },
  {
    "id": 483,
    "type": "single",
    "category": "运算符",
    "difficulty": "中等",
    "question": "仓颉语言中三元运算符的语法是？",
    "options": {
      "A": "condition ? expr1 : expr2",
      "B": "if (condition) expr1 else expr2",
      "C": "condition ? expr1 | expr2",
      "D": "condition then expr1 else expr2"
    },
    "answer": [
      "A"
    ],
    "explanation": "三元运算符condition ? expr1 : expr2表示：若condition为true，执行expr1，否则执行expr2。"
  },
  {
    "id": 484,
    "type": "single",
    "category": "运算符",
    "difficulty": "中等",
    "question": "仓颉语言中取余运算符是？",
    "options": {
      "A": "%",
      "B": "mod",
      "C": "MOD",
      "D": "//"
    },
    "answer": [
      "A"
    ],
    "explanation": "%是取余运算符，用于计算两个数相除的余数，如7 % 3的结果是1。"
  },
  {
    "id": 485,
    "type": "single",
    "category": "接口",
    "difficulty": "中等",
    "question": "仓颉语言中接口的方法默认访问修饰符是？",
    "options": {
      "A": "public",
      "B": "private",
      "C": "protected",
      "D": "internal"
    },
    "answer": [
      "A"
    ],
    "explanation": "接口中的方法默认是public的，实现类必须以public修饰符实现这些方法。"
  },
  {
    "id": 486,
    "type": "single",
    "category": "接口",
    "difficulty": "困难",
    "question": "仓颉语言中解决接口方法冲突的方式是？",
    "options": {
      "A": "显式指定实现哪个接口的方法",
      "B": "优先实现父接口的方法",
      "C": "自动覆盖冲突方法",
      "D": "编译报错，不允许冲突"
    },
    "answer": [
      "A"
    ],
    "explanation": "当类实现的多个接口有同名方法时，需显式指定实现哪个接口的方法以解决冲突。"
  },
  {
    "id": 487,
    "type": "single",
    "category": "枚举",
    "difficulty": "中等",
    "question": "仓颉语言中枚举的ordinal()方法返回什么？",
    "options": {
      "A": "枚举值的索引",
      "B": "枚举值的名称",
      "C": "枚举值的数量",
      "D": "枚举值的哈希码"
    },
    "answer": [
      "A"
    ],
    "explanation": "ordinal()方法返回枚举常量在枚举声明中的位置索引，从0开始。"
  },
  {
    "id": 488,
    "type": "single",
    "category": "枚举",
    "difficulty": "中等",
    "question": "仓颉语言中获取所有枚举值的方法是？",
    "options": {
      "A": "values()",
      "B": "allValues()",
      "C": "getValues()",
      "D": "enumValues()"
    },
    "answer": [
      "A"
    ],
    "explanation": "枚举类的values()方法返回包含所有枚举常量的数组，按声明顺序排列。"
  },
  {
    "id": 489,
    "type": "single",
    "category": "注解",
    "difficulty": "困难",
    "question": "仓颉语言中运行时可见的注解保留策略是？",
    "options": {
      "A": "RetentionPolicy.RUNTIME",
      "B": "RetentionPolicy.CLASS",
      "C": "RetentionPolicy.SOURCE",
      "D": "RetentionPolicy.RUN"
    },
    "answer": [
      "A"
    ],
    "explanation": "RetentionPolicy.RUNTIME表示注解在运行时仍然可见，可通过反射获取注解信息。"
  },
  {
    "id": 490,
    "type": "single",
    "category": "注解",
    "difficulty": "困难",
    "question": "仓颉语言中注解的元素类型不能是？",
    "options": {
      "A": "基本数据类型",
      "B": "注解类型",
      "C": "void",
      "D": "数组"
    },
    "answer": [
      "C"
    ],
    "explanation": "注解的元素类型可以是基本类型、字符串、枚举、注解或这些类型的数组，不能是void。"
  },
  {
    "id": 491,
    "type": "single",
    "category": "文件操作",
    "difficulty": "中等",
    "question": "仓颉语言中创建目录的方法是？",
    "options": {
      "A": "mkdir()",
      "B": "createDir()",
      "C": "makeDirectory()",
      "D": "newDirectory()"
    },
    "answer": [
      "A"
    ],
    "explanation": "File类的mkdir()方法用于创建单级目录，mkdirs()用于创建多级目录。"
  },
  {
    "id": 492,
    "type": "single",
    "category": "文件操作",
    "difficulty": "中等",
    "question": "删除文件的方法是？",
    "options": {
      "A": "delete()",
      "B": "remove()",
      "C": "deleteFile()",
      "D": "erase()"
    },
    "answer": [
      "A"
    ],
    "explanation": "File类的delete()方法用于删除文件或空目录，返回布尔值表示是否删除成功。"
  },
  {
    "id": 493,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中线程的状态不包括？",
    "options": {
      "A": "运行中",
      "B": "阻塞",
      "C": "终止",
      "D": "休眠"
    },
    "answer": [
      "D"
    ],
    "explanation": "线程状态包括新建、就绪、运行中、阻塞、终止，休眠属于阻塞状态的一种情况。"
  },
  {
    "id": 494,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中Lock接口的lock()和unlock()方法的作用是？",
    "options": {
      "A": "获取和释放锁",
      "B": "暂停和恢复线程",
      "C": "等待和唤醒线程",
      "D": "创建和销毁线程"
    },
    "answer": [
      "A"
    ],
    "explanation": "Lock接口的lock()方法用于获取锁，unlock()方法用于释放锁，实现线程同步。"
  },
  {
    "id": 495,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中多行注释是否可以嵌套？",
    "options": {
      "A": "可以",
      "B": "不可以",
      "C": "仅允许两层嵌套",
      "D": "取决于注释内容"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言的多行注释/* */不支持嵌套，内层的*/会被视为外层注释的结束。"
  },
  {
    "id": 496,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中变量名不能包含的字符是？",
    "options": {
      "A": "字母",
      "B": "数字",
      "C": "空格",
      "D": "下划线"
    },
    "answer": [
      "C"
    ],
    "explanation": "变量名可包含字母、数字和下划线，但不能包含空格或其他特殊字符，且不能以数字开头。"
  },
  {
    "id": 497,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示单精度浮点数的类型是？",
    "options": {
      "A": "Float",
      "B": "Double",
      "C": "Single",
      "D": "Float32"
    },
    "answer": [
      "A"
    ],
    "explanation": "Float类型表示32位单精度浮点数，Double表示64位双精度浮点数。"
  },
  {
    "id": 498,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中字符常量的表示方式是？",
    "options": {
      "A": "'a'",
      "B": "\"a\"",
      "C": "`a`",
      "D": "a"
    },
    "answer": [
      "A"
    ],
    "explanation": "字符常量用单引号' '表示，如'a'；字符串用双引号\" \"表示。"
  },
  {
    "id": 499,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中函数的参数是否支持命名参数传递？",
    "options": {
      "A": "支持",
      "B": "不支持",
      "C": "仅默认参数支持",
      "D": "仅可变参数支持"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言支持命名参数传递，调用函数时可指定参数名，如foo(x=5, y=10)，提高代码可读性。"
  },
  {
    "id": 500,
    "type": "single",
    "category": "函数",
    "difficulty": "中等",
    "question": "仓颉语言中函数的返回语句是？",
    "options": {
      "A": "return",
      "B": "back",
      "C": "yield",
      "D": "exit"
    },
    "answer": [
      "A"
    ],
    "explanation": "return语句用于从函数中返回值，并终止函数的执行，如return x + y。"
  },
  {
    "id": 501,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中用于类型检查的关键字是？",
    "options": {
      "A": "is",
      "B": "instanceof",
      "C": "typeof",
      "D": "check"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 is 关键字进行类型检查。"
  },
  {
    "id": 502,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些运算符具有空安全特性？",
    "options": {
      "A": "?.",
      "B": "?:",
      "C": "!!",
      "D": "as?"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "安全调用(?.)、Elvis(?:)、非空断言(!!)和安全转换(as?)都支持空安全。"
  },
  {
    "id": 503,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示64位整数的类型是？",
    "options": {
      "A": "Long",
      "B": "Int64",
      "C": "BigInteger",
      "D": "Integer"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Long 表示64位整数。"
  },
  {
    "id": 504,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些集合类型支持快速随机访问？",
    "options": {
      "A": "ArrayList",
      "B": "LinkedList",
      "C": "Array",
      "D": "HashSet"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "ArrayList和Array支持基于索引的快速随机访问。"
  },
  {
    "id": 505,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中内联函数的主要作用是？",
    "options": {
      "A": "减少函数调用开销",
      "B": "支持递归调用",
      "C": "提高代码可读性",
      "D": "简化函数定义"
    },
    "answer": [
      "A"
    ],
    "explanation": "内联函数通过代码展开减少函数调用开销。"
  },
  {
    "id": 506,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持函数组合？",
    "options": {
      "A": "函数类型",
      "B": "高阶函数",
      "C": "扩展函数",
      "D": "运算符重载"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "函数类型、高阶函数和运算符重载都支持函数组合。"
  },
  {
    "id": 507,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中定义接口的关键字是？",
    "options": {
      "A": "interface",
      "B": "protocol",
      "C": "trait",
      "D": "abstract"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 interface 关键字定义接口。"
  },
  {
    "id": 508,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些类不能被实例化？",
    "options": {
      "A": "抽象类",
      "B": "密封类",
      "C": "数据类",
      "D": "枚举类"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "抽象类和密封类不能被直接实例化。"
  },
  {
    "id": 509,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于协程取消检查的函数是？",
    "options": {
      "A": "ensureActive()",
      "B": "checkCancellation()",
      "C": "validateState()",
      "D": "verifyActive()"
    },
    "answer": [
      "A"
    ],
    "explanation": "ensureActive()函数用于检查协程是否被取消。"
  },
  {
    "id": 510,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是结构化并发的组成部分？",
    "options": {
      "A": "协程作用域",
      "B": "协程上下文",
      "C": "父子关系",
      "D": "取消传播"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "作用域、上下文、父子关系和取消传播都是结构化并发的核心概念。"
  },
  {
    "id": 511,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中对象终结器(finalizer)的作用是？",
    "options": {
      "A": "对象回收前的清理",
      "B": "对象创建的初始化",
      "C": "对象序列化",
      "D": "对象克隆"
    },
    "answer": [
      "A"
    ],
    "explanation": "终结器在对象被垃圾回收前执行清理操作。"
  },
  {
    "id": 512,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些情况可能导致内存泄漏？",
    "options": {
      "A": "静态集合持有对象引用",
      "B": "匿名类持有外部类引用",
      "C": "资源未正确关闭",
      "D": "循环引用"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "静态集合、匿名类持有引用和未关闭资源会导致内存泄漏，循环引用可由GC处理。"
  },
  {
    "id": 513,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于字符串分割的函数是？",
    "options": {
      "A": "split()",
      "B": "divide()",
      "C": "separate()",
      "D": "partition()"
    },
    "answer": [
      "A"
    ],
    "explanation": "split()函数用于按指定分隔符分割字符串。"
  },
  {
    "id": 514,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的终端操作？",
    "options": {
      "A": "toList()",
      "B": "forEach()",
      "C": "count()",
      "D": "map()"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "toList()、forEach()、count()是终端操作，map()是中间操作。"
  },
  {
    "id": 515,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中反射API的主要入口类是？",
    "options": {
      "A": "Class",
      "B": "Type",
      "C": "Reflect",
      "D": "Mirror"
    },
    "answer": [
      "A"
    ],
    "explanation": "Class类是反射API的主要入口点。"
  },
  {
    "id": 516,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些注解可以用于元编程？",
    "options": {
      "A": "@Target",
      "B": "@Retention",
      "C": "@Repeatable",
      "D": "@MustBeDocumented"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些元注解都用于控制注解的行为，支持元编程。"
  },
  {
    "id": 517,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中带标签的break语句可以跳出多少层循环？",
    "options": {
      "A": "只能跳出当前循环",
      "B": "只能跳出两层循环",
      "C": "可以跳出任意层循环",
      "D": "不能跳出循环"
    },
    "answer": [
      "C"
    ],
    "explanation": "带标签的break可以跳出任意层嵌套循环。"
  },
  {
    "id": 518,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的控制流语句？",
    "options": {
      "A": "if-else",
      "B": "when",
      "C": "switch",
      "D": "for"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "if-else、when和for是有效的控制流语句，switch不是仓颉语言关键字。"
  },
  {
    "id": 519,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中布尔类型的取值是？",
    "options": {
      "A": "true/false",
      "B": "True/False",
      "C": "1/0",
      "D": "yes/no"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用小写的true和false作为布尔值。"
  },
  {
    "id": 520,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些类型是数值类型？",
    "options": {
      "A": "Int",
      "B": "Double",
      "C": "Number",
      "D": "Decimal"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Int和Double是数值类型，Number和Decimal不是基本数值类型。"
  },
  {
    "id": 521,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中函数引用操作符是？",
    "options": {
      "A": "::",
      "B": "->",
      "C": "=>",
      "D": "#"
    },
    "answer": [
      "A"
    ],
    "explanation": "::操作符用于函数引用。"
  },
  {
    "id": 522,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些场景适合使用尾递归？",
    "options": {
      "A": "深度递归算法",
      "B": "树形结构遍历",
      "C": "迭代计算",
      "D": "IO密集型操作"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "深度递归、树遍历和迭代计算适合尾递归，IO操作不适合。"
  },
  {
    "id": 523,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中构造函数名是？",
    "options": {
      "A": "init",
      "B": "constructor",
      "C": "new",
      "D": "create"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用init作为构造函数名。"
  },
  {
    "id": 524,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是访问修饰符？",
    "options": {
      "A": "public",
      "B": "private",
      "C": "internal",
      "D": "protected"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "public、private和internal是访问修饰符，protected不是。"
  },
  {
    "id": 525,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于线程同步的锁接口是？",
    "options": {
      "A": "Lock",
      "B": "Mutex",
      "C": "Synchronized",
      "D": "Monitor"
    },
    "answer": [
      "A"
    ],
    "explanation": "Lock接口用于线程同步。"
  },
  {
    "id": 526,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是协程的调度策略？",
    "options": {
      "A": "IO调度",
      "B": "计算调度",
      "C": "主线程调度",
      "D": "无约束调度"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "IO调度、计算调度、主线程调度和无约束调度都是协程调度策略。"
  },
  {
    "id": 527,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中垃圾回收的主要目标是？",
    "options": {
      "A": "回收不再使用的内存",
      "B": "提高程序执行速度",
      "C": "减少内存分配",
      "D": "优化缓存使用"
    },
    "answer": [
      "A"
    ],
    "explanation": "垃圾回收的主要目标是自动回收不再使用的内存。"
  },
  {
    "id": 528,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些技术可以优化内存使用？",
    "options": {
      "A": "对象池",
      "B": "栈上分配",
      "C": "内存映射",
      "D": "压缩指针"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "对象池、栈上分配和压缩指针可以优化内存使用。"
  },
  {
    "id": 529,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于数学计算的类库是？",
    "options": {
      "A": "Math",
      "B": "Arithmetic",
      "C": "Calculate",
      "D": "Number"
    },
    "answer": [
      "A"
    ],
    "explanation": "Math类库提供数学计算函数。"
  },
  {
    "id": 530,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是文件操作的类？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "Path",
      "D": "FileSystem"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "File、Files和Path类用于文件操作。"
  },
  {
    "id": 531,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中泛型擦除的含义是？",
    "options": {
      "A": "运行时类型信息丢失",
      "B": "编译时类型检查",
      "C": "类型参数替换",
      "D": "代码优化"
    },
    "answer": [
      "A"
    ],
    "explanation": "泛型擦除指泛型类型信息在运行时不可用。"
  },
  {
    "id": 532,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持元编程？",
    "options": {
      "A": "注解处理器",
      "B": "反射API",
      "C": "宏定义",
      "D": "代码生成"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "注解处理器、反射API和代码生成支持元编程，仓颉语言不支持宏定义。"
  },
  {
    "id": 533,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于异常处理的关键字是？",
    "options": {
      "A": "try-catch",
      "B": "try-rescue",
      "C": "try-except",
      "D": "try-handle"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用try-catch进行异常处理。"
  },
  {
    "id": 534,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的循环控制语句？",
    "options": {
      "A": "break",
      "B": "continue",
      "C": "goto",
      "D": "return"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "break和continue是循环控制语句，goto不是仓颉语言关键字。"
  },
  {
    "id": 535,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中范围类型的表示方式是？",
    "options": {
      "A": "1..10",
      "B": "1 to 10",
      "C": "range(1,10)",
      "D": "1-10"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用..操作符表示范围。"
  },
  {
    "id": 536,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些集合操作是惰性的？",
    "options": {
      "A": "Sequence.map",
      "B": "Sequence.filter",
      "C": "List.map",
      "D": "List.filter"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Sequence的操作是惰性的，List的操作是急切的。"
  },
  {
    "id": 537,
    "type": "single",
    "category": "函数编程",
    "difficulty": "简单",
    "question": "仓颉语言中Lambda表达式的语法是？",
    "options": {
      "A": "{参数 -> 表达式}",
      "B": "(参数) -> 表达式",
      "C": "参数 => 表达式",
      "D": "函数(参数) = 表达式"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用{参数 -> 表达式}语法定义Lambda表达式。"
  },
  {
    "id": 538,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是高阶函数的应用场景？",
    "options": {
      "A": "集合处理",
      "B": "回调函数",
      "C": "策略模式",
      "D": "模板方法"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "集合处理、回调和策略模式都适合使用高阶函数。"
  },
  {
    "id": 539,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中对象表达式的作用是？",
    "options": {
      "A": "创建匿名对象",
      "B": "定义单例",
      "C": "实现接口",
      "D": "扩展类"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象表达式用于创建匿名对象实例。"
  },
  {
    "id": 540,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是委托模式的优点？",
    "options": {
      "A": "代码复用",
      "B": "运行时灵活性",
      "C": "解耦",
      "D": "编译时优化"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "委托模式支持代码复用、运行时灵活性和解耦。"
  },
  {
    "id": 541,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中轻量级线程的创建关键字是？",
    "options": {
      "A": "spawn",
      "B": "async",
      "C": "go",
      "D": "coroutine"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用spawn关键字创建轻量级线程（协程）。"
  },
  {
    "id": 542,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是原子操作的类型？",
    "options": {
      "A": "AtomicInt",
      "B": "AtomicReference",
      "C": "AtomicBoolean",
      "D": "AtomicLong"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言提供多种原子类型支持原子操作。"
  },
  {
    "id": 543,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中引用队列(ReferenceQueue)的作用是？",
    "options": {
      "A": "跟踪引用对象状态",
      "B": "管理对象生命周期",
      "C": "优化内存分配",
      "D": "提高访问速度"
    },
    "answer": [
      "A"
    ],
    "explanation": "引用队列用于跟踪引用对象的状态变化。"
  },
  {
    "id": 544,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是内存屏障的作用？",
    "options": {
      "A": "保证内存访问顺序",
      "B": "提高内存分配速度",
      "C": "防止指令重排序",
      "D": "优化缓存使用"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "内存屏障保证内存访问顺序和防止指令重排序。"
  },
  {
    "id": 545,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中用于正则表达式匹配的类是？",
    "options": {
      "A": "Regex",
      "B": "Pattern",
      "C": "RegExp",
      "D": "Matcher"
    },
    "answer": [
      "A"
    ],
    "explanation": "Regex类用于正则表达式匹配。"
  },
  {
    "id": 546,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是序列操作的优化策略？",
    "options": {
      "A": "流水线操作",
      "B": "惰性求值",
      "C": "中间结果缓存",
      "D": "并行处理"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "流水线操作和惰性求值是序列操作的主要优化策略。"
  },
  {
    "id": 547,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中定义类型别名的关键字是？",
    "options": {
      "A": "type",
      "B": "alias",
      "C": "typedef",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "type关键字用于定义类型别名。"
  },
  {
    "id": 548,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是DSL构建的特性？",
    "options": {
      "A": "中缀函数",
      "B": "运算符重载",
      "C": "扩展函数",
      "D": "带接收者的Lambda"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些特性都支持领域特定语言(DSL)的构建。"
  },
  {
    "id": 549,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "在仓颉语言中实现响应式编程的最佳方式是？",
    "options": {
      "A": "使用Flow API",
      "B": "使用回调函数",
      "C": "使用事件总线",
      "D": "使用观察者模式"
    },
    "answer": [
      "A"
    ],
    "explanation": "Flow API是仓颉语言中实现响应式编程的推荐方式。"
  },
  {
    "id": 550,
    "type": "multiple",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是微服务架构的最佳实践？",
    "options": {
      "A": "使用HTTP客户端",
      "B": "实现熔断器模式",
      "C": "使用配置管理",
      "D": "实现服务发现"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些都是在仓颉语言中构建微服务架构的重要实践。"
  },
  {
    "id": 551,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中用于模式匹配的关键字是？",
    "options": {
      "A": "match",
      "B": "switch",
      "C": "case",
      "D": "pattern"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 match 关键字进行模式匹配。"
  },
  {
    "id": 552,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的数字字面量格式？",
    "options": {
      "A": "100_000",
      "B": "0xFF",
      "C": "0b1010",
      "D": "1.5e3"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持使用下划线分隔、十六进制、二进制和科学计数法表示数字。"
  },
  {
    "id": 553,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示任意类型的根类型是？",
    "options": {
      "A": "Any",
      "B": "Object",
      "C": "Root",
      "D": "Base"
    },
    "answer": [
      "A"
    ],
    "explanation": "Any 是所有类型的超类，表示任意类型。"
  },
  {
    "id": 554,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的转换操作？",
    "options": {
      "A": "map",
      "B": "flatMap",
      "C": "asSequence",
      "D": "toSet"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些操作都可以将集合转换为其他形式。"
  },
  {
    "id": 555,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中函数柯里化的实现方式是？",
    "options": {
      "A": "自动支持",
      "B": "手动创建部分应用函数",
      "C": "使用curry关键字",
      "D": "不支持柯里化"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言需要手动创建部分应用函数来实现柯里化效果。"
  },
  {
    "id": 556,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是函数式编程的优势？",
    "options": {
      "A": "代码简洁性",
      "B": "易于测试",
      "C": "更好的并发支持",
      "D": "性能优化"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "函数式编程提供代码简洁、易于测试和更好的并发支持，但不一定带来性能优化。"
  },
  {
    "id": 557,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中定义抽象类的关键字是？",
    "options": {
      "A": "abstract class",
      "B": "virtual class",
      "C": "base class",
      "D": "abstract"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 abstract class 定义抽象类。"
  },
  {
    "id": 558,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是对象表达式的用途？",
    "options": {
      "A": "创建匿名对象",
      "B": "实现接口",
      "C": "扩展类",
      "D": "替代Lambda表达式"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "对象表达式用于创建匿名对象、实现接口和扩展类。"
  },
  {
    "id": 559,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于异步计算的函数是？",
    "options": {
      "A": "async",
      "B": "launch",
      "C": "spawn",
      "D": "future"
    },
    "answer": [
      "A"
    ],
    "explanation": "async 函数用于启动返回 Deferred 结果的异步计算。"
  },
  {
    "id": 560,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是通道的关闭策略？",
    "options": {
      "A": "显式关闭",
      "B": "自动关闭",
      "C": "广播关闭",
      "D": "延迟关闭"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "通道需要显式关闭，关闭时会向所有接收者广播关闭信号。"
  },
  {
    "id": 561,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中软引用的主要用途是？",
    "options": {
      "A": "缓存实现",
      "B": "避免循环引用",
      "C": "提高访问速度",
      "D": "减少内存占用"
    },
    "answer": [
      "A"
    ],
    "explanation": "软引用常用于缓存实现，在内存不足时会被回收。"
  },
  {
    "id": 562,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是垃圾回收的触发条件？",
    "options": {
      "A": "堆内存不足",
      "B": "系统空闲时",
      "C": "手动调用",
      "D": "对象创建频繁"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "垃圾回收在堆内存不足或系统空闲时触发，不支持手动调用。"
  },
  {
    "id": 563,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于生成随机数的类是？",
    "options": {
      "A": "Random",
      "B": "Math.random()",
      "C": "Randomizer",
      "D": "Rand"
    },
    "answer": [
      "A"
    ],
    "explanation": "Random 类用于生成随机数。"
  },
  {
    "id": 564,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是日期时间操作的类？",
    "options": {
      "A": "DateTime",
      "B": "Calendar",
      "C": "Time",
      "D": "Duration"
    },
    "answer": [
      "A",
      "D"
    ],
    "explanation": "DateTime 和 Duration 类用于日期时间操作。"
  },
  {
    "id": 565,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中类型投影的关键字是？",
    "options": {
      "A": "out",
      "B": "in",
      "C": "projected",
      "D": "variant"
    },
    "answer": [
      "A"
    ],
    "explanation": "out 关键字用于协变类型投影。"
  },
  {
    "id": 566,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是注解处理器的应用场景？",
    "options": {
      "A": "代码生成",
      "B": "编译时验证",
      "C": "运行时优化",
      "D": "依赖注入"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "注解处理器用于代码生成、编译时验证和依赖注入等。"
  },
  {
    "id": 567,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于范围迭代的关键字是？",
    "options": {
      "A": "in",
      "B": "for",
      "C": "each",
      "D": "loop"
    },
    "answer": [
      "A"
    ],
    "explanation": "in 关键字用于范围迭代，如 for (i in 1..10)。"
  },
  {
    "id": 568,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的字符串模板功能？",
    "options": {
      "A": "变量插值",
      "B": "表达式计算",
      "C": "函数调用",
      "D": "多行字符串"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "字符串模板支持变量插值、表达式计算、函数调用和多行字符串。"
  },
  {
    "id": 569,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示无符号整数的类型前缀是？",
    "options": {
      "A": "U",
      "B": "Unsigned",
      "C": "u",
      "D": "unsigned"
    },
    "answer": [
      "A"
    ],
    "explanation": "U 前缀表示无符号整数，如 UInt、ULong。"
  },
  {
    "id": 570,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是泛型约束的方式？",
    "options": {
      "A": "上界约束",
      "B": "下界约束",
      "C": "多个约束",
      "D": "where子句"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持上界约束、多个约束和where子句，不支持下界约束。"
  },
  {
    "id": 571,
    "type": "single",
    "category": "函数编程",
    "difficulty": "简单",
    "question": "仓颉语言中定义局部函数的位置是？",
    "options": {
      "A": "其他函数内部",
      "B": "类内部",
      "C": "文件顶层",
      "D": "模块内部"
    },
    "answer": [
      "A"
    ],
    "explanation": "局部函数定义在其他函数内部，只能在该函数内访问。"
  },
  {
    "id": 572,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是函数组合的方式？",
    "options": {
      "A": ">> 操作符",
      "B": "compose 函数",
      "C": "andThen 函数",
      "D": "pipe 操作符"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持 >> 操作符、compose 和 andThen 函数进行函数组合。"
  },
  {
    "id": 573,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中伴生对象的访问方式是？",
    "options": {
      "A": "ClassName.Companion",
      "B": "ClassName",
      "C": "Companion",
      "D": "static"
    },
    "answer": [
      "B"
    ],
    "explanation": "伴生对象的成员可以直接通过类名访问。"
  },
  {
    "id": 574,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是内联类的限制？",
    "options": {
      "A": "只能有一个属性",
      "B": "不能继承其他类",
      "C": "不能是泛型类",
      "D": "不能实现接口"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "内联类只能有一个属性，不能继承其他类，但可以实现接口，也可以是泛型类。"
  },
  {
    "id": 575,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中协程上下文包含的主要元素是？",
    "options": {
      "A": "调度器",
      "B": "作业",
      "C": "异常处理器",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "协程上下文包含调度器、作业、异常处理器等元素。"
  },
  {
    "id": 576,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是避免竞态条件的技术？",
    "options": {
      "A": "使用原子变量",
      "B": "使用不可变对象",
      "C": "使用线程局部存储",
      "D": "使用同步块"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些技术都可以帮助避免竞态条件。"
  },
  {
    "id": 577,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中对象生命周期的最后一个阶段是？",
    "options": {
      "A": "可达性分析",
      "B": "终结阶段",
      "C": "回收阶段",
      "D": "清理阶段"
    },
    "answer": [
      "B"
    ],
    "explanation": "对象在垃圾回收前会经历终结阶段，执行清理操作。"
  },
  {
    "id": 578,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是内存优化的策略？",
    "options": {
      "A": "使用基本类型数组",
      "B": "避免装箱操作",
      "C": "使用对象池",
      "D": "减少对象创建"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些策略都可以帮助优化内存使用。"
  },
  {
    "id": 579,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于文件读写的类是？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "FileSystem",
      "D": "IO"
    },
    "answer": [
      "A"
    ],
    "explanation": "File 类用于文件读写操作。"
  },
  {
    "id": 580,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的聚合操作？",
    "options": {
      "A": "sum",
      "B": "average",
      "C": "min",
      "D": "max"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些函数用于计算集合的聚合值。"
  },
  {
    "id": 581,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中反射API的主要用途是？",
    "options": {
      "A": "运行时类型检查",
      "B": "动态方法调用",
      "C": "注解处理",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "反射API用于运行时类型检查、动态方法调用和注解处理等。"
  },
  {
    "id": 582,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是类型安全的构建器模式要素？",
    "options": {
      "A": "带接收者的函数类型",
      "B": "中缀函数",
      "C": "扩展函数",
      "D": "泛型约束"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些特性共同支持类型安全的构建器模式实现。"
  },
  {
    "id": 583,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中智能转换的发生条件是？",
    "options": {
      "A": "使用is检查后",
      "B": "在when分支中",
      "C": "编译器能推断类型",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "在这些情况下，仓颉语言会自动进行智能类型转换。"
  },
  {
    "id": 584,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的标识符命名规则？",
    "options": {
      "A": "以字母或下划线开头",
      "B": "可以包含数字",
      "C": "可以使用反引号包围关键字",
      "D": "可以使用特殊字符"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "标识符以字母或下划线开头，可以包含数字，可以使用反引号包围关键字。"
  },
  {
    "id": 585,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中数组的初始化函数是？",
    "options": {
      "A": "arrayOf",
      "B": "Array",
      "C": "new Array",
      "D": "createArray"
    },
    "answer": [
      "A"
    ],
    "explanation": "arrayOf 函数用于初始化数组。"
  },
  {
    "id": 586,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是序列操作的性能优势？",
    "options": {
      "A": "避免中间集合创建",
      "B": "延迟计算",
      "C": "更好的缓存局部性",
      "D": "并行处理"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "序列通过避免中间集合和延迟计算来优化性能。"
  },
  {
    "id": 587,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中尾递归优化的关键字是？",
    "options": {
      "A": "tailrec",
      "B": "inline",
      "C": "optimize",
      "D": "recursive"
    },
    "answer": [
      "A"
    ],
    "explanation": "tailrec 关键字标记尾递归函数以进行优化。"
  },
  {
    "id": 588,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是函数记忆化的实现方式？",
    "options": {
      "A": "使用缓存装饰器",
      "B": "手动缓存结果",
      "C": "使用lazy委托",
      "D": "使用序列缓存"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "函数记忆化可以通过缓存装饰器或手动缓存结果实现。"
  },
  {
    "id": 589,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中属性委托的by关键字作用是？",
    "options": {
      "A": "委托属性实现",
      "B": "委托方法调用",
      "C": "委托类实现",
      "D": "委托接口实现"
    },
    "answer": [
      "A"
    ],
    "explanation": "by 关键字用于委托属性的实现。"
  },
  {
    "id": 590,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是密封类的优势？",
    "options": {
      "A": "编译时检查完整性",
      "B": "更好的模式匹配",
      "C": "限制继承层次",
      "D": "提高性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "密封类提供编译时检查、更好的模式匹配和限制继承层次。"
  },
  {
    "id": 591,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于协程超时设置的函数是？",
    "options": {
      "A": "withTimeout",
      "B": "timeout",
      "C": "setTimeout",
      "D": "withDeadline"
    },
    "answer": [
      "A"
    ],
    "explanation": "withTimeout 函数用于设置协程执行超时。"
  },
  {
    "id": 592,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是响应式流的特性？",
    "options": {
      "A": "背压支持",
      "B": "异步数据流",
      "C": "操作符链式调用",
      "D": "错误处理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "响应式流支持背压、异步数据流、操作符链式调用和错误处理。"
  },
  {
    "id": 593,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中对象分配的主要区域是？",
    "options": {
      "A": "堆",
      "B": "栈",
      "C": "方法区",
      "D": "直接内存"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象主要分配在堆内存中。"
  },
  {
    "id": 594,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是内存泄漏的检测方法？",
    "options": {
      "A": "堆转储分析",
      "B": "内存分析器",
      "C": "引用跟踪",
      "D": "日志分析"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "堆转储分析、内存分析器和引用跟踪是检测内存泄漏的有效方法。"
  },
  {
    "id": 595,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中用于网络请求的类是？",
    "options": {
      "A": "HttpClient",
      "B": "Net",
      "C": "Web",
      "D": "Request"
    },
    "answer": [
      "A"
    ],
    "explanation": "HttpClient 类用于进行HTTP网络请求。"
  },
  {
    "id": 596,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是集合的性能优化操作？",
    "options": {
      "A": "使用序列处理大数据",
      "B": "使用数组处理基本类型",
      "C": "使用视图避免复制",
      "D": "使用并行流"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "序列、基本类型数组和视图都可以优化集合操作性能。"
  },
  {
    "id": 597,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中逆变类型投影的关键字是？",
    "options": {
      "A": "in",
      "B": "out",
      "C": "contra",
      "D": "negative"
    },
    "answer": [
      "A"
    ],
    "explanation": "in 关键字用于逆变类型投影。"
  },
  {
    "id": 598,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是编译时代码生成的用途？",
    "options": {
      "A": "减少运行时反射",
      "B": "提高性能",
      "C": "增强类型安全",
      "D": "简化API使用"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "编译时代码生成可以减少运行时反射、提高性能、增强类型安全和简化API使用。"
  },
  {
    "id": 599,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "在仓颉语言中实现事件驱动架构的最佳方式是？",
    "options": {
      "A": "使用Flow和Channel",
      "B": "使用回调函数",
      "C": "使用观察者模式",
      "D": "使用消息队列"
    },
    "answer": [
      "A"
    ],
    "explanation": "Flow和Channel提供了构建事件驱动架构的现代方式。"
  },
  {
    "id": 600,
    "type": "multiple",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是微服务通信的最佳实践？",
    "options": {
      "A": "使用RESTful API",
      "B": "使用gRPC",
      "C": "使用消息队列",
      "D": "使用服务网格"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些都是在微服务架构中进行服务通信的有效方式。"
  },
  {
    "id": 601,
    "type": "single",
    "category": "模块系统",
    "difficulty": "简单",
    "question": "仓颉语言中导入整个模块的关键字是？",
    "options": {
      "A": "import",
      "B": "include",
      "C": "use",
      "D": "require"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 import 关键字导入整个模块。"
  },
  {
    "id": 602,
    "type": "single",
    "category": "模块系统",
    "difficulty": "简单",
    "question": "仓颉语言中导出模块成员的关键字是？",
    "options": {
      "A": "export",
      "B": "public",
      "C": "expose",
      "D": "out"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 export 关键字导出模块中的成员供外部使用。"
  },
  {
    "id": 603,
    "type": "single",
    "category": "模块系统",
    "difficulty": "中等",
    "question": "仓颉语言中导入模块特定成员的语法是？",
    "options": {
      "A": "import { member } from 'module'",
      "B": "import member from 'module'",
      "C": "use module.member",
      "D": "include module::member"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言通过 import { 成员名 } from '模块名' 语法导入模块中的特定成员。"
  },
  {
    "id": 604,
    "type": "single",
    "category": "模块系统",
    "difficulty": "中等",
    "question": "仓颉语言中模块的入口文件通常命名为？",
    "options": {
      "A": "main.cj",
      "B": "index.cj",
      "C": "entry.cj",
      "D": "module.cj"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中模块的入口文件通常约定为 main.cj。"
  },
  {
    "id": 605,
    "type": "single",
    "category": "模块系统",
    "difficulty": "困难",
    "question": "仓颉语言中模块别名的定义方式是？",
    "options": {
      "A": "import module as alias",
      "B": "import alias = module",
      "C": "use module alias",
      "D": "module alias = module"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 import 模块名 as 别名 为导入的模块定义别名。"
  },
  {
    "id": 606,
    "type": "single",
    "category": "错误处理",
    "difficulty": "简单",
    "question": "仓颉语言中抛出异常的关键字是？",
    "options": {
      "A": "throw",
      "B": "raise",
      "C": "emit",
      "D": "throwException"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 throw 关键字抛出异常。"
  },
  {
    "id": 607,
    "type": "single",
    "category": "错误处理",
    "difficulty": "简单",
    "question": "仓颉语言中处理异常后一定会执行的块是？",
    "options": {
      "A": "finally",
      "B": "after",
      "C": "always",
      "D": "done"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 finally 块中的代码无论是否发生异常都会执行。"
  },
  {
    "id": 608,
    "type": "single",
    "category": "错误处理",
    "difficulty": "中等",
    "question": "仓颉语言中自定义异常的方式是？",
    "options": {
      "A": "继承 Exception 类",
      "B": "使用 exception 关键字定义",
      "C": "实现 Error 接口",
      "D": "通过 enum 定义"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中自定义异常需继承内置的 Exception 类。"
  },
  {
    "id": 609,
    "type": "single",
    "category": "错误处理",
    "difficulty": "中等",
    "question": "仓颉语言中捕获所有异常的方式是？",
    "options": {
      "A": "catch (Exception e)",
      "B": "catch (Any e)",
      "C": "catch (*)",
      "D": "catch"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 catch (Exception e) 可以捕获所有继承自 Exception 的异常。"
  },
  {
    "id": 610,
    "type": "single",
    "category": "错误处理",
    "difficulty": "困难",
    "question": "仓颉语言中异常与错误的主要区别是？",
    "options": {
      "A": "异常可恢复，错误不可恢复",
      "B": "异常是编译时，错误是运行时",
      "C": "异常由用户抛出，错误由系统抛出",
      "D": "异常不中断程序，错误中断程序"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中，异常通常表示可恢复的问题，错误表示严重的、不可恢复的问题。"
  },
  {
    "id": 611,
    "type": "single",
    "category": "泛型进阶",
    "difficulty": "中等",
    "question": "仓颉语言中泛型约束的关键字是？",
    "options": {
      "A": "where",
      "B": "constraint",
      "C": "extends",
      "D": "limit"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 where 关键字对泛型参数进行约束。"
  },
  {
    "id": 612,
    "type": "single",
    "category": "泛型进阶",
    "difficulty": "中等",
    "question": "仓颉语言中泛型通配符的表示方式是？",
    "options": {
      "A": "?",
      "B": "*",
      "C": "_",
      "D": "any"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 ? 作为泛型通配符，表示任意类型。"
  },
  {
    "id": 613,
    "type": "single",
    "category": "泛型进阶",
    "difficulty": "困难",
    "question": "仓颉语言中泛型方法的定义位置是？",
    "options": {
      "A": "类内部或独立定义",
      "B": "只能在类内部",
      "C": "只能独立定义",
      "D": "必须在接口中"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中的泛型方法既可以定义在类内部，也可以作为独立的函数定义。"
  },
  {
    "id": 614,
    "type": "single",
    "category": "泛型进阶",
    "difficulty": "困难",
    "question": "仓颉语言中泛型类型擦除发生在哪个阶段？",
    "options": {
      "A": "编译时",
      "B": "运行时",
      "C": "链接时",
      "D": "加载时"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言在编译时会进行泛型类型擦除，运行时不保留泛型类型信息。"
  },
  {
    "id": 615,
    "type": "single",
    "category": "泛型进阶",
    "difficulty": "困难",
    "question": "仓颉语言中如何实现泛型的协变？",
    "options": {
      "A": "使用 out 关键字",
      "B": "使用 in 关键字",
      "C": "通过通配符",
      "D": "默认支持协变"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过在泛型参数前添加 out 关键字实现协变。"
  },
  {
    "id": 616,
    "type": "single",
    "category": "运算符重载",
    "difficulty": "中等",
    "question": "仓颉语言中重载加法运算符的方法名是？",
    "options": {
      "A": "plus",
      "B": "add",
      "C": "operator+",
      "D": "sum"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过定义 plus 方法重载加法运算符。"
  },
  {
    "id": 617,
    "type": "single",
    "category": "运算符重载",
    "difficulty": "中等",
    "question": "仓颉语言中重载比较运算符（==）的方法名是？",
    "options": {
      "A": "equals",
      "B": "compare",
      "C": "operator==",
      "D": "equalTo"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过定义 equals 方法重载相等比较运算符（==）。"
  },
  {
    "id": 618,
    "type": "single",
    "category": "运算符重载",
    "difficulty": "困难",
    "question": "仓颉语言中不能被重载的运算符是？",
    "options": {
      "A": "=",
      "B": "+",
      "C": "*",
      "D": "%"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中赋值运算符（=）不能被重载。"
  },
  {
    "id": 619,
    "type": "single",
    "category": "运算符重载",
    "difficulty": "困难",
    "question": "仓颉语言中重载一元运算符的方法特点是？",
    "options": {
      "A": "无参数",
      "B": "一个参数",
      "C": "两个参数",
      "D": "可变参数"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中重载一元运算符的方法没有参数，操作当前对象。"
  },
  {
    "id": 620,
    "type": "single",
    "category": "运算符重载",
    "difficulty": "困难",
    "question": "仓颉语言中运算符重载的访问修饰符通常为？",
    "options": {
      "A": "public",
      "B": "private",
      "C": "internal",
      "D": "无限制"
    },
    "answer": [
      "A"
    ],
    "explanation": "运算符重载方法需要被外部访问，因此通常使用 public 修饰符。"
  },
  {
    "id": 621,
    "type": "single",
    "category": "委托与事件",
    "difficulty": "中等",
    "question": "仓颉语言中委托的定义关键字是？",
    "options": {
      "A": "delegate",
      "B": "func",
      "C": "action",
      "D": "callback"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 delegate 关键字定义委托类型。"
  },
  {
    "id": 622,
    "type": "single",
    "category": "委托与事件",
    "difficulty": "中等",
    "question": "仓颉语言中事件的定义关键字是？",
    "options": {
      "A": "event",
      "B": "signal",
      "C": "trigger",
      "D": "notify"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 event 关键字定义事件。"
  },
  {
    "id": 623,
    "type": "single",
    "category": "委托与事件",
    "difficulty": "困难",
    "question": "仓颉语言中订阅事件的运算符是？",
    "options": {
      "A": "+=",
      "B": "=",
      "C": "=>",
      "D": "->"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 += 运算符为事件订阅处理方法。"
  },
  {
    "id": 624,
    "type": "single",
    "category": "委托与事件",
    "difficulty": "困难",
    "question": "仓颉语言中多播委托的执行顺序是？",
    "options": {
      "A": "按照订阅顺序执行",
      "B": "随机执行",
      "C": "按照方法名排序执行",
      "D": "逆序执行"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中多播委托中的方法按照订阅（添加）的顺序依次执行。"
  },
  {
    "id": 625,
    "type": "single",
    "category": "委托与事件",
    "difficulty": "困难",
    "question": "仓颉语言中事件与委托的关系是？",
    "options": {
      "A": "事件基于委托实现",
      "B": "委托基于事件实现",
      "C": "两者完全独立",
      "D": "两者是同一概念"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中事件是特殊的委托实例，提供了更严格的访问控制。"
  },
  {
    "id": 626,
    "type": "single",
    "category": "注解进阶",
    "difficulty": "中等",
    "question": "仓颉语言中注解的保留策略关键字是？",
    "options": {
      "A": "Retention",
      "B": "Keep",
      "C": "Preserve",
      "D": "Retain"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Retention 注解指定注解的保留策略（源文件、类文件或运行时）。"
  },
  {
    "id": 627,
    "type": "single",
    "category": "注解进阶",
    "difficulty": "中等",
    "question": "仓颉语言中注解可应用的目标由哪个注解指定？",
    "options": {
      "A": "Target",
      "B": "ApplyTo",
      "C": "Scope",
      "D": "Range"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 Target 注解指定自定义注解可以应用的程序元素（类、方法等）。"
  },
  {
    "id": 628,
    "type": "single",
    "category": "注解进阶",
    "difficulty": "困难",
    "question": "仓颉语言中运行时获取注解信息的方式是？",
    "options": {
      "A": "通过反射API",
      "B": "通过注解处理器",
      "C": "直接访问注解属性",
      "D": "通过编译器API"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中在运行时需通过反射API（如 Mirror 类）获取注解信息。"
  },
  {
    "id": 629,
    "type": "single",
    "category": "注解进阶",
    "difficulty": "困难",
    "question": "仓颉语言中注解处理器的作用是？",
    "options": {
      "A": "编译时处理注解并生成代码",
      "B": "运行时处理注解逻辑",
      "C": "验证注解的正确性",
      "D": "优化注解的性能"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的注解处理器在编译阶段工作，可根据注解生成额外的代码或资源。"
  },
  {
    "id": 630,
    "type": "single",
    "category": "注解进阶",
    "difficulty": "困难",
    "question": "仓颉语言中可重复注解的声明方式是？",
    "options": {
      "A": "使用 Repeatable 注解标记",
      "B": "定义数组类型的注解属性",
      "C": "多次定义同一注解",
      "D": "继承 Repeatable 接口"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 @Repeatable 注解标记自定义注解为可重复注解，允许在同一元素上多次应用。"
  },
  {
    "id": 631,
    "type": "single",
    "category": "集合进阶",
    "difficulty": "中等",
    "question": "仓颉语言中获取集合大小的方法是？",
    "options": {
      "A": "size()",
      "B": "length()",
      "C": "count()",
      "D": "getSize()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中集合类型通过 size() 方法获取元素数量。"
  },
  {
    "id": 632,
    "type": "single",
    "category": "集合进阶",
    "difficulty": "中等",
    "question": "仓颉语言中判断集合是否为空的方法是？",
    "options": {
      "A": "isEmpty()",
      "B": "isNull()",
      "C": "hasElements()",
      "D": "empty()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中集合的 isEmpty() 方法用于判断集合是否不包含任何元素。"
  },
  {
    "id": 633,
    "type": "single",
    "category": "集合进阶",
    "difficulty": "困难",
    "question": "仓颉语言中集合的流式操作入口方法是？",
    "options": {
      "A": "stream()",
      "B": "flow()",
      "C": "sequence()",
      "D": "pipe()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过集合的 stream() 方法获取流对象，进行流式操作（过滤、映射等）。"
  },
  {
    "id": 634,
    "type": "single",
    "category": "集合进阶",
    "difficulty": "困难",
    "question": "仓颉语言中Map集合获取值的方法是？",
    "options": {
      "A": "get(key)",
      "B": "getValue(key)",
      "C": "find(key)",
      "D": "lookup(key)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Map 集合通过 get(key) 方法根据键获取对应的值。"
  },
  {
    "id": 635,
    "type": "single",
    "category": "集合进阶",
    "difficulty": "困难",
    "question": "仓颉语言中不可变集合的创建方式是？",
    "options": {
      "A": "使用 of() 方法",
      "B": "使用 immutable 关键字",
      "C": "通过构造函数",
      "D": "使用 freeze() 方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过集合的 of() 静态方法创建不可变集合，创建后不能修改其元素。"
  },
  {
    "id": 636,
    "type": "single",
    "category": "字符串处理",
    "difficulty": "简单",
    "question": "仓颉语言中字符串拼接的运算符是？",
    "options": {
      "A": "+",
      "B": "&",
      "C": ".",
      "D": "<<"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 + 运算符进行字符串拼接。"
  },
  {
    "id": 637,
    "type": "single",
    "category": "字符串处理",
    "difficulty": "简单",
    "question": "仓颉语言中字符串转换为小写的方法是？",
    "options": {
      "A": "toLowerCase()",
      "B": "toLower()",
      "C": "lowercase()",
      "D": "lower()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中字符串的 toLowerCase() 方法将所有字符转换为小写。"
  },
  {
    "id": 638,
    "type": "single",
    "category": "字符串处理",
    "difficulty": "中等",
    "question": "仓颉语言中判断字符串是否包含子串的方法是？",
    "options": {
      "A": "contains(substr)",
      "B": "has(substr)",
      "C": "includes(substr)",
      "D": "find(substr)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中字符串的 contains(substr) 方法判断当前字符串是否包含指定子串。"
  },
  {
    "id": 639,
    "type": "single",
    "category": "字符串处理",
    "difficulty": "中等",
    "question": "仓颉语言中字符串替换的方法是？",
    "options": {
      "A": "replace(old, new)",
      "B": "swap(old, new)",
      "C": "change(old, new)",
      "D": "update(old, new)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中字符串的 replace(old, new) 方法将所有旧子串替换为新子串。"
  },
  {
    "id": 640,
    "type": "single",
    "category": "字符串处理",
    "difficulty": "困难",
    "question": "仓颉语言中字符串插值的语法是？",
    "options": {
      "A": "`Hello ${name}`",
      "B": "Hello {name}",
      "C": "Hello $name",
      "D": "Hello @name"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用反引号包裹字符串，并通过 ${} 语法进行变量插值。"
  },
  {
    "id": 641,
    "type": "single",
    "category": "日期时间",
    "difficulty": "简单",
    "question": "仓颉语言中表示日期的类是？",
    "options": {
      "A": "Date",
      "B": "Day",
      "C": "Calendar",
      "D": "DateTime"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Date 类用于表示日期（年、月、日）。"
  },
  {
    "id": 642,
    "type": "single",
    "category": "日期时间",
    "difficulty": "简单",
    "question": "仓颉语言中获取当前日期的方法是？",
    "options": {
      "A": "Date.today()",
      "B": "Date.now()",
      "C": "new Date()",
      "D": "Date.current()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Date.today() 方法返回当前日期（忽略时间部分）。"
  },
  {
    "id": 643,
    "type": "single",
    "category": "日期时间",
    "difficulty": "中等",
    "question": "仓颉语言中计算两个日期差值的方法是？",
    "options": {
      "A": "minus()",
      "B": "subtract()",
      "C": "diff()",
      "D": "distance()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中日期对象的 minus() 方法用于计算与另一个日期的差值（返回时间间隔）。"
  },
  {
    "id": 644,
    "type": "single",
    "category": "日期时间",
    "difficulty": "中等",
    "question": "仓颉语言中日期格式化的方法是？",
    "options": {
      "A": "format(pattern)",
      "B": "toString(pattern)",
      "C": "parse(pattern)",
      "D": "stringify(pattern)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中日期对象的 format(pattern) 方法根据指定模式将日期转换为字符串。"
  },
  {
    "id": 645,
    "type": "single",
    "category": "日期时间",
    "difficulty": "困难",
    "question": "仓颉语言中时间间隔的类是？",
    "options": {
      "A": "Duration",
      "B": "Interval",
      "C": "Period",
      "D": "TimeSpan"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Duration 类表示时间间隔（如几小时、几分钟）。"
  },
  {
    "id": 646,
    "type": "single",
    "category": "文件IO进阶",
    "difficulty": "中等",
    "question": "仓颉语言中读取文件所有内容的方法是？",
    "options": {
      "A": "File.readAllText(path)",
      "B": "File.read(path)",
      "C": "File.load(path)",
      "D": "File.getText(path)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 File 类的 readAllText(path) 方法一次性读取文件的所有文本内容。"
  },
  {
    "id": 647,
    "type": "single",
    "category": "文件IO进阶",
    "difficulty": "中等",
    "question": "仓颉语言中写入文件内容的方法是？",
    "options": {
      "A": "File.writeAllText(path, content)",
      "B": "File.write(path, content)",
      "C": "File.save(path, content)",
      "D": "File.putText(path, content)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 File 类的 writeAllText(path, content) 方法将文本内容写入指定文件。"
  },
  {
    "id": 648,
    "type": "single",
    "category": "文件IO进阶",
    "difficulty": "困难",
    "question": "仓颉语言中处理大文件时推荐使用的类是？",
    "options": {
      "A": "FileStream",
      "B": "BufferedReader",
      "C": "StreamReader",
      "D": "FileReader"
    },
    "answer": [
      "A"
    ],
    "explanation": "处理大文件时，仓颉语言推荐使用 FileStream 类进行流式读写，减少内存占用。"
  },
  {
    "id": 649,
    "type": "single",
    "category": "文件IO进阶",
    "difficulty": "困难",
    "question": "仓颉语言中判断文件是否存在的方法是？",
    "options": {
      "A": "File.exists(path)",
      "B": "File.hasFile(path)",
      "C": "File.isExist(path)",
      "D": "File.checkExists(path)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 File 类的 exists(path) 方法用于判断指定路径的文件是否存在。"
  },
  {
    "id": 650,
    "type": "single",
    "category": "文件IO进阶",
    "difficulty": "困难",
    "question": "仓颉语言中创建目录的方法是？",
    "options": {
      "A": "Directory.create(path)",
      "B": "File.makeDir(path)",
      "C": "Folder.create(path)",
      "D": "mkdir(path)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Directory 类的 create(path) 方法用于创建指定路径的目录。"
  },
  {
    "id": 651,
    "type": "single",
    "category": "网络编程",
    "difficulty": "中等",
    "question": "仓颉语言中发送GET请求的方法是？",
    "options": {
      "A": "HttpClient.get(url)",
      "B": "HttpClient.sendGet(url)",
      "C": "Http.get(url)",
      "D": "Request.get(url)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 HttpClient 类的 get(url) 方法用于发送HTTP GET请求。"
  },
  {
    "id": 652,
    "type": "single",
    "category": "网络编程",
    "difficulty": "中等",
    "question": "仓颉语言中设置HTTP请求头的方法是？",
    "options": {
      "A": "setHeader(name, value)",
      "B": "addHeader(name, value)",
      "C": "header(name, value)",
      "D": "putHeader(name, value)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中HTTP请求对象通过 setHeader(name, value) 方法设置请求头。"
  },
  {
    "id": 653,
    "type": "single",
    "category": "网络编程",
    "difficulty": "困难",
    "question": "仓颉语言中处理HTTP响应状态码的属性是？",
    "options": {
      "A": "statusCode",
      "B": "code",
      "C": "status",
      "D": "responseCode"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中HTTP响应对象的 statusCode 属性表示响应的状态码（如200、404）。"
  },
  {
    "id": 654,
    "type": "single",
    "category": "网络编程",
    "difficulty": "困难",
    "question": "仓颉语言中WebSocket连接的类是？",
    "options": {
      "A": "WebSocket",
      "B": "WsClient",
      "C": "WebSocketClient",
      "D": "WsConnection"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 WebSocket 类建立和处理WebSocket连接。"
  },
  {
    "id": 655,
    "type": "single",
    "category": "网络编程",
    "difficulty": "困难",
    "question": "仓颉语言中TCP服务器的创建类是？",
    "options": {
      "A": "TcpServer",
      "B": "ServerSocket",
      "C": "TcpListener",
      "D": "TcpConnection"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 TcpServer 类创建TCP服务器，监听和处理客户端连接。"
  },
  {
    "id": 656,
    "type": "single",
    "category": "数据库操作",
    "difficulty": "中等",
    "question": "仓颉语言中执行SQL查询的方法是？",
    "options": {
      "A": "query(sql)",
      "B": "executeQuery(sql)",
      "C": "runQuery(sql)",
      "D": "fetch(sql)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中数据库连接对象的 query(sql) 方法用于执行SQL查询语句并返回结果。"
  },
  {
    "id": 657,
    "type": "single",
    "category": "数据库操作",
    "difficulty": "中等",
    "question": "仓颉语言中执行SQL更新语句的方法是？",
    "options": {
      "A": "execute(sql)",
      "B": "update(sql)",
      "C": "run(sql)",
      "D": "exec(sql)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中数据库连接对象的 execute(sql) 方法用于执行SQL更新语句（INSERT、UPDATE、DELETE等）。"
  },
  {
    "id": 658,
    "type": "single",
    "category": "数据库操作",
    "difficulty": "困难",
    "question": "仓颉语言中防止SQL注入的方式是？",
    "options": {
      "A": "使用参数化查询",
      "B": "手动拼接SQL语句",
      "C": "使用字符串替换",
      "D": "过滤特殊字符"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中推荐使用参数化查询防止SQL注入，通过占位符传递参数。"
  },
  {
    "id": 659,
    "type": "single",
    "category": "数据库操作",
    "difficulty": "困难",
    "question": "仓颉语言中事务提交的方法是？",
    "options": {
      "A": "commit()",
      "B": "submit()",
      "C": "save()",
      "D": "apply()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中数据库事务通过 commit() 方法提交，将所有操作持久化到数据库。"
  },
  {
    "id": 660,
    "type": "single",
    "category": "数据库操作",
    "difficulty": "困难",
    "question": "仓颉语言中事务回滚的方法是？",
    "options": {
      "A": "rollback()",
      "B": "undo()",
      "C": "revert()",
      "D": "cancel()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中数据库事务通过 rollback() 方法回滚，撤销所有未提交的操作。"
  },
  {
    "id": 661,
    "type": "single",
    "category": "并发进阶",
    "difficulty": "困难",
    "question": "仓颉语言中等待多个协程完成的方法是？",
    "options": {
      "A": "joinAll()",
      "B": "waitAll()",
      "C": "awaitAll()",
      "D": "finishAll()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 joinAll() 方法等待多个协程执行完成。"
  },
  {
    "id": 662,
    "type": "single",
    "category": "并发进阶",
    "difficulty": "困难",
    "question": "仓颉语言中限制协程并发数量的类是？",
    "options": {
      "A": "Semaphore",
      "B": "Limiter",
      "C": "CoroutineLimit",
      "D": "ConcurrentControl"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Semaphore（信号量）可用于限制同时运行的协程数量。"
  },
  {
    "id": 663,
    "type": "single",
    "category": "并发进阶",
    "difficulty": "困难",
    "question": "仓颉语言中读写锁的类是？",
    "options": {
      "A": "ReadWriteLock",
      "B": "RwLock",
      "C": "ReadWriteMutex",
      "D": "RwMutex"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 ReadWriteLock 类实现读写锁，允许多个读操作或一个写操作同时进行。"
  },
  {
    "id": 664,
    "type": "single",
    "category": "并发进阶",
    "difficulty": "困难",
    "question": "仓颉语言中协程休眠的方法是？",
    "options": {
      "A": "sleep(duration)",
      "B": "wait(duration)",
      "C": "pause(duration)",
      "D": "delay(duration)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中协程通过 sleep(duration) 方法休眠指定的时间。"
  },
  {
    "id": 665,
    "type": "single",
    "category": "并发进阶",
    "difficulty": "困难",
    "question": "仓颉语言中原子整数类型是？",
    "options": {
      "A": "AtomicInt",
      "B": "AtomicInteger",
      "C": "IntAtomic",
      "D": "Atomic<Int>"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 AtomicInt 是原子整数类型，支持线程安全的自增、自减等操作。"
  },
  {
    "id": 666,
    "type": "single",
    "category": "内存管理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中垃圾回收的触发时机是？",
    "options": {
      "A": "内存不足时自动触发",
      "B": "只能手动触发",
      "C": "每秒钟触发一次",
      "D": "程序结束时触发"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言的垃圾回收器通常在内存不足时自动触发，也可手动建议触发，但不能保证立即执行。"
  },
  {
    "id": 667,
    "type": "single",
    "category": "内存管理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中强引用的特点是？",
    "options": {
      "A": "阻止对象被回收",
      "B": "不阻止对象被回收",
      "C": "仅在特定条件下阻止回收",
      "D": "与弱引用功能相同"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中强引用是默认的引用类型，持有强引用的对象不会被垃圾回收器回收。"
  },
  {
    "id": 668,
    "type": "single",
    "category": "内存管理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中软引用的类是？",
    "options": {
      "A": "SoftReference",
      "B": "WeakReference",
      "C": "SoftRef",
      "D": "SoftPtr"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 SoftReference 类表示软引用，在内存不足时可能被回收。"
  },
  {
    "id": 669,
    "type": "single",
    "category": "内存管理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中对象的finalize方法作用是？",
    "options": {
      "A": "对象被回收前执行清理操作",
      "B": "对象创建时初始化",
      "C": "对象克隆时调用",
      "D": "对象序列化时调用"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中对象的 finalize 方法在对象被垃圾回收前调用，可用于释放资源等清理操作。"
  },
  {
    "id": 670,
    "type": "single",
    "category": "内存管理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中减少内存碎片的方法是？",
    "options": {
      "A": "使用内存池",
      "B": "频繁创建大对象",
      "C": "禁用垃圾回收",
      "D": "使用手动内存管理"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用内存池可以重复利用内存块，减少内存分配和回收的频率，从而减少内存碎片。"
  },
  {
    "id": 671,
    "type": "single",
    "category": "语法进阶",
    "difficulty": "中等",
    "question": "仓颉语言中匿名函数的表示方式是？",
    "options": {
      "A": "() => { ... }",
      "B": "function() { ... }",
      "C": "lambda() { ... }",
      "D": "func() { ... }"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用箭头语法 () => { ... } 定义匿名函数。"
  },
  {
    "id": 672,
    "type": "single",
    "category": "语法进阶",
    "difficulty": "中等",
    "question": "仓颉语言中可变参数的表示方式是？",
    "options": {
      "A": "param...",
      "B": "...param",
      "C": "param*",
      "D": "*param"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中在参数名后添加 ... 表示可变参数，允许传递任意数量的同类型参数。"
  },
  {
    "id": 673,
    "type": "single",
    "category": "语法进阶",
    "difficulty": "困难",
    "question": "仓颉语言中解构赋值的语法是？",
    "options": {
      "A": "let (a, b) = pair",
      "B": "let a, b = pair",
      "C": "let {a, b} = pair",
      "D": "let [a, b] = pair"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 (a, b) = 表达式 的语法进行解构赋值，从元组或类似结构中提取值。"
  },
  {
    "id": 674,
    "type": "single",
    "category": "语法进阶",
    "difficulty": "困难",
    "question": "仓颉语言中 Elvis 运算符的作用是？",
    "options": {
      "A": "简化空值判断",
      "B": "逻辑运算",
      "C": "算术运算",
      "D": "类型转换"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中的 Elvis 运算符（?:）用于简化空值判断，如 a ?: b 表示若a不为空则取a，否则取b。"
  },
  {
    "id": 675,
    "type": "single",
    "category": "语法进阶",
    "difficulty": "困难",
    "question": "仓颉语言中范围表达式的运算符是？",
    "options": {
      "A": "..",
      "B": ":",
      "C": "-",
      "D": "to"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 .. 运算符创建范围表达式，如 1..10 表示从1到10的范围。"
  },
  {
    "id": 676,
    "type": "single",
    "category": "面向对象进阶",
    "difficulty": "困难",
    "question": "仓颉语言中方法重写的关键字是？",
    "options": {
      "A": "override",
      "B": "overwrite",
      "C": "replace",
      "D": "redefine"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 override 关键字标记子类重写父类的方法。"
  },
  {
    "id": 677,
    "type": "single",
    "category": "面向对象进阶",
    "difficulty": "困难",
    "question": "仓颉语言中密封方法的关键字是？",
    "options": {
      "A": "sealed",
      "B": "final",
      "C": "closed",
      "D": "fixed"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 sealed 关键字标记方法，防止子类重写该方法。"
  },
  {
    "id": 678,
    "type": "single",
    "category": "面向对象进阶",
    "difficulty": "困难",
    "question": "仓颉语言中类的静态构造函数的特点是？",
    "options": {
      "A": "仅执行一次",
      "B": "每次创建对象时执行",
      "C": "需要手动调用",
      "D": "可以有多个"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中类的静态构造函数在类第一次被使用时执行，且仅执行一次，用于初始化静态成员。"
  },
  {
    "id": 679,
    "type": "single",
    "category": "面向对象进阶",
    "difficulty": "困难",
    "question": "仓颉语言中对象相等性比较的方法是？",
    "options": {
      "A": "equals()",
      "B": "== 运算符",
      "C": "same()",
      "D": "compare()",
      "E": "A和B"
    },
    "answer": [
      "E"
    ],
    "explanation": "仓颉语言中默认 == 运算符调用 equals() 方法进行对象内容的相等性比较。"
  },
  {
    "id": 680,
    "type": "single",
    "category": "面向对象进阶",
    "difficulty": "困难",
    "question": "仓颉语言中克隆对象的方法是？",
    "options": {
      "A": "clone()",
      "B": "copy()",
      "C": "duplicate()",
      "D": "replicate()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 clone() 方法创建对象的副本，需要类实现 Cloneable 接口。"
  },
  {
    "id": 681,
    "type": "single",
    "category": "数据序列化",
    "difficulty": "中等",
    "question": "仓颉语言中对象序列化的接口是？",
    "options": {
      "A": "Serializable",
      "B": "Serialize",
      "C": "Encodable",
      "D": "Convertible"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中实现 Serializable 接口的类的对象可以被序列化。"
  },
  {
    "id": 682,
    "type": "single",
    "category": "数据序列化",
    "difficulty": "中等",
    "question": "仓颉语言中阻止字段序列化的关键字是？",
    "options": {
      "A": "transient",
      "B": "nonSerializable",
      "C": "noSerialize",
      "D": "ignore"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 transient 关键字标记的字段不会被序列化。"
  },
  {
    "id": 683,
    "type": "single",
    "category": "数据序列化",
    "difficulty": "困难",
    "question": "仓颉语言中JSON反序列化的方法是？",
    "options": {
      "A": "fromJson(json, type)",
      "B": "parseJson(json, type)",
      "C": "decodeJson(json, type)",
      "D": "deserializeJson(json, type)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 fromJson(json, 类型) 方法将JSON字符串反序列化为指定类型的对象。"
  },
  {
    "id": 684,
    "type": "single",
    "category": "数据序列化",
    "difficulty": "困难",
    "question": "仓颉语言中二进制序列化的类是？",
    "options": {
      "A": "BinarySerializer",
      "B": "ObjectSerializer",
      "C": "BinaryEncoder",
      "D": "DataSerializer"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 BinarySerializer 类用于将对象序列化为二进制数据。"
  },
  {
    "id": 685,
    "type": "single",
    "category": "数据序列化",
    "difficulty": "困难",
    "question": "仓颉语言中序列化版本号的属性是？",
    "options": {
      "A": "serialVersionUID",
      "B": "serialVersion",
      "C": "versionId",
      "D": "serializeId"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 serialVersionUID 属性指定类的序列化版本号，确保序列化和反序列化的兼容性。"
  },
  {
    "id": 686,
    "type": "single",
    "category": "测试框架",
    "difficulty": "中等",
    "question": "仓颉语言中单元测试的注解是？",
    "options": {
      "A": "@Test",
      "B": "@TestCase",
      "C": "@UnitTest",
      "D": "@TestFunction"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 @Test 注解标记单元测试方法。"
  },
  {
    "id": 687,
    "type": "single",
    "category": "测试框架",
    "difficulty": "中等",
    "question": "仓颉语言中断言相等的方法是？",
    "options": {
      "A": "assertEquals(a, b)",
      "B": "assertEqual(a, b)",
      "C": "assert(a == b)",
      "D": "checkEquals(a, b)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中测试框架提供的 assertEquals(a, b) 方法用于断言两个值相等。"
  },
  {
    "id": 688,
    "type": "single",
    "category": "测试框架",
    "difficulty": "困难",
    "question": "仓颉语言中测试前执行的注解是？",
    "options": {
      "A": "@Before",
      "B": "@BeforeTest",
      "C": "@Setup",
      "D": "@Prepare"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 @Before 注解标记的方法在每个测试方法执行前运行，用于准备测试环境。"
  },
  {
    "id": 689,
    "type": "single",
    "category": "测试框架",
    "difficulty": "困难",
    "question": "仓颉语言中测试后执行的注解是？",
    "options": {
      "A": "@After",
      "B": "@AfterTest",
      "C": "@Teardown",
      "D": "@Cleanup"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 @After 注解标记的方法在每个测试方法执行后运行，用于清理测试环境。"
  },
  {
    "id": 690,
    "type": "single",
    "category": "测试框架",
    "difficulty": "困难",
    "question": "仓颉语言中忽略测试的注解是？",
    "options": {
      "A": "@Ignore",
      "B": "@Skip",
      "C": "@Exclude",
      "D": "@Disable"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 @Ignore 注解标记的测试方法会被测试框架忽略，不执行。"
  },
  {
    "id": 691,
    "type": "single",
    "category": "反射进阶",
    "difficulty": "困难",
    "question": "仓颉语言中通过反射获取类方法的方法是？",
    "options": {
      "A": "getMethods()",
      "B": "getFunctions()",
      "C": "getMethodsInfo()",
      "D": "findMethods()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 Mirror 类的 getMethods() 方法获取类的所有方法信息。"
  },
  {
    "id": 692,
    "type": "single",
    "category": "反射进阶",
    "difficulty": "困难",
    "question": "仓颉语言中通过反射调用方法的方法是？",
    "options": {
      "A": "invoke()",
      "B": "call()",
      "C": "execute()",
      "D": "run()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中反射获取的方法对象通过 invoke() 方法调用，传递实例和参数。"
  },
  {
    "id": 693,
    "type": "single",
    "category": "反射进阶",
    "difficulty": "困难",
    "question": "仓颉语言中通过反射获取字段值的方法是？",
    "options": {
      "A": "get()",
      "B": "getValue()",
      "C": "fetch()",
      "D": "retrieve()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中反射获取的字段对象通过 get(实例) 方法获取指定实例的字段值。"
  },
  {
    "id": 694,
    "type": "single",
    "category": "反射进阶",
    "difficulty": "困难",
    "question": "仓颉语言中通过反射设置字段值的方法是？",
    "options": {
      "A": "set()",
      "B": "setValue()",
      "C": "assign()",
      "D": "update()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中反射获取的字段对象通过 set(实例, 值) 方法设置指定实例的字段值。"
  },
  {
    "id": 695,
    "type": "single",
    "category": "反射进阶",
    "difficulty": "困难",
    "question": "仓颉语言中获取类的 Mirror 对象的方法是？",
    "options": {
      "A": "Mirror.of(class)",
      "B": "class.getMirror()",
      "C": "new Mirror(class)",
      "D": "Mirror.forClass(class)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 Mirror.of(类对象) 方法获取该类的 Mirror 反射对象。"
  },
  {
    "id": 696,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "仓颉语言中减少自动装箱的方法是？",
    "options": {
      "A": "使用基本数据类型",
      "B": "使用包装类",
      "C": "频繁装箱拆箱",
      "D": "使用泛型"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中基本数据类型（如 int）不会发生装箱操作，使用基本类型可减少自动装箱带来的性能开销。"
  },
  {
    "id": 697,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "仓颉语言中字符串拼接的高效方式是？",
    "options": {
      "A": "使用 StringBuilder",
      "B": "使用 + 运算符",
      "C": "使用 concat() 方法",
      "D": "使用 join() 方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "频繁进行字符串拼接时，仓颉语言中使用 StringBuilder 比 + 运算符更高效，减少中间字符串对象的创建。"
  },
  {
    "id": 698,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "仓颉语言中集合遍历的高效方式是？",
    "options": {
      "A": "for-each 循环",
      "B": "迭代器遍历",
      "C": "索引遍历",
      "D": "forEach() 方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 for-each 循环对集合遍历进行了优化，通常比其他方式更高效且代码简洁。"
  },
  {
    "id": 699,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "仓颉语言中缓存常用对象的方式是？",
    "options": {
      "A": "使用缓存容器",
      "B": "每次使用时创建",
      "C": "使用弱引用",
      "D": "频繁垃圾回收"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中对于频繁使用的对象，使用缓存容器（如 Cache 类）存储可减少对象创建和销毁的开销。"
  },
  {
    "id": 700,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "仓颉语言中避免内存泄漏的方法是？",
    "options": {
      "A": "及时释放无用引用",
      "B": "使用强引用存储临时对象",
      "C": "创建大量静态集合",
      "D": "忽略对象生命周期"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中及时释放不再使用的对象引用（如从集合中移除），可避免垃圾回收器无法回收这些对象导致的内存泄漏。"
  },
  {
    "id": 701,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于声明变量的关键字是？",
    "options": {
      "A": "var",
      "B": "let",
      "C": "val",
      "D": "def"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 var 关键字声明变量。"
  },
  {
    "id": 702,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的循环语句？",
    "options": {
      "A": "for",
      "B": "while",
      "C": "do-while",
      "D": "loop"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持 for、while 和 do-while 循环，没有 loop 关键字。"
  },
  {
    "id": 703,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中安全类型转换的运算符是？",
    "options": {
      "A": "as?",
      "B": "as",
      "C": "cast",
      "D": "convert"
    },
    "answer": [
      "A"
    ],
    "explanation": "as? 运算符用于安全类型转换，转换失败返回 null。"
  },
  {
    "id": 704,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中哪些运算符可以重载？",
    "options": {
      "A": "算术运算符",
      "B": "比较运算符",
      "C": "索引运算符",
      "D": "调用运算符"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持多种运算符重载，包括算术、比较、索引和调用运算符。"
  },
  {
    "id": 705,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示双精度浮点数的类型是？",
    "options": {
      "A": "Double",
      "B": "Float",
      "C": "Decimal",
      "D": "Number"
    },
    "answer": [
      "A"
    ],
    "explanation": "Double 表示双精度浮点数。"
  },
  {
    "id": 706,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的终端操作？",
    "options": {
      "A": "toList()",
      "B": "forEach()",
      "C": "count()",
      "D": "map()"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "toList()、forEach() 和 count() 是终端操作，map() 是中间操作。"
  },
  {
    "id": 707,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示无符号整数的前缀是？",
    "options": {
      "A": "U",
      "B": "Unsigned",
      "C": "u",
      "D": "unsigned"
    },
    "answer": [
      "A"
    ],
    "explanation": "U 前缀表示无符号整数，如 UInt、ULong。"
  },
  {
    "id": 708,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是泛型约束的方式？",
    "options": {
      "A": "上界约束",
      "B": "多个约束",
      "C": "where子句",
      "D": "下界约束"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持上界约束、多个约束和 where 子句，不支持下界约束。"
  },
  {
    "id": 709,
    "type": "single",
    "category": "函数编程",
    "difficulty": "简单",
    "question": "仓颉语言中定义函数的关键字是？",
    "options": {
      "A": "function",
      "B": "func",
      "C": "def",
      "D": "fn"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 function 关键字定义函数。"
  },
  {
    "id": 710,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是函数式编程的特性？",
    "options": {
      "A": "高阶函数",
      "B": "不可变性",
      "C": "纯函数",
      "D": "副作用管理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些特性都是函数式编程的核心概念。"
  },
  {
    "id": 711,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中尾递归优化的关键字是？",
    "options": {
      "A": "tailrec",
      "B": "inline",
      "C": "recursive",
      "D": "optimize"
    },
    "answer": [
      "A"
    ],
    "explanation": "tailrec 关键字用于标记尾递归函数以进行优化。"
  },
  {
    "id": 712,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是Lambda表达式的特性？",
    "options": {
      "A": "简洁语法",
      "B": "类型推断",
      "C": "访问外部变量",
      "D": "支持函数式接口"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Lambda表达式具有简洁语法、类型推断、访问外部变量和支持函数式接口等特性。"
  },
  {
    "id": 713,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中定义类的关键字是？",
    "options": {
      "A": "class",
      "B": "struct",
      "C": "object",
      "D": "type"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 class 关键字定义类。"
  },
  {
    "id": 714,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些访问修饰符是有效的？",
    "options": {
      "A": "public",
      "B": "private",
      "C": "internal",
      "D": "protected"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持 public、private 和 internal 访问修饰符，没有 protected。"
  },
  {
    "id": 715,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中伴生对象的访问方式是？",
    "options": {
      "A": "ClassName",
      "B": "ClassName.Companion",
      "C": "Companion",
      "D": "static"
    },
    "answer": [
      "A"
    ],
    "explanation": "伴生对象的成员可以直接通过类名访问。"
  },
  {
    "id": 716,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是数据类的自动生成方法？",
    "options": {
      "A": "equals()",
      "B": "hashCode()",
      "C": "toString()",
      "D": "copy()"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据类自动生成 equals()、hashCode()、toString() 和 copy() 方法。"
  },
  {
    "id": 717,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中创建协程的关键字是？",
    "options": {
      "A": "spawn",
      "B": "async",
      "C": "launch",
      "D": "go"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 spawn 关键字创建协程。"
  },
  {
    "id": 718,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是协程调度器？",
    "options": {
      "A": "Dispatchers.IO",
      "B": "Dispatchers.Main",
      "C": "Dispatchers.Default",
      "D": "Dispatchers.Unconfined"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些是仓颉语言中协程的常用调度器。"
  },
  {
    "id": 719,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于异步计算的函数是？",
    "options": {
      "A": "async",
      "B": "launch",
      "C": "spawn",
      "D": "future"
    },
    "answer": [
      "A"
    ],
    "explanation": "async 函数用于启动返回 Deferred 结果的异步计算。"
  },
  {
    "id": 720,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是结构化并发的优势？",
    "options": {
      "A": "自动取消传播",
      "B": "避免协程泄漏",
      "C": "简化错误处理",
      "D": "提高性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "结构化并发提供自动取消传播、避免协程泄漏和简化错误处理。"
  },
  {
    "id": 721,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言采用的内存管理方式是？",
    "options": {
      "A": "自动垃圾回收",
      "B": "手动内存管理",
      "C": "引用计数",
      "D": "所有权系统"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用自动垃圾回收机制管理内存。"
  },
  {
    "id": 722,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些引用类型不会阻止垃圾回收？",
    "options": {
      "A": "软引用",
      "B": "弱引用",
      "C": "幻象引用",
      "D": "强引用"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "软引用、弱引用和幻象引用不会阻止垃圾回收，只有强引用会。"
  },
  {
    "id": 723,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中软引用的主要用途是？",
    "options": {
      "A": "缓存实现",
      "B": "避免循环引用",
      "C": "提高访问速度",
      "D": "减少内存占用"
    },
    "answer": [
      "A"
    ],
    "explanation": "软引用常用于缓存实现，在内存不足时会被回收。"
  },
  {
    "id": 724,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是内存优化的策略？",
    "options": {
      "A": "使用基本类型数组",
      "B": "避免装箱操作",
      "C": "使用对象池",
      "D": "减少对象创建"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些策略都可以帮助优化内存使用。"
  },
  {
    "id": 725,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于数学计算的类库是？",
    "options": {
      "A": "Math",
      "B": "Arithmetic",
      "C": "Calculate",
      "D": "Number"
    },
    "answer": [
      "A"
    ],
    "explanation": "Math 类库提供数学计算函数。"
  },
  {
    "id": 726,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的高阶函数？",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "reduce",
      "D": "groupBy"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些函数都是集合操作的高阶函数。"
  },
  {
    "id": 727,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中用于正则表达式匹配的类是？",
    "options": {
      "A": "Regex",
      "B": "Pattern",
      "C": "RegExp",
      "D": "Matcher"
    },
    "answer": [
      "A"
    ],
    "explanation": "Regex 类用于正则表达式匹配。"
  },
  {
    "id": 728,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是序列操作的优化策略？",
    "options": {
      "A": "流水线操作",
      "B": "惰性求值",
      "C": "中间结果缓存",
      "D": "并行处理"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "流水线操作和惰性求值是序列操作的主要优化策略。"
  },
  {
    "id": 729,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中定义注解的关键字是？",
    "options": {
      "A": "annotation class",
      "B": "@annotation",
      "C": "@interface",
      "D": "annotation"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 annotation class 定义注解。"
  },
  {
    "id": 730,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是反射API的用途？",
    "options": {
      "A": "运行时获取类信息",
      "B": "动态创建对象",
      "C": "调用私有方法",
      "D": "代码生成"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "反射用于运行时获取类信息、动态创建对象和调用方法。"
  },
  {
    "id": 731,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中类型投影的关键字是？",
    "options": {
      "A": "out",
      "B": "in",
      "C": "projected",
      "D": "variant"
    },
    "answer": [
      "A"
    ],
    "explanation": "out 关键字用于协变类型投影。"
  },
  {
    "id": 732,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是DSL构建的特性？",
    "options": {
      "A": "中缀函数",
      "B": "运算符重载",
      "C": "扩展函数",
      "D": "带接收者的Lambda"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些特性都支持领域特定语言(DSL)的构建。"
  },
  {
    "id": 733,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于单行注释的符号是？",
    "options": {
      "A": "//",
      "B": "#",
      "C": "--",
      "D": "/*"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 // 进行单行注释。"
  },
  {
    "id": 734,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的字符串模板功能？",
    "options": {
      "A": "变量插值",
      "B": "表达式计算",
      "C": "函数调用",
      "D": "多行字符串"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "字符串模板支持变量插值、表达式计算、函数调用和多行字符串。"
  },
  {
    "id": 735,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示布尔值的类型是？",
    "options": {
      "A": "Boolean",
      "B": "Bool",
      "C": "boolean",
      "D": "bit"
    },
    "answer": [
      "A"
    ],
    "explanation": "Boolean 类型表示布尔值 true 或 false。"
  },
  {
    "id": 736,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些集合类型是有序的？",
    "options": {
      "A": "List",
      "B": "Set",
      "C": "Array",
      "D": "Map"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "List 和 Array 是有序集合，Set 是无序集合，Map 是键值对集合。"
  },
  {
    "id": 737,
    "type": "single",
    "category": "函数编程",
    "difficulty": "简单",
    "question": "仓颉语言中Lambda表达式的语法是？",
    "options": {
      "A": "{参数 -> 表达式}",
      "B": "(参数) -> 表达式",
      "C": "参数 => 表达式",
      "D": "函数(参数) = 表达式"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 {参数 -> 表达式} 语法定义Lambda表达式。"
  },
  {
    "id": 738,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是高阶函数的应用场景？",
    "options": {
      "A": "集合处理",
      "B": "回调函数",
      "C": "策略模式",
      "D": "模板方法"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "集合处理、回调和策略模式都适合使用高阶函数。"
  },
  {
    "id": 739,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中实例化对象的方式是？",
    "options": {
      "A": "ClassName()",
      "B": "new ClassName()",
      "C": "ClassName.new()",
      "D": "create ClassName()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言直接使用类名加括号实例化对象，不需要 new 关键字。"
  },
  {
    "id": 740,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是对象表达式的用途？",
    "options": {
      "A": "创建匿名对象",
      "B": "实现接口",
      "C": "扩展类",
      "D": "替代Lambda表达式"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "对象表达式用于创建匿名对象、实现接口和扩展类。"
  },
  {
    "id": 741,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中协程上下文包含的主要元素是？",
    "options": {
      "A": "调度器",
      "B": "作业",
      "C": "异常处理器",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "协程上下文包含调度器、作业、异常处理器等元素。"
  },
  {
    "id": 742,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是原子操作的类型？",
    "options": {
      "A": "AtomicInt",
      "B": "AtomicReference",
      "C": "AtomicBoolean",
      "D": "AtomicLong"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言提供多种原子类型支持原子操作。"
  },
  {
    "id": 743,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中对象分配的主要区域是？",
    "options": {
      "A": "堆",
      "B": "栈",
      "C": "方法区",
      "D": "直接内存"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象主要分配在堆内存中。"
  },
  {
    "id": 744,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是内存泄漏的检测方法？",
    "options": {
      "A": "堆转储分析",
      "B": "内存分析器",
      "C": "引用跟踪",
      "D": "日志分析"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "堆转储分析、内存分析器和引用跟踪是检测内存泄漏的有效方法。"
  },
  {
    "id": 745,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于文件读写的类是？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "FileSystem",
      "D": "IO"
    },
    "answer": [
      "A"
    ],
    "explanation": "File 类用于文件读写操作。"
  },
  {
    "id": 746,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的聚合操作？",
    "options": {
      "A": "sum",
      "B": "average",
      "C": "min",
      "D": "max"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些函数用于计算集合的聚合值。"
  },
  {
    "id": 747,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中定义类型别名的关键字是？",
    "options": {
      "A": "type",
      "B": "alias",
      "C": "typedef",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "type 关键字用于定义类型别名。"
  },
  {
    "id": 748,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是注解处理器的应用场景？",
    "options": {
      "A": "代码生成",
      "B": "编译时验证",
      "C": "依赖注入",
      "D": "运行时优化"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "注解处理器用于代码生成、编译时验证和依赖注入等。"
  },
  {
    "id": 749,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中用于模式匹配的关键字是？",
    "options": {
      "A": "match",
      "B": "switch",
      "C": "case",
      "D": "pattern"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 match 关键字进行模式匹配。"
  },
  {
    "id": 750,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是有效的数字字面量格式？",
    "options": {
      "A": "100_000",
      "B": "0xFF",
      "C": "0b1010",
      "D": "1.5e3"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持使用下划线分隔、十六进制、二进制和科学计数法表示数字。"
  },
  {
    "id": 751,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示任意类型的根类型是？",
    "options": {
      "A": "Any",
      "B": "Object",
      "C": "Root",
      "D": "Base"
    },
    "answer": [
      "A"
    ],
    "explanation": "Any 是所有类型的超类，表示任意类型。"
  },
  {
    "id": 752,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的转换操作？",
    "options": {
      "A": "map",
      "B": "flatMap",
      "C": "asSequence",
      "D": "toSet"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些操作都可以将集合转换为其他形式。"
  },
  {
    "id": 753,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中函数柯里化的实现方式是？",
    "options": {
      "A": "手动创建部分应用函数",
      "B": "自动支持",
      "C": "使用curry关键字",
      "D": "不支持柯里化"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言需要手动创建部分应用函数来实现柯里化效果。"
  },
  {
    "id": 754,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是函数式编程的优势？",
    "options": {
      "A": "代码简洁性",
      "B": "易于测试",
      "C": "更好的并发支持",
      "D": "性能优化"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "函数式编程提供代码简洁、易于测试和更好的并发支持，但不一定带来性能优化。"
  },
  {
    "id": 755,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中定义抽象类的关键字是？",
    "options": {
      "A": "abstract class",
      "B": "virtual class",
      "C": "base class",
      "D": "abstract"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 abstract class 定义抽象类。"
  },
  {
    "id": 756,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是内联类的限制？",
    "options": {
      "A": "只能有一个属性",
      "B": "不能继承其他类",
      "C": "不能是泛型类",
      "D": "不能实现接口"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "内联类只能有一个属性，不能继承其他类，但可以实现接口，也可以是泛型类。"
  },
  {
    "id": 757,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于协程超时设置的函数是？",
    "options": {
      "A": "withTimeout",
      "B": "timeout",
      "C": "setTimeout",
      "D": "withDeadline"
    },
    "answer": [
      "A"
    ],
    "explanation": "withTimeout 函数用于设置协程执行超时。"
  },
  {
    "id": 758,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是响应式流的特性？",
    "options": {
      "A": "背压支持",
      "B": "异步数据流",
      "C": "操作符链式调用",
      "D": "错误处理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "响应式流支持背压、异步数据流、操作符链式调用和错误处理。"
  },
  {
    "id": 759,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中对象生命周期的最后一个阶段是？",
    "options": {
      "A": "终结阶段",
      "B": "可达性分析",
      "C": "回收阶段",
      "D": "清理阶段"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象在垃圾回收前会经历终结阶段，执行清理操作。"
  },
  {
    "id": 760,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是垃圾回收的触发条件？",
    "options": {
      "A": "堆内存不足",
      "B": "系统空闲时",
      "C": "手动调用",
      "D": "对象创建频繁"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "垃圾回收在堆内存不足或系统空闲时触发，不支持手动调用。"
  },
  {
    "id": 761,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中用于网络请求的类是？",
    "options": {
      "A": "HttpClient",
      "B": "Net",
      "C": "Web",
      "D": "Request"
    },
    "answer": [
      "A"
    ],
    "explanation": "HttpClient 类用于进行HTTP网络请求。"
  },
  {
    "id": 762,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是集合的性能优化操作？",
    "options": {
      "A": "使用序列处理大数据",
      "B": "使用数组处理基本类型",
      "C": "使用视图避免复制",
      "D": "使用并行流"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "序列、基本类型数组和视图都可以优化集合操作性能。"
  },
  {
    "id": 763,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中逆变类型投影的关键字是？",
    "options": {
      "A": "in",
      "B": "out",
      "C": "contra",
      "D": "negative"
    },
    "answer": [
      "A"
    ],
    "explanation": "in 关键字用于逆变类型投影。"
  },
  {
    "id": 764,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是编译时代码生成的用途？",
    "options": {
      "A": "减少运行时反射",
      "B": "提高性能",
      "C": "增强类型安全",
      "D": "简化API使用"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "编译时代码生成可以减少运行时反射、提高性能、增强类型安全和简化API使用。"
  },
  {
    "id": 765,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中智能转换的发生条件是？",
    "options": {
      "A": "使用is检查后",
      "B": "在when分支中",
      "C": "编译器能推断类型",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "在这些情况下，仓颉语言会自动进行智能类型转换。"
  },
  {
    "id": 766,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的标识符命名规则？",
    "options": {
      "A": "以字母或下划线开头",
      "B": "可以包含数字",
      "C": "可以使用反引号包围关键字",
      "D": "可以使用特殊字符"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "标识符以字母或下划线开头，可以包含数字，可以使用反引号包围关键字。"
  },
  {
    "id": 767,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中数组的初始化函数是？",
    "options": {
      "A": "arrayOf",
      "B": "Array",
      "C": "new Array",
      "D": "createArray"
    },
    "answer": [
      "A"
    ],
    "explanation": "arrayOf 函数用于初始化数组。"
  },
  {
    "id": 768,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是序列操作的性能优势？",
    "options": {
      "A": "避免中间集合创建",
      "B": "延迟计算",
      "C": "更好的缓存局部性",
      "D": "并行处理"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "序列通过避免中间集合和延迟计算来优化性能。"
  },
  {
    "id": 769,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中函数引用操作符是？",
    "options": {
      "A": "::",
      "B": "->",
      "C": "=>",
      "D": "#"
    },
    "answer": [
      "A"
    ],
    "explanation": ":: 操作符用于函数引用。"
  },
  {
    "id": 770,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是函数组合的方式？",
    "options": {
      "A": ">> 操作符",
      "B": "compose 函数",
      "C": "andThen 函数",
      "D": "pipe 操作符"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持 >> 操作符、compose 和 andThen 函数进行函数组合。"
  },
  {
    "id": 771,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中属性委托的by关键字作用是？",
    "options": {
      "A": "委托属性实现",
      "B": "委托方法调用",
      "C": "委托类实现",
      "D": "委托接口实现"
    },
    "answer": [
      "A"
    ],
    "explanation": "by 关键字用于委托属性的实现。"
  },
  {
    "id": 772,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是密封类的优势？",
    "options": {
      "A": "编译时检查完整性",
      "B": "更好的模式匹配",
      "C": "限制继承层次",
      "D": "提高性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "密封类提供编译时检查、更好的模式匹配和限制继承层次。"
  },
  {
    "id": 773,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中用于协程取消检查的函数是？",
    "options": {
      "A": "ensureActive()",
      "B": "checkCancellation()",
      "C": "validateState()",
      "D": "verifyActive()"
    },
    "answer": [
      "A"
    ],
    "explanation": "ensureActive() 函数用于检查协程是否被取消。"
  },
  {
    "id": 774,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是避免竞态条件的技术？",
    "options": {
      "A": "使用原子变量",
      "B": "使用不可变对象",
      "C": "使用线程局部存储",
      "D": "使用同步块"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些技术都可以帮助避免竞态条件。"
  },
  {
    "id": 775,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中引用队列(ReferenceQueue)的作用是？",
    "options": {
      "A": "跟踪引用对象状态",
      "B": "管理对象生命周期",
      "C": "优化内存分配",
      "D": "提高访问速度"
    },
    "answer": [
      "A"
    ],
    "explanation": "引用队列用于跟踪引用对象的状态变化。"
  },
  {
    "id": 776,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是内存屏障的作用？",
    "options": {
      "A": "保证内存访问顺序",
      "B": "防止指令重排序",
      "C": "提高内存分配速度",
      "D": "优化缓存使用"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "内存屏障保证内存访问顺序和防止指令重排序。"
  },
  {
    "id": 777,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于生成随机数的类是？",
    "options": {
      "A": "Random",
      "B": "Math.random()",
      "C": "Randomizer",
      "D": "Rand"
    },
    "answer": [
      "A"
    ],
    "explanation": "Random 类用于生成随机数。"
  },
  {
    "id": 778,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是日期时间操作的类？",
    "options": {
      "A": "DateTime",
      "B": "Duration",
      "C": "Calendar",
      "D": "Time"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "DateTime 和 Duration 类用于日期时间操作。"
  },
  {
    "id": 779,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中反射API的主要用途是？",
    "options": {
      "A": "运行时类型检查",
      "B": "动态方法调用",
      "C": "注解处理",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "反射API用于运行时类型检查、动态方法调用和注解处理等。"
  },
  {
    "id": 780,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是类型安全的构建器模式要素？",
    "options": {
      "A": "带接收者的函数类型",
      "B": "中缀函数",
      "C": "扩展函数",
      "D": "泛型约束"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些特性共同支持类型安全的构建器模式实现。"
  },
  {
    "id": 781,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于范围迭代的关键字是？",
    "options": {
      "A": "in",
      "B": "for",
      "C": "each",
      "D": "loop"
    },
    "answer": [
      "A"
    ],
    "explanation": "in 关键字用于范围迭代，如 for (i in 1..10)。"
  },
  {
    "id": 782,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的控制流语句？",
    "options": {
      "A": "if-else",
      "B": "when",
      "C": "for",
      "D": "switch"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "if-else、when 和 for 是有效的控制流语句，switch 不是仓颉语言关键字。"
  },
  {
    "id": 783,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示64位整数的类型是？",
    "options": {
      "A": "Long",
      "B": "Int64",
      "C": "BigInteger",
      "D": "Integer"
    },
    "answer": [
      "A"
    ],
    "explanation": "Long 表示64位整数。"
  },
  {
    "id": 784,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些集合类型支持快速随机访问？",
    "options": {
      "A": "ArrayList",
      "B": "LinkedList",
      "C": "Array",
      "D": "HashSet"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "ArrayList 和 Array 支持基于索引的快速随机访问。"
  },
  {
    "id": 785,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中内联函数的主要作用是？",
    "options": {
      "A": "减少函数调用开销",
      "B": "支持递归调用",
      "C": "提高代码可读性",
      "D": "简化函数定义"
    },
    "answer": [
      "A"
    ],
    "explanation": "内联函数通过代码展开减少函数调用开销。"
  },
  {
    "id": 786,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持函数组合？",
    "options": {
      "A": "函数类型",
      "B": "高阶函数",
      "C": "扩展函数",
      "D": "运算符重载"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "函数类型、高阶函数和运算符重载都支持函数组合。"
  },
  {
    "id": 787,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中定义接口的关键字是？",
    "options": {
      "A": "interface",
      "B": "protocol",
      "C": "trait",
      "D": "abstract"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 interface 关键字定义接口。"
  },
  {
    "id": 788,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些类不能被实例化？",
    "options": {
      "A": "抽象类",
      "B": "密封类",
      "C": "数据类",
      "D": "枚举类"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "抽象类和密封类不能被直接实例化。"
  },
  {
    "id": 789,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于线程同步的锁接口是？",
    "options": {
      "A": "Lock",
      "B": "Mutex",
      "C": "Synchronized",
      "D": "Monitor"
    },
    "answer": [
      "A"
    ],
    "explanation": "Lock 接口用于线程同步。"
  },
  {
    "id": 790,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是协程的调度策略？",
    "options": {
      "A": "IO调度",
      "B": "计算调度",
      "C": "主线程调度",
      "D": "无约束调度"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "IO调度、计算调度、主线程调度和无约束调度都是协程调度策略。"
  },
  {
    "id": 791,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中垃圾回收的主要目标是？",
    "options": {
      "A": "回收不再使用的内存",
      "B": "提高程序执行速度",
      "C": "减少内存分配",
      "D": "优化缓存使用"
    },
    "answer": [
      "A"
    ],
    "explanation": "垃圾回收的主要目标是自动回收不再使用的内存。"
  },
  {
    "id": 792,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些技术可以优化内存使用？",
    "options": {
      "A": "对象池",
      "B": "栈上分配",
      "C": "压缩指针",
      "D": "内存映射"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "对象池、栈上分配和压缩指针可以优化内存使用。"
  },
  {
    "id": 793,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于字符串分割的函数是？",
    "options": {
      "A": "split()",
      "B": "divide()",
      "C": "separate()",
      "D": "partition()"
    },
    "answer": [
      "A"
    ],
    "explanation": "split() 函数用于按指定分隔符分割字符串。"
  },
  {
    "id": 794,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是文件操作的类？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "Path",
      "D": "FileSystem"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "File、Files 和 Path 类用于文件操作。"
  },
  {
    "id": 795,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中泛型擦除的含义是？",
    "options": {
      "A": "运行时类型信息丢失",
      "B": "编译时类型检查",
      "C": "类型参数替换",
      "D": "代码优化"
    },
    "answer": [
      "A"
    ],
    "explanation": "泛型擦除指泛型类型信息在运行时不可用。"
  },
  {
    "id": 796,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些特性支持元编程？",
    "options": {
      "A": "注解处理器",
      "B": "反射API",
      "C": "代码生成",
      "D": "宏定义"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "注解处理器、反射API和代码生成支持元编程，仓颉语言不支持宏定义。"
  },
  {
    "id": 797,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于异常处理的关键字是？",
    "options": {
      "A": "try-catch",
      "B": "try-rescue",
      "C": "try-except",
      "D": "try-handle"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 try-catch 进行异常处理。"
  },
  {
    "id": 798,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的循环控制语句？",
    "options": {
      "A": "break",
      "B": "continue",
      "C": "goto",
      "D": "return"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "break 和 continue 是循环控制语句，goto 不是仓颉语言关键字。"
  },
  {
    "id": 799,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中范围类型的表示方式是？",
    "options": {
      "A": "1..10",
      "B": "1 to 10",
      "C": "range(1,10)",
      "D": "1-10"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 .. 操作符表示范围。"
  },
  {
    "id": 800,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些集合操作是惰性的？",
    "options": {
      "A": "Sequence.map",
      "B": "Sequence.filter",
      "C": "List.map",
      "D": "List.filter"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Sequence 的操作是惰性的，List 的操作是急切的。"
  },
  {
    "id": 801,
    "type": "single",
    "category": "UI编程",
    "difficulty": "中等",
    "question": "仓颉语言中按钮点击事件的监听器接口是？",
    "options": {
      "A": "OnClickListener",
      "B": "ClickHandler",
      "C": "ButtonListener",
      "D": "TapReceiver"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过实现 OnClickListener 接口处理按钮点击事件。"
  },
  {
    "id": 802,
    "type": "single",
    "category": "UI编程",
    "difficulty": "中等",
    "question": "仓颉语言中线性布局的类是？",
    "options": {
      "A": "LinearLayout",
      "B": "RowLayout",
      "C": "LinearContainer",
      "D": "FlowLayout"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 LinearLayout 类用于创建线性排列的UI布局。"
  },
  {
    "id": 803,
    "type": "single",
    "category": "UI编程",
    "difficulty": "困难",
    "question": "仓颉语言中更新UI组件的正确线程是？",
    "options": {
      "A": "主线程",
      "B": "子线程",
      "C": "后台线程",
      "D": "任意线程"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中UI组件必须在主线程（UI线程）中更新，否则会抛出异常。"
  },
  {
    "id": 804,
    "type": "single",
    "category": "UI编程",
    "difficulty": "困难",
    "question": "仓颉语言中布局文件的默认存放目录是？",
    "options": {
      "A": "res/layout",
      "B": "ui/layouts",
      "C": "resources/ui",
      "D": "views"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中UI布局文件默认存放在 res/layout 目录下。"
  },
  {
    "id": 805,
    "type": "single",
    "category": "UI编程",
    "difficulty": "中等",
    "question": "仓颉语言中获取UI控件的方法是？",
    "options": {
      "A": "findView(id)",
      "B": "getView(id)",
      "C": "lookupView(id)",
      "D": "findControl(id)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 findView(id) 方法根据ID获取UI控件实例。"
  },
  {
    "id": 806,
    "type": "single",
    "category": "多线程",
    "difficulty": "中等",
    "question": "仓颉语言中创建线程的类是？",
    "options": {
      "A": "Thread",
      "B": "Task",
      "C": "Worker",
      "D": "Runnable"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 Thread 类创建和管理线程。"
  },
  {
    "id": 807,
    "type": "single",
    "category": "多线程",
    "difficulty": "中等",
    "question": "仓颉语言中线程启动的方法是？",
    "options": {
      "A": "start()",
      "B": "run()",
      "C": "execute()",
      "D": "begin()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中线程对象通过 start() 方法启动，会自动调用 run() 方法。"
  },
  {
    "id": 808,
    "type": "single",
    "category": "多线程",
    "difficulty": "困难",
    "question": "仓颉语言中线程同步的关键字是？",
    "options": {
      "A": "synchronized",
      "B": "lock",
      "C": "sync",
      "D": "atomic"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 synchronized 关键字实现线程同步，确保临界区代码的原子性。"
  },
  {
    "id": 809,
    "type": "single",
    "category": "多线程",
    "difficulty": "困难",
    "question": "仓颉语言中线程池的核心类是？",
    "options": {
      "A": "ThreadPool",
      "B": "Executor",
      "C": "TaskPool",
      "D": "WorkerPool"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 ThreadPool 类用于创建和管理线程池，提高线程复用效率。"
  },
  {
    "id": 810,
    "type": "single",
    "category": "多线程",
    "difficulty": "困难",
    "question": "仓颉语言中线程等待的方法是？",
    "options": {
      "A": "wait()",
      "B": "sleep()",
      "C": "pause()",
      "D": "hold()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中线程的 wait() 方法使当前线程进入等待状态，需通过 notify() 唤醒。"
  },
  {
    "id": 811,
    "type": "single",
    "category": "安全编程",
    "difficulty": "中等",
    "question": "仓颉语言中MD5加密的类是？",
    "options": {
      "A": "MD5Encoder",
      "B": "MD5Hash",
      "C": "MessageDigest",
      "D": "CryptoMD5"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言中通过 MessageDigest 类实现MD5加密，需指定算法为\"MD5\"。"
  },
  {
    "id": 812,
    "type": "single",
    "category": "安全编程",
    "difficulty": "中等",
    "question": "仓颉语言中防止XSS攻击的方法是？",
    "options": {
      "A": "输入过滤",
      "B": "加密传输",
      "C": "使用HTTPS",
      "D": "数据库加密"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中防止XSS攻击的核心是对用户输入进行过滤和转义。"
  },
  {
    "id": 813,
    "type": "single",
    "category": "安全编程",
    "difficulty": "困难",
    "question": "仓颉语言中AES加密的模式通常选择？",
    "options": {
      "A": "AES/CBC/PKCS5Padding",
      "B": "AES/ECB/NoPadding",
      "C": "AES/OFB/ZeroPadding",
      "D": "AES/CTR/ISO10126Padding"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中AES加密推荐使用CBC模式配合PKCS5Padding填充，安全性较高。"
  },
  {
    "id": 814,
    "type": "single",
    "category": "安全编程",
    "difficulty": "困难",
    "question": "仓颉语言中验证用户密码的正确方式是？",
    "options": {
      "A": "比较哈希值",
      "B": "明文比较",
      "C": "加密后比较",
      "D": "base64编码后比较"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中应存储密码的哈希值（带盐），验证时比较输入密码的哈希值与存储值。"
  },
  {
    "id": 815,
    "type": "single",
    "category": "安全编程",
    "difficulty": "中等",
    "question": "仓颉语言中HTTPS通信的类是？",
    "options": {
      "A": "HttpsClient",
      "B": "SecureHttpClient",
      "C": "TlsClient",
      "D": "SslHttpClient"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 HttpsClient 类用于建立HTTPS安全连接进行通信。"
  },
  {
    "id": 816,
    "type": "single",
    "category": "正则表达式",
    "difficulty": "中等",
    "question": "仓颉语言中创建正则表达式的类是？",
    "options": {
      "A": "Regex",
      "B": "Pattern",
      "C": "RegularExpression",
      "D": "RegExp"
    },
    "answer": [
      "B"
    ],
    "explanation": "仓颉语言中通过 Pattern 类编译正则表达式模式。"
  },
  {
    "id": 817,
    "type": "single",
    "category": "正则表达式",
    "difficulty": "中等",
    "question": "仓颉语言中匹配正则表达式的方法是？",
    "options": {
      "A": "matches()",
      "B": "find()",
      "C": "test()",
      "D": "check()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Matcher 类的 matches() 方法判断整个字符串是否匹配正则表达式。"
  },
  {
    "id": 818,
    "type": "single",
    "category": "正则表达式",
    "difficulty": "困难",
    "question": "仓颉语言中提取正则匹配组的方法是？",
    "options": {
      "A": "group(index)",
      "B": "getGroup(index)",
      "C": "matchGroup(index)",
      "D": "extractGroup(index)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Matcher 类的 group(index) 方法提取第index个匹配组的内容。"
  },
  {
    "id": 819,
    "type": "single",
    "category": "正则表达式",
    "difficulty": "困难",
    "question": "仓颉语言中正则替换的方法是？",
    "options": {
      "A": "replaceAll(replacement)",
      "B": "replace(regex, replacement)",
      "C": "substituteAll(regex, replacement)",
      "D": "replaceEach(regex, replacement)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Matcher 类的 replaceAll(replacement) 方法替换所有匹配的子串。"
  },
  {
    "id": 820,
    "type": "single",
    "category": "正则表达式",
    "difficulty": "中等",
    "question": "仓颉语言中表示任意字符的正则元字符是？",
    "options": {
      "A": ".",
      "B": "*",
      "C": "?",
      "D": "%"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中正则表达式中，.（点）表示匹配任意单个字符（除换行符）。"
  },
  {
    "id": 821,
    "type": "single",
    "category": "函数式编程",
    "difficulty": "中等",
    "question": "仓颉语言中函数式接口的注解是？",
    "options": {
      "A": "@FunctionalInterface",
      "B": "@FunctionInterface",
      "C": "@Functional",
      "D": "@LambdaInterface"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 @FunctionalInterface 注解标记仅包含一个抽象方法的函数式接口。"
  },
  {
    "id": 822,
    "type": "single",
    "category": "函数式编程",
    "difficulty": "中等",
    "question": "仓颉语言中消费型函数接口是？",
    "options": {
      "A": "Consumer",
      "B": "Function",
      "C": "Supplier",
      "D": "Predicate"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Consumer 接口表示接受一个输入参数且无返回值的操作。"
  },
  {
    "id": 823,
    "type": "single",
    "category": "函数式编程",
    "difficulty": "困难",
    "question": "仓颉语言中Stream的过滤方法是？",
    "options": {
      "A": "filter()",
      "B": "select()",
      "C": "where()",
      "D": "match()",
      "E": "A和C"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中Stream的 filter() 方法用于根据条件过滤元素，接收Predicate参数。"
  },
  {
    "id": 824,
    "type": "single",
    "category": "函数式编程",
    "difficulty": "困难",
    "question": "仓颉语言中Stream的映射方法是？",
    "options": {
      "A": "map()",
      "B": "transform()",
      "C": "convert()",
      "D": "cast()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中Stream的 map() 方法用于将元素转换为另一种类型，接收Function参数。"
  },
  {
    "id": 825,
    "type": "single",
    "category": "函数式编程",
    "difficulty": "困难",
    "question": "仓颉语言中Stream的终端操作方法是？",
    "options": {
      "A": "collect()",
      "B": "map()",
      "C": "filter()",
      "D": "flatMap()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 collect() 是Stream的终端操作，会触发流的处理并返回结果。"
  },
  {
    "id": 826,
    "type": "single",
    "category": "元编程",
    "difficulty": "困难",
    "question": "仓颉语言中编译时注解处理器的基类是？",
    "options": {
      "A": "AbstractProcessor",
      "B": "AnnotationProcessor",
      "C": "CompileProcessor",
      "D": "MetaProcessor"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中开发编译时注解处理器需继承 AbstractProcessor 类。"
  },
  {
    "id": 827,
    "type": "single",
    "category": "元编程",
    "difficulty": "困难",
    "question": "仓颉语言中动态生成类的API是？",
    "options": {
      "A": "ClassGenerator",
      "B": "DynamicClass",
      "C": "ClassBuilder",
      "D": "MetaClass"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 ClassGenerator API 在运行时动态生成类的字节码。"
  },
  {
    "id": 828,
    "type": "single",
    "category": "元编程",
    "difficulty": "困难",
    "question": "仓颉语言中获取类注解的反射方法是？",
    "options": {
      "A": "getAnnotations()",
      "B": "getClassAnnotations()",
      "C": "findAnnotations()",
      "D": "getDeclaredAnnotations()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 Class 对象的 getAnnotations() 方法获取类上的所有注解。"
  },
  {
    "id": 829,
    "type": "single",
    "category": "元编程",
    "difficulty": "困难",
    "question": "仓颉语言中方法参数名的获取方式是？",
    "options": {
      "A": "通过反射+编译参数",
      "B": "直接通过getName()",
      "C": "通过参数索引获取",
      "D": "无法获取"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中默认不保留方法参数名，需通过 -parameters 编译参数并结合反射获取。"
  },
  {
    "id": 830,
    "type": "single",
    "category": "元编程",
    "difficulty": "困难",
    "question": "仓颉语言中代理类的创建类是？",
    "options": {
      "A": "Proxy",
      "B": "Delegate",
      "C": "Agent",
      "D": "Surrogate"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 Proxy 类用于创建动态代理对象，实现接口的代理功能。"
  },
  {
    "id": 831,
    "type": "single",
    "category": "跨平台开发",
    "difficulty": "中等",
    "question": "仓颉语言中获取操作系统类型的方法是？",
    "options": {
      "A": "System.os.name",
      "B": "Environment.getOS()",
      "C": "Platform.type",
      "D": "OSInfo.current"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 System.os.name 属性获取当前操作系统名称。"
  },
  {
    "id": 832,
    "type": "single",
    "category": "跨平台开发",
    "difficulty": "中等",
    "question": "仓颉语言中获取文件系统分隔符的方法是？",
    "options": {
      "A": "File.separator",
      "B": "Path.delimiter",
      "C": "FileSystem.sep",
      "D": "Dir.splitChar"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 File.separator 常量表示当前平台的文件系统分隔符。"
  },
  {
    "id": 833,
    "type": "single",
    "category": "跨平台开发",
    "difficulty": "困难",
    "question": "仓颉语言中处理平台特定代码的注解是？",
    "options": {
      "A": "@PlatformSpecific",
      "B": "@OSDependent",
      "C": "@Conditional",
      "D": "@Platform"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言中 @Conditional 注解结合条件判断处理平台特定代码的编译或运行。"
  },
  {
    "id": 834,
    "type": "single",
    "category": "跨平台开发",
    "difficulty": "困难",
    "question": "仓颉语言中跨平台UI框架的核心类是？",
    "options": {
      "A": "CrossPlatformUI",
      "B": "UniversalUI",
      "C": "MultiPlatformView",
      "D": "PlatformIndependentUI"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 CrossPlatformUI 类是跨平台UI框架的核心，提供统一的UI操作接口。"
  },
  {
    "id": 835,
    "type": "single",
    "category": "跨平台开发",
    "difficulty": "中等",
    "question": "仓颉语言中获取系统环境变量的方法是？",
    "options": {
      "A": "System.getEnv(name)",
      "B": "Environment.getVariable(name)",
      "C": "OS.getEnv(name)",
      "D": "Env.get(name)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过 System.getEnv(name) 方法获取指定名称的系统环境变量。"
  },
  {
    "id": 836,
    "type": "single",
    "category": "调试技巧",
    "difficulty": "中等",
    "question": "仓颉语言中设置断点的注解是？",
    "options": {
      "A": "@Breakpoint",
      "B": "@Debug",
      "C": "@Stop",
      "D": "@Pause"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中 @Breakpoint 注解可在指定位置设置程序断点，用于调试。"
  },
  {
    "id": 837,
    "type": "single",
    "category": "调试技巧",
    "difficulty": "中等",
    "question": "仓颉语言中打印调用栈的方法是？",
    "options": {
      "A": "Thread.dumpStack()",
      "B": "Exception.printStackTrace()",
      "C": "Debug.printStack()",
      "D": "A和B"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中 Thread.dumpStack() 和 Exception.printStackTrace() 均可打印调用栈信息。"
  },
  {
    "id": 838,
    "type": "single",
    "category": "调试技巧",
    "difficulty": "困难",
    "question": "仓颉语言中条件断点的设置方式是？",
    "options": {
      "A": "指定布尔表达式",
      "B": "使用if语句包裹",
      "C": "通过注解参数",
      "D": "无法设置条件断点"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中调试器支持设置条件断点，当指定布尔表达式为true时触发。"
  },
  {
    "id": 839,
    "type": "single",
    "category": "调试技巧",
    "difficulty": "困难",
    "question": "仓颉语言中日志调试的级别不包括？",
    "options": {
      "A": "VERBOSE",
      "B": "DEBUG",
      "C": "NOTICE",
      "D": "ERROR"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言中日志级别通常包括VERBOSE、DEBUG、INFO、WARN、ERROR，不包括NOTICE。"
  },
  {
    "id": 840,
    "type": "single",
    "category": "调试技巧",
    "difficulty": "中等",
    "question": "仓颉语言中查看变量值的调试方法是？",
    "options": {
      "A": "监视表达式",
      "B": "打印到控制台",
      "C": "日志输出",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中调试时可通过监视表达式、打印到控制台或日志输出查看变量值。"
  },
  {
    "id": 841,
    "type": "single",
    "category": "代码规范",
    "difficulty": "简单",
    "question": "仓颉语言中类名的命名规范是？",
    "options": {
      "A": "帕斯卡命名法（首字母大写）",
      "B": "驼峰命名法（首字母小写）",
      "C": "全大写+下划线",
      "D": "全小写+下划线"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中类名通常采用帕斯卡命名法，即每个单词首字母大写，如MyClass。"
  },
  {
    "id": 842,
    "type": "single",
    "category": "代码规范",
    "difficulty": "简单",
    "question": "仓颉语言中方法名的命名规范是？",
    "options": {
      "A": "驼峰命名法（首字母小写）",
      "B": "帕斯卡命名法（首字母大写）",
      "C": "全大写+下划线",
      "D": "全小写+下划线"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中方法名通常采用驼峰命名法，即首个单词首字母小写，后续单词首字母大写，如getUserInfo。"
  },
  {
    "id": 843,
    "type": "single",
    "category": "代码规范",
    "difficulty": "中等",
    "question": "仓颉语言中常量的命名规范是？",
    "options": {
      "A": "全大写+下划线",
      "B": "驼峰命名法",
      "C": "帕斯卡命名法",
      "D": "全小写+下划线"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中常量通常采用全大写字母，单词间用下划线分隔，如MAX_SIZE。"
  },
  {
    "id": 844,
    "type": "single",
    "category": "代码规范",
    "difficulty": "中等",
    "question": "仓颉语言中包名的命名规范是？",
    "options": {
      "A": "全小写+点分隔",
      "B": "驼峰命名法",
      "C": "帕斯卡命名法",
      "D": "全大写+点分隔"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中包名通常采用全小写字母，层级间用点分隔，如com.example.util。"
  },
  {
    "id": 845,
    "type": "single",
    "category": "代码规范",
    "difficulty": "中等",
    "question": "仓颉语言中每行代码的建议长度不超过？",
    "options": {
      "A": "80个字符",
      "B": "100个字符",
      "C": "120个字符",
      "D": "150个字符"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言代码规范建议每行代码长度不超过120个字符，保证可读性。"
  },
  {
    "id": 846,
    "type": "single",
    "category": "设计模式",
    "difficulty": "中等",
    "question": "仓颉语言中单例模式的核心是？",
    "options": {
      "A": "确保唯一实例",
      "B": "继承复用",
      "C": "接口隔离",
      "D": "依赖注入"
    },
    "answer": [
      "A"
    ],
    "explanation": "单例模式的核心是保证一个类仅有一个实例，并提供一个访问它的全局访问点。"
  },
  {
    "id": 847,
    "type": "single",
    "category": "设计模式",
    "difficulty": "中等",
    "question": "仓颉语言中工厂模式的作用是？",
    "options": {
      "A": "封装对象创建过程",
      "B": "实现接口多态",
      "C": "分离对象行为",
      "D": "管理对象生命周期"
    },
    "answer": [
      "A"
    ],
    "explanation": "工厂模式用于封装对象的创建过程，使客户端无需知道具体实现类。"
  },
  {
    "id": 848,
    "type": "single",
    "category": "设计模式",
    "difficulty": "困难",
    "question": "仓颉语言中观察者模式的接口通常包括？",
    "options": {
      "A": "Observable和Observer",
      "B": "Subject和Listener",
      "C": "Event和Handler",
      "D": "Publisher和Subscriber"
    },
    "answer": [
      "A"
    ],
    "explanation": "观察者模式中通常定义Observable（被观察者）和Observer（观察者）接口，实现对象间的通知机制。"
  },
  {
    "id": 849,
    "type": "single",
    "category": "设计模式",
    "difficulty": "困难",
    "question": "仓颉语言中装饰器模式的目的是？",
    "options": {
      "A": "动态添加功能",
      "B": "继承扩展功能",
      "C": "封装复杂逻辑",
      "D": "优化性能"
    },
    "answer": [
      "A"
    ],
    "explanation": "装饰器模式允许在不改变原有对象的基础上，动态地给对象添加额外功能。"
  },
  {
    "id": 850,
    "type": "single",
    "category": "设计模式",
    "difficulty": "困难",
    "question": "仓颉语言中适配器模式的作用是？",
    "options": {
      "A": "兼容不同接口",
      "B": "实现延迟加载",
      "C": "缓存对象实例",
      "D": "简化对象创建"
    },
    "answer": [
      "A"
    ],
    "explanation": "适配器模式用于将一个类的接口转换为客户端期望的另一个接口，解决接口不兼容问题。"
  },
  {
    "id": 851,
    "type": "single",
    "category": "异常处理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中异常链的构建方法是？",
    "options": {
      "A": "在异常构造函数中传入cause",
      "B": "使用setCause()方法",
      "C": "通过throws关键字",
      "D": "A和B"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中可通过异常构造函数传入cause参数或调用setCause()方法构建异常链，保留原始异常信息。"
  },
  {
    "id": 852,
    "type": "single",
    "category": "异常处理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中自定义检查型异常的方式是？",
    "options": {
      "A": "继承Exception类",
      "B": "继承RuntimeException类",
      "C": "实现Exception接口",
      "D": "使用@Checked注解"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中检查型异常需继承Exception类，编译器会强制要求处理该异常。"
  },
  {
    "id": 853,
    "type": "single",
    "category": "异常处理进阶",
    "difficulty": "困难",
    "question": "仓颉语言中异常转换的目的是？",
    "options": {
      "A": "隐藏实现细节",
      "B": "简化异常处理",
      "C": "提高性能",
      "D": "增加异常信息"
    },
    "answer": [
      "A"
    ],
    "explanation": "异常转换将底层异常转换为上层可理解的异常类型，隐藏内部实现细节，同时保留原始异常作为cause。"
  },
  {
    "id": 854,
    "type": "single",
    "category": "异常处理进阶",
    "difficulty": "中等",
    "question": "仓颉语言中try-with-resources的作用是？",
    "options": {
      "A": "自动释放资源",
      "B": "简化异常捕获",
      "C": "提高代码性能",
      "D": "支持多异常处理"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中try-with-resources语句可自动释放实现AutoCloseable接口的资源，无需手动关闭。"
  },
  {
    "id": 855,
    "type": "single",
    "category": "异常处理进阶",
    "difficulty": "中等",
    "question": "仓颉语言中同时捕获多个异常的语法是？",
    "options": {
      "A": "catch (Exception1 | Exception2 e)",
      "B": "catch (Exception1 e, Exception2 e)",
      "C": "catch (Exception1 e) catch (Exception2 e)",
      "D": "catch (Exception1, Exception2 e)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中使用 | 分隔多个异常类型，可在一个catch块中处理多种异常。"
  },
  {
    "id": 856,
    "type": "single",
    "category": "集合框架",
    "difficulty": "中等",
    "question": "仓颉语言中HashSet的底层实现是？",
    "options": {
      "A": "HashMap",
      "B": "Array",
      "C": "LinkedList",
      "D": "TreeMap"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中HashSet基于HashMap实现，元素存储在HashMap的key位置，value为固定对象。"
  },
  {
    "id": 857,
    "type": "single",
    "category": "集合框架",
    "difficulty": "中等",
    "question": "仓颉语言中ArrayList与LinkedList的主要区别是？",
    "options": {
      "A": "底层数据结构不同",
      "B": "是否允许重复元素",
      "C": "是否线程安全",
      "D": "是否有序"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArrayList基于动态数组实现，LinkedList基于双向链表实现，这是两者的核心区别。"
  },
  {
    "id": 858,
    "type": "single",
    "category": "集合框架",
    "difficulty": "困难",
    "question": "仓颉语言中TreeMap的排序依据是？",
    "options": {
      "A": "自然顺序或比较器",
      "B": "插入顺序",
      "C": "哈希值顺序",
      "D": "随机顺序"
    },
    "answer": [
      "A"
    ],
    "explanation": "TreeMap中的元素根据键的自然顺序（实现Comparable）或构造时指定的比较器进行排序。"
  },
  {
    "id": 859,
    "type": "single",
    "category": "集合框架",
    "difficulty": "困难",
    "question": "仓颉语言中ConcurrentHashMap的线程安全机制是？",
    "options": {
      "A": "分段锁",
      "B": "synchronized全表锁",
      "C": "volatile修饰",
      "D": "CAS操作"
    },
    "answer": [
      "A"
    ],
    "explanation": "ConcurrentHashMap通过分段锁机制实现线程安全，不同段可同时被不同线程操作。"
  },
  {
    "id": 860,
    "type": "single",
    "category": "集合框架",
    "difficulty": "中等",
    "question": "仓颉语言中集合转换为数组的方法是？",
    "options": {
      "A": "toArray()",
      "B": "convertToArray()",
      "C": "asArray()",
      "D": "toListArray()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中Collection接口的toArray()方法将集合转换为数组。"
  },
  {
    "id": 861,
    "type": "single",
    "category": "输入输出",
    "difficulty": "中等",
    "question": "仓颉语言中缓冲流的作用是？",
    "options": {
      "A": "提高IO效率",
      "B": "支持随机访问",
      "C": "实现对象序列化",
      "D": "处理网络数据"
    },
    "answer": [
      "A"
    ],
    "explanation": "缓冲流（如BufferedReader）通过内部缓冲区减少IO操作次数，提高读写效率。"
  },
  {
    "id": 862,
    "type": "single",
    "category": "输入输出",
    "difficulty": "中等",
    "question": "仓颉语言中处理二进制数据的流是？",
    "options": {
      "A": "InputStream/OutputStream",
      "B": "Reader/Writer",
      "C": "Buffer/Channel",
      "D": "DataStream"
    },
    "answer": [
      "A"
    ],
    "explanation": "InputStream和OutputStream是处理二进制数据的基础流类。"
  },
  {
    "id": 863,
    "type": "single",
    "category": "输入输出",
    "difficulty": "困难",
    "question": "仓颉语言中NIO的核心组件不包括？",
    "options": {
      "A": "Stream",
      "B": "Channel",
      "C": "Buffer",
      "D": "Selector"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中NIO的核心组件是Channel、Buffer和Selector，Stream是传统IO的组件。"
  },
  {
    "id": 864,
    "type": "single",
    "category": "输入输出",
    "difficulty": "困难",
    "question": "仓颉语言中FileChannel的transferTo方法作用是？",
    "options": {
      "A": "直接传输数据",
      "B": "读取文件内容",
      "C": "写入文件内容",
      "D": "关闭通道"
    },
    "answer": [
      "A"
    ],
    "explanation": "FileChannel的transferTo方法可直接将数据从一个通道传输到另一个通道，效率高。"
  },
  {
    "id": 865,
    "type": "single",
    "category": "输入输出",
    "difficulty": "中等",
    "question": "仓颉语言中字符编码转换的类是？",
    "options": {
      "A": "Charset",
      "B": "Encoding",
      "C": "Codec",
      "D": "CharSetConverter"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中Charset类用于字符编码的表示和转换，如UTF-8、GBK等。"
  },
  {
    "id": 866,
    "type": "single",
    "category": "网络编程进阶",
    "difficulty": "困难",
    "question": "仓颉语言中TCP与UDP的主要区别是？",
    "options": {
      "A": "是否可靠连接",
      "B": "传输速度",
      "C": "数据大小限制",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "TCP是可靠的面向连接协议，UDP是不可靠的无连接协议，两者在可靠性、速度和数据大小限制上均有区别。"
  },
  {
    "id": 867,
    "type": "single",
    "category": "网络编程进阶",
    "difficulty": "困难",
    "question": "仓颉语言中HTTP请求的Content-Type表示？",
    "options": {
      "A": "请求体数据类型",
      "B": "响应数据类型",
      "C": "字符编码",
      "D": "压缩方式"
    },
    "answer": [
      "A"
    ],
    "explanation": "HTTP请求头中的Content-Type字段指定请求体的数据格式类型，如application/json。"
  },
  {
    "id": 868,
    "type": "single",
    "category": "网络编程进阶",
    "difficulty": "中等",
    "question": "仓颉语言中处理Cookie的类是？",
    "options": {
      "A": "CookieManager",
      "B": "CookieHandler",
      "C": "HttpCookie",
      "D": "A和C"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中HttpCookie类表示Cookie，CookieManager类管理Cookie的存储和获取。"
  },
  {
    "id": 869,
    "type": "single",
    "category": "网络编程进阶",
    "difficulty": "中等",
    "question": "仓颉语言中设置HTTP超时的方法是？",
    "options": {
      "A": "setTimeout()",
      "B": "setConnectionTimeout()",
      "C": "setReadTimeout()",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中HTTP客户端可通过setTimeout()、setConnectionTimeout()等方法设置不同阶段的超时时间。"
  },
  {
    "id": 870,
    "type": "single",
    "category": "网络编程进阶",
    "difficulty": "困难",
    "question": "仓颉语言中WebSocket的消息类型不包括？",
    "options": {
      "A": "文本消息",
      "B": "二进制消息",
      "C": "控制消息",
      "D": "流消息"
    },
    "answer": [
      "D"
    ],
    "explanation": "WebSocket支持文本消息、二进制消息和控制消息（如关闭连接），不包括流消息类型。"
  },
  {
    "id": 871,
    "type": "single",
    "category": "数据库进阶",
    "difficulty": "困难",
    "question": "仓颉语言中JDBC连接池的接口是？",
    "options": {
      "A": "DataSource",
      "B": "ConnectionPool",
      "C": "JdbcPool",
      "D": "DbConnectionPool"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中JDBC连接池通过DataSource接口实现，如HikariCP、C3P0等均实现该接口。"
  },
  {
    "id": 872,
    "type": "single",
    "category": "数据库进阶",
    "difficulty": "困难",
    "question": "仓颉语言中预处理语句的类是？",
    "options": {
      "A": "PreparedStatement",
      "B": "PreparedQuery",
      "C": "SqlStatement",
      "D": "ParamStatement"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中PreparedStatement类用于执行带参数的预编译SQL语句，防止SQL注入。"
  },
  {
    "id": 873,
    "type": "single",
    "category": "数据库进阶",
    "difficulty": "中等",
    "question": "仓颉语言中设置预处理语句参数的方法是？",
    "options": {
      "A": "setXxx(index, value)",
      "B": "setParameter(index, value)",
      "C": "addParameter(index, value)",
      "D": "putParameter(index, value)"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中PreparedStatement通过setXxx()方法设置参数，如setInt()、setString()等。"
  },
  {
    "id": 874,
    "type": "single",
    "category": "数据库进阶",
    "difficulty": "中等",
    "question": "仓颉语言中获取查询结果的元数据的方法是？",
    "options": {
      "A": "getMetaData()",
      "B": "getColumnInfo()",
      "C": "getResultInfo()",
      "D": "getTableMetaData()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中ResultSet的getMetaData()方法获取查询结果的元数据（如列名、类型等）。"
  },
  {
    "id": 875,
    "type": "single",
    "category": "数据库进阶",
    "difficulty": "困难",
    "question": "仓颉语言中批量执行SQL的方法是？",
    "options": {
      "A": "addBatch()和executeBatch()",
      "B": "batchAdd()和batchExecute()",
      "C": "addBatchSql()和runBatch()",
      "D": "batch()和execute()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言中通过addBatch()添加SQL语句到批处理，executeBatch()执行批量操作。"
  },
  {
    "id": 876,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中CountDownLatch的作用是？",
    "options": {
      "A": "等待多个线程完成",
      "B": "控制线程执行顺序",
      "C": "实现线程间通信",
      "D": "限制并发数量"
    },
    "answer": [
      "A"
    ],
    "explanation": "CountDownLatch通过计数器等待多个线程完成操作，计数器减为0时唤醒等待线程。"
  },
  {
    "id": 877,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中CyclicBarrier与CountDownLatch的区别是？",
    "options": {
      "A": "是否可重用",
      "B": "是否阻塞线程",
      "C": "是否需要计数器",
      "D": "是否线程安全"
    },
    "answer": [
      "A"
    ],
    "explanation": "CyclicBarrier可通过reset()方法重置计数器重复使用，CountDownLatch的计数器无法重置。"
  },
  {
    "id": 878,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中AtomicReference的作用是？",
    "options": {
      "A": "原子操作对象引用",
      "B": "原子操作基本类型",
      "C": "同步对象访问",
      "D": "实现线程安全集合"
    },
    "answer": [
      "A"
    ],
    "explanation": "AtomicReference提供对象引用的原子操作，如compareAndSet()，确保线程安全。"
  },
  {
    "id": 879,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中线程本地变量的类是？",
    "options": {
      "A": "ThreadLocal",
      "B": "LocalThread",
      "C": "ThreadStorage",
      "D": "LocalStorage"
    },
    "answer": [
      "A"
    ],
    "explanation": "ThreadLocal类用于创建线程本地变量，每个线程拥有独立的变量副本。"
  },
  {
    "id": 880,
    "type": "single",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中Fork/Join框架的核心类是？",
    "options": {
      "A": "ForkJoinPool",
      "B": "ParallelTask",
      "C": "SplitWorker",
      "D": "ConcurrentProcessor"
    },
    "answer": [
      "A"
    ],
    "explanation": "Fork/Join框架的核心是ForkJoinPool，用于实现大任务的拆分（fork）和结果合并（join）。"
  },
  {
    "id": 881,
    "type": "single",
    "category": "内存模型",
    "difficulty": "困难",
    "question": "仓颉语言中volatile关键字的作用是？",
    "options": {
      "A": "保证可见性和有序性",
      "B": "保证原子性",
      "C": "实现线程同步",
      "D": "优化内存访问"
    },
    "answer": [
      "A"
    ],
    "explanation": "volatile关键字确保变量的可见性（线程间可见）和有序性（禁止指令重排），但不保证原子性。"
  },
  {
    "id": 882,
    "type": "single",
    "category": "内存模型",
    "difficulty": "困难",
    "question": "仓颉语言中happens-before原则的作用是？",
    "options": {
      "A": "定义内存可见性规则",
      "B": "保证线程安全",
      "C": "优化代码执行",
      "D": "简化并发编程"
    },
    "answer": [
      "A"
    ],
    "explanation": "happens-before原则定义了操作之间的内存可见性规则，是理解仓颉语言内存模型的基础。"
  },
  {
    "id": 883,
    "type": "single",
    "category": "内存模型",
    "difficulty": "困难",
    "question": "仓颉语言中对象的内存布局不包括？",
    "options": {
      "A": "方法代码",
      "B": "对象头",
      "C": "实例数据",
      "D": "对齐填充"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象的内存布局包括对象头、实例数据和对齐填充，方法代码存储在方法区，不属于对象内存。"
  },
  {
    "id": 884,
    "type": "single",
    "category": "内存模型",
    "difficulty": "困难",
    "question": "仓颉语言中TLAB的作用是？",
    "options": {
      "A": "减少锁竞争",
      "B": "提高垃圾回收效率",
      "C": "优化方法调用",
      "D": "加速类加载"
    },
    "answer": [
      "A"
    ],
    "explanation": "TLAB（Thread Local Allocation Buffer）是线程本地分配缓冲区，减少对象分配时的锁竞争。"
  },
  {
    "id": 885,
    "type": "single",
    "category": "内存模型",
    "difficulty": "中等",
    "question": "仓颉语言中堆内存与栈内存的主要区别是？",
    "options": {
      "A": "存储内容和生命周期",
      "B": "是否线程共享",
      "C": "内存管理方式",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "堆内存存储对象，线程共享，由GC管理；栈内存存储局部变量和方法调用，线程私有，自动释放。"
  },
  {
    "id": 886,
    "type": "single",
    "category": "类加载机制",
    "difficulty": "困难",
    "question": "仓颉语言中类加载的过程不包括？",
    "options": {
      "A": "解析",
      "B": "验证",
      "C": "优化",
      "D": "初始化"
    },
    "answer": [
      "C"
    ],
    "explanation": "类加载过程包括加载、验证、准备、解析和初始化五个阶段，优化不属于标准加载过程。"
  },
  {
    "id": 887,
    "type": "single",
    "category": "类加载机制",
    "difficulty": "困难",
    "question": "仓颉语言中类加载器的类型不包括？",
    "options": {
      "A": "应用类加载器",
      "B": "扩展类加载器",
      "C": "根类加载器",
      "D": "模块类加载器"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中类加载器通常包括根类加载器、扩展类加载器和应用类加载器，模块类加载器不是标准类型。"
  },
  {
    "id": 888,
    "type": "single",
    "category": "类加载机制",
    "difficulty": "困难",
    "question": "仓颉语言中双亲委派模型的作用是？",
    "options": {
      "A": "防止类重复加载",
      "B": "提高加载效率",
      "C": "实现类隔离",
      "D": "简化加载流程"
    },
    "answer": [
      "A"
    ],
    "explanation": "双亲委派模型通过优先让父类加载器加载类，避免同一个类被多个类加载器重复加载。"
  },
  {
    "id": 889,
    "type": "single",
    "category": "类加载机制",
    "difficulty": "中等",
    "question": "仓颉语言中触发类初始化的条件不包括？",
    "options": {
      "A": "访问类的静态变量",
      "B": "调用类的静态方法",
      "C": "使用Class.forName()加载类",
      "D": "通过类名获取Class对象"
    },
    "answer": [
      "D"
    ],
    "explanation": "通过类名.class获取Class对象不会触发类的初始化，其他选项均会触发。"
  },
  {
    "id": 890,
    "type": "single",
    "category": "类加载机制",
    "difficulty": "困难",
    "question": "仓颉语言中自定义类加载器需重写的方法是？",
    "options": {
      "A": "findClass()",
      "B": "loadClass()",
      "C": "defineClass()",
      "D": "resolveClass()"
    },
    "answer": [
      "A"
    ],
    "explanation": "自定义类加载器通常重写findClass()方法实现类的加载，避免破坏双亲委派模型。"
  },
  {
    "id": 891,
    "type": "single",
    "category": "泛型高级",
    "difficulty": "困难",
    "question": "仓颉语言中泛型上限通配符的表示是？",
    "options": {
      "A": "? extends T",
      "B": "? super T",
      "C": "T extends ?",
      "D": "T super ?"
    },
    "answer": [
      "A"
    ],
    "explanation": "? extends T 表示泛型通配符的上限，只能接收T及其子类类型。"
  },
  {
    "id": 892,
    "type": "single",
    "category": "泛型高级",
    "difficulty": "困难",
    "question": "仓颉语言中泛型下限通配符的表示是？",
    "options": {
      "A": "? super T",
      "B": "? extends T",
      "C": "T super ?",
      "D": "T extends ?"
    },
    "answer": [
      "A"
    ],
    "explanation": "? super T 表示泛型通配符的下限，只能接收T及其父类类型。"
  },
  {
    "id": 893,
    "type": "single",
    "category": "泛型高级",
    "difficulty": "困难",
    "question": "仓颉语言中泛型方法与泛型类的区别是？",
    "options": {
      "A": "类型参数的作用范围",
      "B": "是否支持通配符",
      "C": "是否可重载",
      "D": "是否可继承"
    },
    "answer": [
      "A"
    ],
    "explanation": "泛型方法的类型参数仅作用于当前方法，泛型类的类型参数作用于整个类。"
  },
  {
    "id": 894,
    "type": "single",
    "category": "泛型高级",
    "difficulty": "困难",
    "question": "仓颉语言中不能使用泛型的情况是？",
    "options": {
      "A": "创建泛型数组",
      "B": "静态成员使用泛型类型",
      "C": "异常类声明",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "仓颉语言中不能创建泛型数组、静态成员不能使用类的泛型类型、不能声明泛型异常类。"
  },
  {
    "id": 895,
    "type": "single",
    "category": "泛型高级",
    "difficulty": "中等",
    "question": "仓颉语言中获取泛型实际类型的方法是？",
    "options": {
      "A": "通过反射+匿名内部类",
      "B": "直接通过getType()",
      "C": "通过class属性",
      "D": "无法获取"
    },
    "answer": [
      "A"
    ],
    "explanation": "由于类型擦除，需通过反射结合匿名内部类（保留泛型信息）获取实际类型参数。"
  },
  {
    "id": 896,
    "type": "single",
    "category": "注解高级",
    "difficulty": "困难",
    "question": "仓颉语言中注解的属性类型不能是？",
    "options": {
      "A": "注解类型",
      "B": "数组类型",
      "C": "泛型类型",
      "D": "基本类型"
    },
    "answer": [
      "C"
    ],
    "explanation": "仓颉语言中注解的属性类型可以是基本类型、字符串、枚举、注解及以上类型的数组，不能是泛型类型。"
  },
  {
    "id": 897,
    "type": "single",
    "category": "注解高级",
    "difficulty": "困难",
    "question": "仓颉语言中注解处理器的处理阶段是？",
    "options": {
      "A": "编译时",
      "B": "运行时",
      "C": "类加载时",
      "D": "链接时"
    },
    "answer": [
      "A"
    ],
    "explanation": "注解处理器在编译阶段工作，对源代码中的注解进行处理并生成额外代码。"
  },
  {
    "id": 898,
    "type": "single",
    "category": "注解高级",
    "difficulty": "中等",
    "question": "仓颉语言中获取方法注解的反射方法是？",
    "options": {
      "A": "Method.getAnnotations()",
      "B": "Class.getMethodAnnotations()",
      "C": "Method.getDeclaredAnnotations()",
      "D": "A和C"
    },
    "answer": [
      "D"
    ],
    "explanation": "通过Method对象的getAnnotations()和getDeclaredAnnotations()方法可获取方法上的注解。"
  },
  {
    "id": 899,
    "type": "single",
    "category": "注解高级",
    "difficulty": "中等",
    "question": "仓颉语言中注解的默认保留策略是？",
    "options": {
      "A": "CLASS",
      "B": "SOURCE",
      "C": "RUNTIME",
      "D": "PERMANENT"
    },
    "answer": [
      "A"
    ],
    "explanation": "未指定Retention时，注解默认保留到类文件（CLASS），但不保留到运行时。"
  },
  {
    "id": 900,
    "type": "single",
    "category": "注解高级",
    "difficulty": "困难",
    "question": "仓颉语言中重复注解的容器注解作用是？",
    "options": {
      "A": "存储多个重复注解实例",
      "B": "标记注解可重复",
      "C": "限制注解使用次数",
      "D": "增强注解功能"
    },
    "answer": [
      "A"
    ],
    "explanation": "重复注解需要一个容器注解，用于在编译时将多个重复注解实例存储为数组。"
  },
  {
    "id": 901,
    "type": "single",
    "category": "JVM调优",
    "difficulty": "困难",
    "question": "仓颉语言中Serial GC的垃圾回收机制是？",
    "options": {
      "A": "单线程标记-清除-整理",
      "B": "多线程标记-清除",
      "C": "并发标记-清除",
      "D": "分代并发收集"
    },
    "answer": [
      "A"
    ],
    "explanation": "Serial GC是单线程执行垃圾回收的收集器，采用标记-清除-整理算法，适用于单CPU环境的小型应用。"
  },
  {
    "id": 902,
    "type": "single",
    "category": "JVM调优",
    "difficulty": "困难",
    "question": "仓颉语言中新生代和老年代的默认比例是？",
    "options": {
      "A": "1:2",
      "B": "1:3",
      "C": "2:1",
      "D": "3:1"
    },
    "answer": [
      "A"
    ],
    "explanation": "JVM默认将堆内存划分为新生代和老年代，比例为1:2，新生代又分为Eden区和两个Survivor区。"
  },
  {
    "id": 903,
    "type": "single",
    "category": "JVM调优",
    "difficulty": "中等",
    "question": "仓颉语言中设置堆内存大小的参数是？",
    "options": {
      "A": "-Xms和-Xmx",
      "B": "-XX:NewSize和-XX:MaxNewSize",
      "C": "-XX:PermSize和-XX:MaxPermSize",
      "D": "-Xss"
    },
    "answer": [
      "A"
    ],
    "explanation": "-Xms设置初始堆内存大小，-Xmx设置最大堆内存大小，通常建议两者设置为相同值避免频繁调整。"
  },
  {
    "id": 904,
    "type": "single",
    "category": "JVM调优",
    "difficulty": "困难",
    "question": "仓颉语言中判断对象是否可回收的根节点不包括？",
    "options": {
      "A": "虚拟机栈中引用的对象",
      "B": "方法区中类静态属性引用的对象",
      "C": "方法区中常量引用的对象",
      "D": "堆中正在创建的对象"
    },
    "answer": [
      "D"
    ],
    "explanation": "根节点（GC Roots）包括虚拟机栈引用、类静态属性引用、常量引用和本地方法栈引用，堆中创建的对象本身不是根节点。"
  },
  {
    "id": 905,
    "type": "single",
    "category": "JVM调优",
    "difficulty": "中等",
    "question": "仓颉语言中永久代（PermGen）存储的内容不包括？",
    "options": {
      "A": "类的字节码",
      "B": "字符串常量",
      "C": "对象实例",
      "D": "静态变量"
    },
    "answer": [
      "C"
    ],
    "explanation": "永久代用于存储类信息、字符串常量、静态变量等，对象实例存储在堆的新生代和老年代。"
  },
  {
    "id": 906,
    "type": "single",
    "category": "微服务架构",
    "difficulty": "中等",
    "question": "仓颉语言中服务注册与发现的组件是？",
    "options": {
      "A": "ServiceRegistry",
      "B": "ConfigServer",
      "C": "Gateway",
      "D": "CircuitBreaker"
    },
    "answer": [
      "A"
    ],
    "explanation": "ServiceRegistry是微服务架构中负责服务注册与发现的核心组件，管理服务地址和状态。"
  },
  {
    "id": 907,
    "type": "single",
    "category": "微服务架构",
    "difficulty": "中等",
    "question": "仓颉语言中API网关的主要作用是？",
    "options": {
      "A": "路由请求和统一入口",
      "B": "服务注册与发现",
      "C": "配置管理",
      "D": "熔断降级"
    },
    "answer": [
      "A"
    ],
    "explanation": "API网关作为微服务的统一入口，负责请求路由、负载均衡、认证授权等功能。"
  },
  {
    "id": 908,
    "type": "single",
    "category": "微服务架构",
    "difficulty": "困难",
    "question": "仓颉语言中解决分布式事务的模式不包括？",
    "options": {
      "A": "2PC（两阶段提交）",
      "B": "TCC（Try-Confirm-Cancel）",
      "C": "SAGA模式",
      "D": "CAP模式"
    },
    "answer": [
      "D"
    ],
    "explanation": "CAP是分布式系统的特性（一致性、可用性、分区容错性），不是分布式事务解决方案。"
  },
  {
    "id": 909,
    "type": "single",
    "category": "微服务架构",
    "difficulty": "中等",
    "question": "仓颉语言中配置中心的作用是？",
    "options": {
      "A": "集中管理服务配置",
      "B": "处理服务间通信",
      "C": "监控服务健康状态",
      "D": "实现服务熔断"
    },
    "answer": [
      "A"
    ],
    "explanation": "配置中心用于集中管理微服务的配置信息，支持动态配置更新，无需重启服务。"
  },
  {
    "id": 910,
    "type": "single",
    "category": "微服务架构",
    "difficulty": "困难",
    "question": "仓颉语言中服务熔断与降级的区别是？",
    "options": {
      "A": "触发条件不同",
      "B": "目的不同",
      "C": "恢复机制不同",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "熔断由服务调用失败率触发，目的是保护调用方；降级由系统负载触发，目的是保证核心功能，两者恢复机制也不同。"
  },
  {
    "id": 911,
    "type": "single",
    "category": "分布式系统",
    "difficulty": "困难",
    "question": "仓颉语言中一致性哈希算法的主要优势是？",
    "options": {
      "A": "节点变化时影响范围小",
      "B": "计算速度更快",
      "C": "保证数据绝对一致",
      "D": "实现简单"
    },
    "answer": [
      "A"
    ],
    "explanation": "一致性哈希在节点增减时，只有少量数据需要迁移，解决了传统哈希算法大量数据迁移的问题。"
  },
  {
    "id": 912,
    "type": "single",
    "category": "分布式系统",
    "difficulty": "困难",
    "question": "仓颉语言中ZooKeeper的核心功能不包括？",
    "options": {
      "A": "分布式锁",
      "B": "数据分片",
      "C": "服务注册",
      "D": "配置管理"
    },
    "answer": [
      "B"
    ],
    "explanation": "ZooKeeper提供分布式协调服务，包括分布式锁、服务注册、配置管理等，不直接提供数据分片功能。"
  },
  {
    "id": 913,
    "type": "single",
    "category": "分布式系统",
    "difficulty": "中等",
    "question": "仓颉语言中分布式锁的实现方式不包括？",
    "options": {
      "A": "基于数据库",
      "B": "基于缓存",
      "C": "基于消息队列",
      "D": "基于本地变量"
    },
    "answer": [
      "D"
    ],
    "explanation": "本地变量仅在单个进程内有效，无法实现跨进程的分布式锁，其他选项均可作为分布式锁的实现方式。"
  },
  {
    "id": 914,
    "type": "single",
    "category": "分布式系统",
    "difficulty": "困难",
    "question": "仓颉语言中BASE理论的含义是？",
    "options": {
      "A": "基本可用、软状态、最终一致性",
      "B": "强一致性、可用性、分区容错",
      "C": "原子性、一致性、隔离性、持久性",
      "D": "一致性、可用性、可靠性"
    },
    "answer": [
      "A"
    ],
    "explanation": "BASE理论是分布式系统的实践理论，包括基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventually Consistent）。"
  },
  {
    "id": 915,
    "type": "single",
    "category": "分布式系统",
    "difficulty": "中等",
    "question": "仓颉语言中消息队列的主要作用不包括？",
    "options": {
      "A": "异步通信",
      "B": "流量削峰",
      "C": "数据持久化",
      "D": "强一致性保证"
    },
    "answer": [
      "D"
    ],
    "explanation": "消息队列可实现异步通信、流量削峰和数据持久化，但无法保证分布式系统的强一致性。"
  },
  {
    "id": 916,
    "type": "single",
    "category": "Spring框架",
    "difficulty": "中等",
    "question": "仓颉语言中Spring IoC容器的主要功能是？",
    "options": {
      "A": "依赖注入",
      "B": "AOP代理",
      "C": "事务管理",
      "D": "ORM映射"
    },
    "answer": [
      "A"
    ],
    "explanation": "Spring IoC（控制反转）容器的核心功能是依赖注入（DI），管理对象的创建和依赖关系。"
  },
  {
    "id": 917,
    "type": "single",
    "category": "Spring框架",
    "difficulty": "中等",
    "question": "仓颉语言中Spring AOP的通知类型不包括？",
    "options": {
      "A": "Before通知",
      "B": "After通知",
      "C": "Around通知",
      "D": "Loop通知"
    },
    "answer": [
      "D"
    ],
    "explanation": "Spring AOP支持Before（前置）、After（后置）、Around（环绕）、AfterReturning（返回后）和AfterThrowing（异常后）通知，无Loop通知。"
  },
  {
    "id": 918,
    "type": "single",
    "category": "Spring框架",
    "difficulty": "困难",
    "question": "仓颉语言中Spring事务的传播行为REQUIRES_NEW表示？",
    "options": {
      "A": "创建新事务，暂停当前事务",
      "B": "如果有事务则加入，否则创建",
      "C": "必须在已有事务中运行，否则报错",
      "D": "不使用事务"
    },
    "answer": [
      "A"
    ],
    "explanation": "REQUIRES_NEW传播行为会创建一个新事务，如果当前存在事务，则将其暂停，新事务独立运行。"
  },
  {
    "id": 919,
    "type": "single",
    "category": "Spring框架",
    "difficulty": "中等",
    "question": "仓颉语言中Spring Bean的作用域不包括？",
    "options": {
      "A": "singleton",
      "B": "prototype",
      "C": "request",
      "D": "threadlocal"
    },
    "answer": [
      "D"
    ],
    "explanation": "Spring Bean的标准作用域包括singleton、prototype、request、session等，threadlocal不是标准作用域。"
  },
  {
    "id": 920,
    "type": "single",
    "category": "Spring框架",
    "difficulty": "困难",
    "question": "仓颉语言中Spring Boot的自动配置原理基于？",
    "options": {
      "A": "@EnableAutoConfiguration注解",
      "B": "XML配置文件",
      "C": "手动注册Bean",
      "D": "反射动态生成"
    },
    "answer": [
      "A"
    ],
    "explanation": "Spring Boot的自动配置通过@EnableAutoConfiguration注解触发，结合SPI机制加载META-INF/spring.factories中的配置类。"
  },
  {
    "id": 921,
    "type": "single",
    "category": "数据库优化",
    "difficulty": "中等",
    "question": "仓颉语言中数据库索引的主要作用是？",
    "options": {
      "A": "提高查询速度",
      "B": "减少存储空间",
      "C": "加速插入操作",
      "D": "保证数据唯一性"
    },
    "answer": [
      "A"
    ],
    "explanation": "索引通过建立数据的快速查找结构，显著提高查询语句的执行速度，但会增加存储空间并降低插入/更新性能。"
  },
  {
    "id": 922,
    "type": "single",
    "category": "数据库优化",
    "difficulty": "困难",
    "question": "仓颉语言中不适合创建索引的列是？",
    "options": {
      "A": "频繁更新的列",
      "B": "查询条件中常用的列",
      "C": "主键列",
      "D": "外键列"
    },
    "answer": [
      "A"
    ],
    "explanation": "频繁更新的列不适合创建索引，因为索引会随数据更新而重建，增加性能开销。"
  },
  {
    "id": 923,
    "type": "single",
    "category": "数据库优化",
    "difficulty": "中等",
    "question": "仓颉语言中SQL查询优化的方法不包括？",
    "options": {
      "A": "避免使用SELECT *",
      "B": "合理使用索引",
      "C": "增加表中数据量",
      "D": "优化JOIN操作"
    },
    "answer": [
      "C"
    ],
    "explanation": "增加表中数据量会降低查询性能，不是SQL优化方法，其他选项均为有效的优化手段。"
  },
  {
    "id": 924,
    "type": "single",
    "category": "数据库优化",
    "difficulty": "困难",
    "question": "仓颉语言中数据库分表分库的方式不包括？",
    "options": {
      "A": "水平分表",
      "B": "垂直分表",
      "C": "时间分表",
      "D": "逻辑分表"
    },
    "answer": [
      "D"
    ],
    "explanation": "分表分库的常见方式包括水平分表（按行拆分）、垂直分表（按列拆分）和时间分表（按时间维度），逻辑分表不是实际拆分方式。"
  },
  {
    "id": 925,
    "type": "single",
    "category": "数据库优化",
    "difficulty": "中等",
    "question": "仓颉语言中数据库连接池的作用是？",
    "options": {
      "A": "复用连接，减少连接开销",
      "B": "增加并发连接数",
      "C": "提高SQL执行效率",
      "D": "优化查询计划"
    },
    "answer": [
      "A"
    ],
    "explanation": "数据库连接池通过复用已创建的连接，避免频繁创建和关闭连接的开销，提高系统性能。"
  },
  {
    "id": 926,
    "type": "single",
    "category": "前端框架",
    "difficulty": "中等",
    "question": "仓颉语言中Vue的双向数据绑定原理基于？",
    "options": {
      "A": "数据劫持+发布订阅模式",
      "B": "观察者模式",
      "C": "代理模式",
      "D": "装饰器模式"
    },
    "answer": [
      "A"
    ],
    "explanation": "Vue通过Object.defineProperty()劫持数据变化，结合发布-订阅模式实现视图与数据的双向绑定。"
  },
  {
    "id": 927,
    "type": "single",
    "category": "前端框架",
    "difficulty": "中等",
    "question": "仓颉语言中React的虚拟DOM的作用是？",
    "options": {
      "A": "减少真实DOM操作",
      "B": "提高JavaScript执行效率",
      "C": "优化CSS渲染",
      "D": "实现跨浏览器兼容"
    },
    "answer": [
      "A"
    ],
    "explanation": "虚拟DOM是真实DOM的内存映射，通过对比虚拟DOM变化批量更新真实DOM，减少DOM操作次数，提高性能。"
  },
  {
    "id": 928,
    "type": "single",
    "category": "前端框架",
    "difficulty": "困难",
    "question": "仓颉语言中Angular的依赖注入机制作用是？",
    "options": {
      "A": "解耦组件依赖",
      "B": "提高渲染速度",
      "C": "优化代码体积",
      "D": "增强安全性"
    },
    "answer": [
      "A"
    ],
    "explanation": "Angular的依赖注入（DI）机制通过容器管理组件依赖，实现组件间解耦，便于测试和维护。"
  },
  {
    "id": 929,
    "type": "single",
    "category": "前端框架",
    "difficulty": "中等",
    "question": "仓颉语言中前端路由的实现方式不包括？",
    "options": {
      "A": "基于hash",
      "B": "基于history API",
      "C": "基于WebSocket",
      "D": "基于内存路由"
    },
    "answer": [
      "C"
    ],
    "explanation": "前端路由常用实现方式包括hash模式、history API模式和内存路由（适用于非浏览器环境），WebSocket用于双向通信，不是路由方式。"
  },
  {
    "id": 930,
    "type": "single",
    "category": "前端框架",
    "difficulty": "困难",
    "question": "仓颉语言中前端状态管理的核心问题是？",
    "options": {
      "A": "状态共享与同步",
      "B": "提高渲染性能",
      "C": "减少代码量",
      "D": "优化网络请求"
    },
    "answer": [
      "A"
    ],
    "explanation": "前端状态管理（如Redux、Vuex）主要解决多个组件间的状态共享和同步问题，保证状态变化可预测。"
  },
  {
    "id": 931,
    "type": "single",
    "category": "移动开发",
    "difficulty": "中等",
    "question": "仓颉语言中移动端适配的常用方案不包括？",
    "options": {
      "A": "rem适配",
      "B": "vw/vh适配",
      "C": "固定像素适配",
      "D": "媒体查询适配"
    },
    "answer": [
      "C"
    ],
    "explanation": "固定像素适配无法适应不同屏幕尺寸，不是移动端适配的常用方案，其他选项均为有效的适配方法。"
  },
  {
    "id": 932,
    "type": "single",
    "category": "移动开发",
    "difficulty": "中等",
    "question": "仓颉语言中移动端本地存储的方式不包括？",
    "options": {
      "A": "localStorage",
      "B": "SessionStorage",
      "C": "Cookie",
      "D": "DatabaseLink"
    },
    "answer": [
      "D"
    ],
    "explanation": "移动端本地存储包括localStorage、SessionStorage、Cookie和IndexedDB等，DatabaseLink不是存储方式。"
  },
  {
    "id": 933,
    "type": "single",
    "category": "移动开发",
    "difficulty": "困难",
    "question": "仓颉语言中Hybrid App与Native App的主要区别是？",
    "options": {
      "A": "开发技术栈不同",
      "B": "是否需要安装",
      "C": "是否支持网络访问",
      "D": "是否跨平台"
    },
    "answer": [
      "A"
    ],
    "explanation": "Hybrid App使用Web技术（HTML/CSS/JS）开发，结合原生容器；Native App使用平台特定语言（如Java、Swift）开发，这是核心区别。"
  },
  {
    "id": 934,
    "type": "single",
    "category": "移动开发",
    "difficulty": "中等",
    "question": "仓颉语言中移动端手势识别的事件不包括？",
    "options": {
      "A": "tap",
      "B": "swipe",
      "C": "rotate",
      "D": "hover"
    },
    "answer": [
      "D"
    ],
    "explanation": "hover是鼠标悬停事件，不适用于移动端触摸交互，移动端常用手势事件包括tap（点击）、swipe（滑动）、rotate（旋转）等。"
  },
  {
    "id": 935,
    "type": "single",
    "category": "移动开发",
    "difficulty": "困难",
    "question": "仓颉语言中移动端性能优化的方向不包括？",
    "options": {
      "A": "减少DOM操作",
      "B": "优化图片加载",
      "C": "增加JavaScript代码量",
      "D": "使用懒加载"
    },
    "answer": [
      "C"
    ],
    "explanation": "增加JavaScript代码量会增加解析和执行时间，降低性能，不是优化方向，其他选项均为有效的性能优化手段。"
  },
  {
    "id": 936,
    "type": "single",
    "category": "大数据处理",
    "difficulty": "困难",
    "question": "仓颉语言中MapReduce的核心阶段是？",
    "options": {
      "A": "Map和Reduce",
      "B": "Split和Combine",
      "C": "Shuffle和Sort",
      "D": "Input和Output"
    },
    "answer": [
      "A"
    ],
    "explanation": "MapReduce是分布式计算框架，核心阶段是Map（映射）和Reduce（归约），完成数据的转换和聚合。"
  },
  {
    "id": 937,
    "type": "single",
    "category": "大数据处理",
    "difficulty": "中等",
    "question": "仓颉语言中HDFS的架构不包括？",
    "options": {
      "A": "NameNode",
      "B": "DataNode",
      "C": "JobTracker",
      "D": "Secondary NameNode"
    },
    "answer": [
      "C"
    ],
    "explanation": "HDFS架构包括NameNode（元数据管理）、DataNode（数据存储）和Secondary NameNode（元数据备份），JobTracker是MapReduce的组件。"
  },
  {
    "id": 938,
    "type": "single",
    "category": "大数据处理",
    "difficulty": "困难",
    "question": "仓颉语言中Spark与MapReduce的主要区别是？",
    "options": {
      "A": "基于内存计算",
      "B": "支持批处理",
      "C": "分布式计算",
      "D": "使用Java语言"
    },
    "answer": [
      "A"
    ],
    "explanation": "Spark与MapReduce均支持分布式批处理，核心区别是Spark基于内存计算，速度远快于MapReduce的磁盘IO操作。"
  },
  {
    "id": 939,
    "type": "single",
    "category": "大数据处理",
    "difficulty": "中等",
    "question": "仓颉语言中Kafka的主要作用是？",
    "options": {
      "A": "高吞吐量的消息队列",
      "B": "分布式数据库",
      "C": "实时计算引擎",
      "D": "数据存储系统"
    },
    "answer": [
      "A"
    ],
    "explanation": "Kafka是一个高吞吐量的分布式消息队列，用于处理实时数据流，支持高并发读写。"
  },
  {
    "id": 940,
    "type": "single",
    "category": "大数据处理",
    "difficulty": "困难",
    "question": "仓颉语言中Flink的核心特性是？",
    "options": {
      "A": "实时流处理",
      "B": "批处理优先",
      "C": "内存计算",
      "D": "基于磁盘存储"
    },
    "answer": [
      "A"
    ],
    "explanation": "Flink是一个分布式流处理框架，核心特性是支持低延迟、高吞吐的实时流处理，同时也支持批处理。"
  },
  {
    "id": 941,
    "type": "single",
    "category": "人工智能",
    "difficulty": "困难",
    "question": "仓颉语言中机器学习的监督学习与无监督学习的主要区别是？",
    "options": {
      "A": "是否使用标记数据",
      "B": "是否需要大量数据",
      "C": "是否有预测能力",
      "D": "是否使用神经网络"
    },
    "answer": [
      "A"
    ],
    "explanation": "监督学习使用带标记的训练数据（输入+输出），无监督学习使用无标记数据，这是两者的核心区别。"
  },
  {
    "id": 942,
    "type": "single",
    "category": "人工智能",
    "difficulty": "中等",
    "question": "仓颉语言中神经网络的基本组成单元是？",
    "options": {
      "A": "神经元",
      "B": "层",
      "C": "激活函数",
      "D": "权重"
    },
    "answer": [
      "A"
    ],
    "explanation": "神经网络的基本组成单元是神经元（感知器），多个神经元组成层，通过权重连接，使用激活函数处理输出。"
  },
  {
    "id": 943,
    "type": "single",
    "category": "人工智能",
    "difficulty": "困难",
    "question": "仓颉语言中过拟合的解决方法不包括？",
    "options": {
      "A": "增加训练数据",
      "B": "使用正则化",
      "C": "简化模型",
      "D": "增加模型复杂度"
    },
    "answer": [
      "D"
    ],
    "explanation": "过拟合是模型过度拟合训练数据的现象，增加模型复杂度会加剧过拟合，其他选项均为有效的解决方法。"
  },
  {
    "id": 944,
    "type": "single",
    "category": "人工智能",
    "difficulty": "中等",
    "question": "仓颉语言中梯度下降算法的作用是？",
    "options": {
      "A": "最小化损失函数",
      "B": "最大化准确率",
      "C": "优化数据分布",
      "D": "加速模型训练"
    },
    "answer": [
      "A"
    ],
    "explanation": "梯度下降是一种优化算法，通过沿着损失函数的梯度方向调整参数，找到使损失函数最小化的参数组合。"
  },
  {
    "id": 945,
    "type": "single",
    "category": "人工智能",
    "difficulty": "困难",
    "question": "仓颉语言中CNN（卷积神经网络）的核心层不包括？",
    "options": {
      "A": "卷积层",
      "B": "池化层",
      "C": "全连接层",
      "D": "循环层"
    },
    "answer": [
      "D"
    ],
    "explanation": "循环层（如LSTM、GRU）是循环神经网络（RNN）的核心层，不是CNN的组成部分，CNN包括卷积层、池化层和全连接层。"
  },
  {
    "id": 946,
    "type": "single",
    "category": "区块链",
    "difficulty": "困难",
    "question": "仓颉语言中区块链的核心特性不包括？",
    "options": {
      "A": "中心化",
      "B": "不可篡改",
      "C": "去中心化",
      "D": "可追溯"
    },
    "answer": [
      "A"
    ],
    "explanation": "区块链的核心特性包括去中心化、不可篡改、可追溯和透明性，中心化是其对立面，不是核心特性。"
  },
  {
    "id": 947,
    "type": "single",
    "category": "区块链",
    "difficulty": "中等",
    "question": "仓颉语言中区块链中区块的主要组成部分不包括？",
    "options": {
      "A": "区块头",
      "B": "交易数据",
      "C": "哈希值",
      "D": "中心节点地址"
    },
    "answer": [
      "D"
    ],
    "explanation": "区块链的区块由区块头（含前一区块哈希）、交易数据和自身哈希组成，无中心节点地址，因区块链去中心化。"
  },
  {
    "id": 948,
    "type": "single",
    "category": "区块链",
    "difficulty": "困难",
    "question": "仓颉语言中区块链的共识机制不包括？",
    "options": {
      "A": "PoW（工作量证明）",
      "B": "PoS（权益证明）",
      "C": "DFS（深度优先搜索）",
      "D": "DPoS（委托权益证明）"
    },
    "answer": [
      "C"
    ],
    "explanation": "DFS是一种图遍历算法，不是区块链的共识机制，其他选项均为常见的区块链共识机制。"
  },
  {
    "id": 949,
    "type": "single",
    "category": "区块链",
    "difficulty": "中等",
    "question": "仓颉语言中智能合约的特点是？",
    "options": {
      "A": "自动执行的代码",
      "B": "需要人工干预",
      "C": "仅用于金融领域",
      "D": "不可部署修改"
    },
    "answer": [
      "A"
    ],
    "explanation": "智能合约是部署在区块链上的自动执行代码，当满足预设条件时自动运行，无需人工干预，应用领域广泛。"
  },
  {
    "id": 950,
    "type": "single",
    "category": "区块链",
    "difficulty": "困难",
    "question": "仓颉语言中区块链与数据库的主要区别是？",
    "options": {
      "A": "数据一致性保障方式",
      "B": "数据存储格式",
      "C": "查询效率",
      "D": "支持的数据类型"
    },
    "answer": [
      "A"
    ],
    "explanation": "区块链通过分布式共识保障数据一致性，传统数据库通过ACID事务，这是两者的核心区别。"
  },
  {
    "id": 951,
    "type": "single",
    "category": "性能测试",
    "difficulty": "中等",
    "question": "仓颉语言中性能测试的指标不包括？",
    "options": {
      "A": "响应时间",
      "B": "并发用户数",
      "C": "代码行数",
      "D": "吞吐量"
    },
    "answer": [
      "C"
    ],
    "explanation": "性能测试指标包括响应时间、并发用户数、吞吐量、错误率等，代码行数与性能无直接关联。"
  },
  {
    "id": 952,
    "type": "single",
    "category": "性能测试",
    "difficulty": "中等",
    "question": "仓颉语言中负载测试与压力测试的区别是？",
    "options": {
      "A": "测试目标不同",
      "B": "测试工具不同",
      "C": "测试环境不同",
      "D": "测试数据不同"
    },
    "answer": [
      "A"
    ],
    "explanation": "负载测试目标是找到系统在正常负载下的性能瓶颈；压力测试目标是确定系统的极限承载能力，测试目标不同。"
  },
  {
    "id": 953,
    "type": "single",
    "category": "性能测试",
    "difficulty": "困难",
    "question": "仓颉语言中JMeter的主要作用是？",
    "options": {
      "A": "性能测试工具",
      "B": "单元测试框架",
      "C": "代码质量分析工具",
      "D": "版本控制工具"
    },
    "answer": [
      "A"
    ],
    "explanation": "JMeter是一款开源的性能测试工具，用于模拟高负载场景，测试系统的性能表现。"
  },
  {
    "id": 954,
    "type": "single",
    "category": "性能测试",
    "difficulty": "中等",
    "question": "仓颉语言中性能瓶颈的常见位置不包括？",
    "options": {
      "A": "CPU",
      "B": "内存",
      "C": "代码注释",
      "D": "数据库"
    },
    "answer": [
      "C"
    ],
    "explanation": "性能瓶颈通常出现在CPU、内存、磁盘IO、网络或数据库等资源层面，代码注释不影响性能。"
  },
  {
    "id": 955,
    "type": "single",
    "category": "性能测试",
    "difficulty": "困难",
    "question": "仓颉语言中并发测试的目的是？",
    "options": {
      "A": "验证多用户同时操作的稳定性",
      "B": "测试系统的极限容量",
      "C": "优化代码执行效率",
      "D": "检查数据准确性"
    },
    "answer": [
      "A"
    ],
    "explanation": "并发测试模拟多个用户同时访问系统，验证系统在并发场景下的稳定性和数据一致性。"
  },
  {
    "id": 956,
    "type": "single",
    "category": "DevOps",
    "difficulty": "中等",
    "question": "仓颉语言中CI/CD的含义是？",
    "options": {
      "A": "持续集成/持续部署",
      "B": "代码检查/代码部署",
      "C": "持续开发/持续测试",
      "D": "配置管理/发布管理"
    },
    "answer": [
      "A"
    ],
    "explanation": "CI（Continuous Integration）指持续集成，频繁将代码合并到主分支并自动构建测试；CD（Continuous Deployment）指持续部署，自动将通过测试的代码部署到生产环境。"
  },
  {
    "id": 957,
    "type": "single",
    "category": "DevOps",
    "difficulty": "中等",
    "question": "仓颉语言中Docker容器与虚拟机的主要区别是？",
    "options": {
      "A": "资源占用",
      "B": "是否隔离",
      "C": "是否需要操作系统",
      "D": "是否可移植"
    },
    "answer": [
      "A"
    ],
    "explanation": "Docker容器共享宿主机操作系统内核，资源占用远低于虚拟机（需完整操作系统），这是核心区别。"
  },
  {
    "id": 958,
    "type": "single",
    "category": "DevOps",
    "difficulty": "困难",
    "question": "仓颉语言中Kubernetes的核心组件不包括？",
    "options": {
      "A": "Pod",
      "B": "Service",
      "C": "Container",
      "D": "Deployment"
    },
    "answer": [
      "C"
    ],
    "explanation": "Container（容器）是Docker的概念，Kubernetes的核心组件包括Pod、Service、Deployment、Node、Master等。"
  },
  {
    "id": 959,
    "type": "single",
    "category": "DevOps",
    "difficulty": "中等",
    "question": "仓颉语言中基础设施即代码（IaC）的工具不包括？",
    "options": {
      "A": "Terraform",
      "B": "Ansible",
      "C": "Jenkins",
      "D": "Puppet"
    },
    "answer": [
      "C"
    ],
    "explanation": "Jenkins是CI/CD工具，不是IaC工具；Terraform、Ansible、Puppet均为基础设施即代码工具。"
  },
  {
    "id": 960,
    "type": "single",
    "category": "DevOps",
    "difficulty": "困难",
    "question": "仓颉语言中监控系统的核心指标不包括？",
    "options": {
      "A": "CPU使用率",
      "B": "内存占用",
      "C": "代码提交次数",
      "D": "磁盘IO"
    },
    "answer": [
      "C"
    ],
    "explanation": "监控系统的核心指标包括CPU、内存、磁盘、网络等资源使用率和系统性能指标，代码提交次数不属于监控指标。"
  },
  {
    "id": 961,
    "type": "single",
    "category": "算法基础",
    "difficulty": "中等",
    "question": "仓颉语言中时间复杂度为O(log n)的算法是？",
    "options": {
      "A": "二分查找",
      "B": "线性查找",
      "C": "冒泡排序",
      "D": "插入排序"
    },
    "answer": [
      "A"
    ],
    "explanation": "二分查找通过每次减半查找范围，时间复杂度为O(log n)；线性查找为O(n)，冒泡和插入排序为O(n²)。"
  },
  {
    "id": 962,
    "type": "single",
    "category": "算法基础",
    "difficulty": "困难",
    "question": "仓颉语言中快速排序的平均时间复杂度是？",
    "options": {
      "A": "O(n log n)",
      "B": "O(n²)",
      "C": "O(n)",
      "D": "O(log n)"
    },
    "answer": [
      "A"
    ],
    "explanation": "快速排序在平均情况下时间复杂度为O(n log n)，最坏情况下为O(n²)，但通过合理选择基准可避免最坏情况。"
  },
  {
    "id": 963,
    "type": "single",
    "category": "算法基础",
    "difficulty": "中等",
    "question": "仓颉语言中栈的特点是？",
    "options": {
      "A": "先进后出",
      "B": "先进先出",
      "C": "随机访问",
      "D": "双向访问"
    },
    "answer": [
      "A"
    ],
    "explanation": "栈是一种线性数据结构，遵循先进后出（LIFO）原则，只能在一端进行插入和删除操作。"
  },
  {
    "id": 964,
    "type": "single",
    "category": "算法基础",
    "difficulty": "困难",
    "question": "仓颉语言中动态规划与分治法的主要区别是？",
    "options": {
      "A": "是否存储子问题结果",
      "B": "是否分解问题",
      "C": "是否递归求解",
      "D": "是否适用于大规模问题"
    },
    "answer": [
      "A"
    ],
    "explanation": "动态规划通过存储子问题的解（重叠子问题）避免重复计算；分治法不存储子问题结果，可能重复计算，这是核心区别。"
  },
  {
    "id": 965,
    "type": "single",
    "category": "算法基础",
    "difficulty": "中等",
    "question": "仓颉语言中广度优先搜索（BFS）通常使用的辅助结构是？",
    "options": {
      "A": "队列",
      "B": "栈",
      "C": "数组",
      "D": "链表"
    },
    "answer": [
      "A"
    ],
    "explanation": "广度优先搜索按层次遍历，通常使用队列存储待访问节点，确保先访问的节点先处理。"
  },
  {
    "id": 966,
    "type": "single",
    "category": "设计原则",
    "difficulty": "中等",
    "question": "仓颉语言中单一职责原则的含义是？",
    "options": {
      "A": "一个类只负责一项职责",
      "B": "类之间通过接口交互",
      "C": "依赖抽象而非具体实现",
      "D": "对扩展开放，对修改关闭"
    },
    "answer": [
      "A"
    ],
    "explanation": "单一职责原则（SRP）要求一个类只负责一个功能领域的相应职责，降低类的复杂度。"
  },
  {
    "id": 967,
    "type": "single",
    "category": "设计原则",
    "difficulty": "中等",
    "question": "仓颉语言中开闭原则的含义是？",
    "options": {
      "A": "对扩展开放，对修改关闭",
      "B": "子类可替换父类",
      "C": "接口最小化",
      "D": "依赖抽象"
    },
    "answer": [
      "A"
    ],
    "explanation": "开闭原则（OCP）是设计原则的核心，要求软件实体（类、模块等）对扩展开放，对修改关闭，通过抽象实现。"
  },
  {
    "id": 968,
    "type": "single",
    "category": "设计原则",
    "difficulty": "困难",
    "question": "仓颉语言中里氏替换原则的作用是？",
    "options": {
      "A": "保证继承复用的正确性",
      "B": "减少类之间的依赖",
      "C": "提高代码可读性",
      "D": "优化性能"
    },
    "answer": [
      "A"
    ],
    "explanation": "里氏替换原则要求子类可替换父类且不改变程序正确性，确保继承关系的合理性，保证代码复用的安全性。"
  },
  {
    "id": 969,
    "type": "single",
    "category": "设计原则",
    "difficulty": "中等",
    "question": "仓颉语言中依赖倒置原则的含义是？",
    "options": {
      "A": "依赖抽象，不依赖具体",
      "B": "高层模块依赖低层模块",
      "C": "具体类依赖抽象类",
      "D": "接口依赖实现类"
    },
    "answer": [
      "A"
    ],
    "explanation": "依赖倒置原则（DIP）要求高层模块和低层模块都依赖抽象，抽象不依赖细节，细节依赖抽象。"
  },
  {
    "id": 970,
    "type": "single",
    "category": "设计原则",
    "difficulty": "中等",
    "question": "仓颉语言中接口隔离原则的含义是？",
    "options": {
      "A": "接口应小而专，避免臃肿",
      "B": "一个类只实现必要的接口",
      "C": "接口之间不允许继承",
      "D": "接口方法应尽可能多"
    },
    "answer": [
      "A"
    ],
    "explanation": "接口隔离原则（ISP）要求接口应保持精简，只包含客户端需要的方法，避免创建庞大的万能接口。"
  },
  {
    "id": 971,
    "type": "single",
    "category": "网络安全",
    "difficulty": "中等",
    "question": "仓颉语言中SQL注入攻击的防御方法不包括？",
    "options": {
      "A": "使用预处理语句",
      "B": "输入验证和过滤",
      "C": "使用ORM框架",
      "D": "加密传输数据"
    },
    "answer": [
      "D"
    ],
    "explanation": "加密传输（如HTTPS）用于保护数据传输安全，无法防御SQL注入；其他选项均为有效的SQL注入防御方法。"
  },
  {
    "id": 972,
    "type": "single",
    "category": "网络安全",
    "difficulty": "中等",
    "question": "仓颉语言中XSS攻击的主要目标是？",
    "options": {
      "A": "窃取用户信息",
      "B": "篡改数据库",
      "C": "控制服务器",
      "D": "消耗系统资源"
    },
    "answer": [
      "A"
    ],
    "explanation": "XSS（跨站脚本）攻击通过在网页注入恶意脚本，窃取用户Cookie、会话等敏感信息。"
  },
  {
    "id": 973,
    "type": "single",
    "category": "网络安全",
    "difficulty": "困难",
    "question": "仓颉语言中CSRF攻击的防御方法不包括？",
    "options": {
      "A": "使用Token验证",
      "B": "检查Referer",
      "C": "输入过滤",
      "D": "SameSite Cookie"
    },
    "answer": [
      "C"
    ],
    "explanation": "输入过滤主要用于防御XSS和SQL注入，对CSRF（跨站请求伪造）无效；其他选项均为有效的CSRF防御方法。"
  },
  {
    "id": 974,
    "type": "single",
    "category": "网络安全",
    "difficulty": "中等",
    "question": "仓颉语言中HTTPS的加密方式是？",
    "options": {
      "A": "对称加密+非对称加密",
      "B": "仅对称加密",
      "C": "仅非对称加密",
      "D": "哈希加密"
    },
    "answer": [
      "A"
    ],
    "explanation": "HTTPS通过非对称加密交换对称密钥，之后使用对称加密传输数据，结合两种加密方式的优势。"
  },
  {
    "id": 975,
    "type": "single",
    "category": "网络安全",
    "difficulty": "困难",
    "question": "仓颉语言中密码存储的最佳实践是？",
    "options": {
      "A": "哈希+盐值",
      "B": "明文存储",
      "C": "仅加密存储",
      "D": "Base64编码存储"
    },
    "answer": [
      "A"
    ],
    "explanation": "密码应使用强哈希算法（如BCrypt、Argon2）结合随机盐值存储，避免明文、简单加密或编码存储。"
  },
  {
    "id": 976,
    "type": "single",
    "category": "移动应用安全",
    "difficulty": "困难",
    "question": "仓颉语言中移动应用的本地数据加密方法不包括？",
    "options": {
      "A": "AES加密",
      "B": "SQLCipher",
      "C": "Base64编码",
      "D": "硬件加密"
    },
    "answer": [
      "C"
    ],
    "explanation": "Base64是编码方式而非加密，不能用于保护敏感数据；AES、SQLCipher（数据库加密）和硬件加密均为有效的本地数据加密方法。"
  },
  {
    "id": 977,
    "type": "single",
    "category": "移动应用安全",
    "difficulty": "中等",
    "question": "仓颉语言中移动应用的证书固定（Certificate Pinning）作用是？",
    "options": {
      "A": "防止中间人攻击",
      "B": "加速网络请求",
      "C": "减少数据传输量",
      "D": "优化电池消耗"
    },
    "answer": [
      "A"
    ],
    "explanation": "证书固定将服务器证书或公钥硬编码到应用中，验证服务器身份，防止中间人攻击篡改证书。"
  },
  {
    "id": 978,
    "type": "single",
    "category": "移动应用安全",
    "difficulty": "困难",
    "question": "仓颉语言中移动应用的代码混淆目的是？",
    "options": {
      "A": "增加逆向工程难度",
      "B": "减少代码体积",
      "C": "提高运行效率",
      "D": "修复安全漏洞"
    },
    "answer": [
      "A"
    ],
    "explanation": "代码混淆通过重命名类、方法和变量，移除注释等方式，使代码难以阅读和理解，增加逆向工程的难度。"
  },
  {
    "id": 979,
    "type": "single",
    "category": "移动应用安全",
    "difficulty": "中等",
    "question": "仓颉语言中移动应用的敏感数据不应存储在？",
    "options": {
      "A": "内存中",
      "B": "安全区域（如KeyStore）",
      "C": "未加密的SharedPreferences",
      "D": "加密的数据库"
    },
    "answer": [
      "C"
    ],
    "explanation": "未加密的SharedPreferences易被获取，不应存储敏感数据；敏感数据应存储在安全区域或加密存储。"
  },
  {
    "id": 980,
    "type": "single",
    "category": "移动应用安全",
    "difficulty": "困难",
    "question": "仓颉语言中移动应用的越狱/Root检测作用是？",
    "options": {
      "A": "识别不安全环境并采取措施",
      "B": "提高应用性能",
      "C": "增加应用兼容性",
      "D": "优化用户体验"
    },
    "answer": [
      "A"
    ],
    "explanation": "越狱/Root设备安全性降低，应用通过检测可识别不安全环境，采取限制功能、加强加密等措施保护数据。"
  },
  {
    "id": 981,
    "type": "single",
    "category": "云原生",
    "difficulty": "中等",
    "question": "仓颉语言中云原生应用的特点不包括？",
    "options": {
      "A": "单体架构",
      "B": "容器化部署",
      "C": "微服务架构",
      "D": "弹性伸缩"
    },
    "answer": [
      "A"
    ],
    "explanation": "云原生应用采用微服务架构而非单体架构，具备容器化、弹性伸缩、DevOps等特点。"
  },
  {
    "id": 982,
    "type": "single",
    "category": "云原生",
    "difficulty": "中等",
    "question": "仓颉语言中服务网格（Service Mesh）的主要作用是？",
    "options": {
      "A": "管理服务间通信",
      "B": "实现服务注册发现",
      "C": "进行配置管理",
      "D": "监控系统性能"
    },
    "answer": [
      "A"
    ],
    "explanation": "服务网格通过数据平面（代理）和控制平面，管理服务间的通信，处理流量路由、负载均衡、熔断等。"
  },
  {
    "id": 983,
    "type": "single",
    "category": "云原生",
    "difficulty": "困难",
    "question": "仓颉语言中Serverless架构的特点是？",
    "options": {
      "A": "无需管理服务器",
      "B": "必须使用特定语言",
      "C": "不支持弹性伸缩",
      "D": "适合长运行任务"
    },
    "answer": [
      "A"
    ],
    "explanation": "Serverless（无服务器）架构由云厂商管理服务器，开发者只需关注代码，按使用量计费，适合短运行任务。"
  },
  {
    "id": 984,
    "type": "single",
    "category": "云原生",
    "difficulty": "中等",
    "question": "仓颉语言中容器镜像的构建文件是？",
    "options": {
      "A": "Dockerfile",
      "B": "docker.conf",
      "C": "image.yaml",
      "D": "container.json"
    },
    "answer": [
      "A"
    ],
    "explanation": "Dockerfile是用于构建容器镜像的文本文件，包含一系列构建指令，定义镜像的内容和配置。"
  },
  {
    "id": 985,
    "type": "single",
    "category": "云原生",
    "difficulty": "困难",
    "question": "仓颉语言中GitOps的核心思想是？",
    "options": {
      "A": "以Git为单一数据源管理部署",
      "B": "使用Git进行代码版本控制",
      "C": "自动化代码提交流程",
      "D": "集中管理Git仓库"
    },
    "answer": [
      "A"
    ],
    "explanation": "GitOps将Git仓库作为系统配置和部署的单一数据源，通过监控Git变化自动同步到目标环境。"
  },
  {
    "id": 986,
    "type": "single",
    "category": "数据结构",
    "difficulty": "中等",
    "question": "仓颉语言中哈希表的平均查找时间复杂度是？",
    "options": {
      "A": "O(1)",
      "B": "O(n)",
      "C": "O(log n)",
      "D": "O(n log n)"
    },
    "answer": [
      "A"
    ],
    "explanation": "哈希表通过哈希函数直接定位元素位置，平均查找时间复杂度为O(1)，最坏情况为O(n)（哈希冲突严重时）。"
  },
  {
    "id": 987,
    "type": "single",
    "category": "数据结构",
    "difficulty": "困难",
    "question": "仓颉语言中红黑树的特点不包括？",
    "options": {
      "A": "平衡二叉树",
      "B": "自平衡机制",
      "C": "查询时间复杂度O(n)",
      "D": "插入删除效率高"
    },
    "answer": [
      "C"
    ],
    "explanation": "红黑树是一种自平衡二叉查找树，查询、插入、删除的时间复杂度均为O(log n)，而非O(n)。"
  },
  {
    "id": 988,
    "type": "single",
    "category": "数据结构",
    "difficulty": "中等",
    "question": "仓颉语言中链表与数组的主要区别是？",
    "options": {
      "A": "内存分配方式",
      "B": "是否可存储数据",
      "C": "是否支持遍历",
      "D": "是否支持修改"
    },
    "answer": [
      "A"
    ],
    "explanation": "数组是连续内存空间，链表通过指针指向非连续节点，内存分配方式不同，导致访问和修改性能有差异。"
  },
  {
    "id": 989,
    "type": "single",
    "category": "数据结构",
    "difficulty": "困难",
    "question": "仓颉语言中堆（Heap）的主要应用不包括？",
    "options": {
      "A": "优先队列",
      "B": "堆排序",
      "C": "快速查找",
      "D": "Top K问题"
    },
    "answer": [
      "C"
    ],
    "explanation": "堆适用于优先队列、堆排序和Top K问题等场景，但不支持快速查找（需O(n)时间），查找适合用哈希表或二叉查找树。"
  },
  {
    "id": 990,
    "type": "single",
    "category": "数据结构",
    "difficulty": "中等",
    "question": "仓颉语言中图的遍历方式不包括？",
    "options": {
      "A": "深度优先搜索",
      "B": "广度优先搜索",
      "C": "层次遍历",
      "D": "二分查找"
    },
    "answer": [
      "D"
    ],
    "explanation": "二分查找是有序数组的查找算法，不适用于图的遍历；图的遍历方式包括深度优先搜索、广度优先搜索和层次遍历。"
  },
  {
    "id": 991,
    "type": "single",
    "category": "编译原理",
    "difficulty": "困难",
    "question": "仓颉语言中词法分析的输出是？",
    "options": {
      "A": "记号（Token）",
      "B": "语法树",
      "C": "中间代码",
      "D": "目标代码"
    },
    "answer": [
      "A"
    ],
    "explanation": "词法分析将源代码分解为有意义的基本单位（记号/Token），如关键字、标识符、常量等。"
  },
  {
    "id": 992,
    "type": "single",
    "category": "编译原理",
    "difficulty": "困难",
    "question": "仓颉语言中语法分析的主要任务是？",
    "options": {
      "A": "检查语法正确性并构建语法树",
      "B": "将代码转换为中间表示",
      "C": "优化代码执行效率",
      "D": "生成机器码"
    },
    "answer": [
      "A"
    ],
    "explanation": "语法分析根据语法规则检查Token序列的语法正确性，并构建抽象语法树（AST）。"
  },
  {
    "id": 993,
    "type": "single",
    "category": "编译原理",
    "difficulty": "困难",
    "question": "仓颉语言中中间代码的特点不包括？",
    "options": {
      "A": "与机器无关",
      "B": "易于优化",
      "C": "直接执行",
      "D": "便于代码移植"
    },
    "answer": [
      "C"
    ],
    "explanation": "中间代码是源代码的中间表示形式，与机器无关，便于优化和移植，但不能直接执行，需进一步转换为目标代码。"
  },
  {
    "id": 994,
    "type": "single",
    "category": "编译原理",
    "difficulty": "中等",
    "question": "仓颉语言中语义分析的作用是？",
    "options": {
      "A": "检查代码的逻辑正确性",
      "B": "分解源代码为Token",
      "C": "生成目标代码",
      "D": "优化代码结构"
    },
    "answer": [
      "A"
    ],
    "explanation": "语义分析检查代码的逻辑正确性，如类型匹配、变量未定义等，确保代码含义合法。"
  },
  {
    "id": 995,
    "type": "single",
    "category": "编译原理",
    "difficulty": "困难",
    "question": "仓颉语言中代码优化的目的是？",
    "options": {
      "A": "提高代码执行效率",
      "B": "增加代码可读性",
      "C": "减少代码行数",
      "D": "便于调试"
    },
    "answer": [
      "A"
    ],
    "explanation": "代码优化通过消除冗余、重组指令等方式，生成更高效的目标代码，提高程序执行效率。"
  },
  {
    "id": 996,
    "type": "single",
    "category": "计算机网络",
    "difficulty": "中等",
    "question": "仓颉语言中TCP/IP协议栈的四层模型不包括？",
    "options": {
      "A": "应用层",
      "B": "传输层",
      "C": "会话层",
      "D": "网络层"
    },
    "answer": [
      "C"
    ],
    "explanation": "TCP/IP四层模型包括应用层、传输层、网络层和网络接口层，会话层是OSI七层模型的层级。"
  },
  {
    "id": 997,
    "type": "single",
    "category": "计算机网络",
    "difficulty": "中等",
    "question": "仓颉语言中HTTP请求方法GET与POST的主要区别是？",
    "options": {
      "A": "数据传输方式",
      "B": "是否支持缓存",
      "C": "请求长度限制",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "GET通过URL传递数据，POST通过请求体；GET可缓存，POST不可；GET有长度限制，POST无，这些都是两者的区别。"
  },
  {
    "id": 998,
    "type": "single",
    "category": "计算机网络",
    "difficulty": "困难",
    "question": "仓颉语言中DNS的主要作用是？",
    "options": {
      "A": "域名解析为IP地址",
      "B": "路由选择",
      "C": "数据传输",
      "D": "加密通信"
    },
    "answer": [
      "A"
    ],
    "explanation": "DNS（域名系统）负责将人类可读的域名（如www.example.com）解析为计算机可识别的IP地址。"
  },
  {
    "id": 999,
    "type": "single",
    "category": "计算机网络",
    "difficulty": "中等",
    "question": "仓颉语言中端口号的作用是？",
    "options": {
      "A": "标识应用程序",
      "B": "标识主机",
      "C": "加密数据",
      "D": "路由数据"
    },
    "answer": [
      "A"
    ],
    "explanation": "端口号用于在同一主机上标识不同的网络应用程序，使数据能正确送达目标应用。"
  },
  {
    "id": 1000,
    "type": "single",
    "category": "计算机网络",
    "difficulty": "困难",
    "question": "仓颉语言中HTTPS与HTTP的主要区别是？",
    "options": {
      "A": "是否加密传输",
      "B": "使用的端口不同",
      "C": "协议版本不同",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "HTTPS通过SSL/TLS加密传输，HTTP明文传输；HTTPS默认使用443端口，HTTP使用80端口；两者协议版本也不同，这些都是核心区别。"
  },
  {
    "id": 1001,
    "type": "single",
    "category": "语法基础",
    "difficulty": "简单",
    "question": "仓颉语言中用于声明不可变变量的关键字是？",
    "options": {
      "A": "val",
      "B": "var",
      "C": "const",
      "D": "final"
    },
    "answer": [
      "A"
    ],
    "explanation": "val 关键字用于声明不可变变量，一旦赋值后不能重新赋值。"
  },
  {
    "id": 1002,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些运算符具有空安全特性？",
    "options": {
      "A": "安全调用运算符(?.)",
      "B": "Elvis运算符(?:)",
      "C": "非空断言运算符(!!)",
      "D": "安全转换运算符(as?)"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言提供完整的空安全运算符体系，包括安全调用、Elvis、非空断言和安全转换运算符。"
  },
  {
    "id": 1003,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示32位整数的类型是？",
    "options": {
      "A": "Int",
      "B": "Integer",
      "C": "Int32",
      "D": "Long"
    },
    "answer": [
      "A"
    ],
    "explanation": "Int 类型表示32位整数，是仓颉语言中最常用的整数类型。"
  },
  {
    "id": 1004,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是值类型？",
    "options": {
      "A": "Int",
      "B": "Double",
      "C": "String",
      "D": "Boolean"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Int、Double、Boolean是值类型，String是引用类型。"
  },
  {
    "id": 1005,
    "type": "single",
    "category": "函数编程",
    "difficulty": "简单",
    "question": "仓颉语言中定义函数的关键字是？",
    "options": {
      "A": "function",
      "B": "func",
      "C": "def",
      "D": "fn"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用 function 关键字定义函数。"
  },
  {
    "id": 1006,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是函数式编程的核心概念？",
    "options": {
      "A": "不可变性",
      "B": "高阶函数",
      "C": "纯函数",
      "D": "副作用管理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些概念都是函数式编程的核心，仓颉语言都提供了良好的支持。"
  },
  {
    "id": 1007,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中定义类的关键字是？",
    "options": {
      "A": "class",
      "B": "struct",
      "C": "object",
      "D": "type"
    },
    "answer": [
      "A"
    ],
    "explanation": "class 关键字用于定义类，支持面向对象编程特性。"
  },
  {
    "id": 1008,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些访问修饰符是有效的？",
    "options": {
      "A": "public",
      "B": "private",
      "C": "internal",
      "D": "protected"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "仓颉语言支持public、private和internal访问修饰符，没有protected。"
  },
  {
    "id": 1009,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中创建协程的关键字是？",
    "options": {
      "A": "spawn",
      "B": "async",
      "C": "launch",
      "D": "go"
    },
    "answer": [
      "A"
    ],
    "explanation": "spawn 关键字用于创建轻量级线程（协程）。"
  },
  {
    "id": 1010,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是协程调度器？",
    "options": {
      "A": "Dispatchers.IO",
      "B": "Dispatchers.Main",
      "C": "Dispatchers.Default",
      "D": "Dispatchers.Unconfined"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些调度器分别用于IO操作、UI线程、CPU密集型任务和无约束执行。"
  },
  {
    "id": 1011,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言采用的内存管理机制是？",
    "options": {
      "A": "自动垃圾回收",
      "B": "手动内存管理",
      "C": "引用计数",
      "D": "所有权系统"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用自动垃圾回收机制管理内存，开发者无需手动释放内存。"
  },
  {
    "id": 1012,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些引用类型不会阻止垃圾回收？",
    "options": {
      "A": "软引用",
      "B": "弱引用",
      "C": "幻象引用",
      "D": "强引用"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "软引用、弱引用和幻象引用不会阻止对象被垃圾回收，只有强引用会。"
  },
  {
    "id": 1013,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于数学计算的类库是？",
    "options": {
      "A": "Math",
      "B": "Arithmetic",
      "C": "Calculate",
      "D": "Number"
    },
    "answer": [
      "A"
    ],
    "explanation": "Math 类库提供常用的数学函数和常量。"
  },
  {
    "id": 1014,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合操作的高阶函数？",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "reduce",
      "D": "groupBy"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些函数都是集合操作中常用的高阶函数。"
  },
  {
    "id": 1015,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中定义注解的关键字是？",
    "options": {
      "A": "annotation class",
      "B": "@annotation",
      "C": "@interface",
      "D": "annotation"
    },
    "answer": [
      "A"
    ],
    "explanation": "annotation class 关键字用于定义注解。"
  },
  {
    "id": 1016,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是反射API的用途？",
    "options": {
      "A": "运行时获取类信息",
      "B": "动态创建对象",
      "C": "调用私有方法",
      "D": "代码生成"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "反射API主要用于运行时操作，代码生成通常使用注解处理器。"
  },
  {
    "id": 1017,
    "type": "single",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中用于模式匹配的关键字是？",
    "options": {
      "A": "match",
      "B": "switch",
      "C": "case",
      "D": "pattern"
    },
    "answer": [
      "A"
    ],
    "explanation": "match 关键字用于模式匹配，可以替代复杂的if-else链。"
  },
  {
    "id": 1018,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是智能类型转换的条件？",
    "options": {
      "A": "使用is检查类型后",
      "B": "在when表达式分支中",
      "C": "编译器能够推断类型时",
      "D": "使用as强制转换后"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "在这些情况下，仓颉语言会自动进行智能类型转换，无需显式转换。"
  },
  {
    "id": 1019,
    "type": "single",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中表示任意类型的根类型是？",
    "options": {
      "A": "Any",
      "B": "Object",
      "C": "Root",
      "D": "Base"
    },
    "answer": [
      "A"
    ],
    "explanation": "Any 是所有类型的超类，类似于Java中的Object。"
  },
  {
    "id": 1020,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是泛型型变的方式？",
    "options": {
      "A": "声明处型变",
      "B": "使用处型变",
      "C": "类型投影",
      "D": "星投影"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持多种泛型型变方式，包括声明处型变、使用处型变、类型投影和星投影。"
  },
  {
    "id": 1021,
    "type": "single",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中尾递归优化的关键字是？",
    "options": {
      "A": "tailrec",
      "B": "inline",
      "C": "recursive",
      "D": "optimize"
    },
    "answer": [
      "A"
    ],
    "explanation": "tailrec 关键字用于标记尾递归函数，编译器会将其优化为迭代形式。"
  },
  {
    "id": 1022,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是Lambda表达式的特性？",
    "options": {
      "A": "简洁的语法",
      "B": "类型推断",
      "C": "可以访问外部变量",
      "D": "支持SAM转换"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Lambda表达式具有简洁语法、类型推断、可以访问外部变量，并支持SAM转换。"
  },
  {
    "id": 1023,
    "type": "single",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中伴生对象的访问方式是？",
    "options": {
      "A": "ClassName",
      "B": "ClassName.Companion",
      "C": "Companion",
      "D": "static"
    },
    "answer": [
      "A"
    ],
    "explanation": "伴生对象的成员可以直接通过类名访问，无需通过实例。"
  },
  {
    "id": 1024,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是数据类的自动生成方法？",
    "options": {
      "A": "equals()",
      "B": "hashCode()",
      "C": "toString()",
      "D": "copy()"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据类自动生成equals()、hashCode()、toString()和copy()方法。"
  },
  {
    "id": 1025,
    "type": "single",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中用于异步计算的函数是？",
    "options": {
      "A": "async",
      "B": "launch",
      "C": "spawn",
      "D": "future"
    },
    "answer": [
      "A"
    ],
    "explanation": "async 函数用于启动返回Deferred结果的异步计算。"
  },
  {
    "id": 1026,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是结构化并发的优势？",
    "options": {
      "A": "自动取消传播",
      "B": "避免协程泄漏",
      "C": "简化错误处理",
      "D": "提高性能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "结构化并发提供自动取消传播、避免协程泄漏和简化错误处理等优势。"
  },
  {
    "id": 1027,
    "type": "single",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中软引用的主要用途是？",
    "options": {
      "A": "缓存实现",
      "B": "避免循环引用",
      "C": "提高访问速度",
      "D": "减少内存占用"
    },
    "answer": [
      "A"
    ],
    "explanation": "软引用常用于缓存实现，在内存不足时会被回收。"
  },
  {
    "id": 1028,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是内存优化的策略？",
    "options": {
      "A": "使用基本类型数组",
      "B": "避免装箱操作",
      "C": "使用对象池",
      "D": "减少对象创建"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些策略都可以帮助优化内存使用，提高程序性能。"
  },
  {
    "id": 1029,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中用于正则表达式匹配的类是？",
    "options": {
      "A": "Regex",
      "B": "Pattern",
      "C": "RegExp",
      "D": "Matcher"
    },
    "answer": [
      "A"
    ],
    "explanation": "Regex 类用于正则表达式匹配操作。"
  },
  {
    "id": 1030,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是序列操作的优化策略？",
    "options": {
      "A": "流水线操作",
      "B": "惰性求值",
      "C": "中间结果缓存",
      "D": "并行处理"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "序列通过流水线操作和惰性求值来优化性能，避免不必要的计算。"
  },
  {
    "id": 1031,
    "type": "single",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中类型投影的关键字是？",
    "options": {
      "A": "out",
      "B": "in",
      "C": "projected",
      "D": "variant"
    },
    "answer": [
      "A"
    ],
    "explanation": "out 关键字用于协变类型投影。"
  },
  {
    "id": 1032,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是DSL构建的特性？",
    "options": {
      "A": "中缀函数",
      "B": "运算符重载",
      "C": "扩展函数",
      "D": "带接收者的Lambda"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些特性都支持领域特定语言(DSL)的构建，使代码更加表达性强。"
  },
  {
    "id": 1033,
    "type": "single",
    "category": "语法基础",
    "difficulty": "困难",
    "question": "仓颉语言中带标签的break语句可以跳出多少层循环？",
    "options": {
      "A": "只能跳出当前循环",
      "B": "只能跳出两层循环",
      "C": "可以跳出任意层循环",
      "D": "不能跳出循环"
    },
    "answer": [
      "C"
    ],
    "explanation": "带标签的break可以跳出任意层嵌套循环，提供了更灵活的控制流。"
  },
  {
    "id": 1034,
    "type": "multiple",
    "category": "语法基础",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是有效的数字字面量格式？",
    "options": {
      "A": "使用下划线分隔",
      "B": "十六进制表示",
      "C": "二进制表示",
      "D": "科学计数法"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言支持多种数字字面量格式，提高代码的可读性和灵活性。"
  },
  {
    "id": 1035,
    "type": "single",
    "category": "数据类型",
    "difficulty": "简单",
    "question": "仓颉语言中表示布尔值的类型是？",
    "options": {
      "A": "Boolean",
      "B": "Bool",
      "C": "boolean",
      "D": "bit"
    },
    "answer": [
      "A"
    ],
    "explanation": "Boolean 类型表示布尔值true或false。"
  },
  {
    "id": 1036,
    "type": "multiple",
    "category": "数据类型",
    "difficulty": "中等",
    "question": "仓颉语言中哪些集合类型是有序的？",
    "options": {
      "A": "List",
      "B": "Set",
      "C": "Array",
      "D": "Map"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "List和Array是有序集合，Set是无序集合，Map是键值对集合。"
  },
  {
    "id": 1037,
    "type": "single",
    "category": "函数编程",
    "difficulty": "简单",
    "question": "仓颉语言中Lambda表达式的语法是？",
    "options": {
      "A": "{参数 -> 表达式}",
      "B": "(参数) -> 表达式",
      "C": "参数 => 表达式",
      "D": "函数(参数) = 表达式"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言使用{参数 -> 表达式}语法定义Lambda表达式。"
  },
  {
    "id": 1038,
    "type": "multiple",
    "category": "函数编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是高阶函数的应用场景？",
    "options": {
      "A": "集合处理",
      "B": "回调函数",
      "C": "策略模式",
      "D": "模板方法"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "高阶函数在集合处理、回调和策略模式等场景中非常有用。"
  },
  {
    "id": 1039,
    "type": "single",
    "category": "面向对象",
    "difficulty": "简单",
    "question": "仓颉语言中实例化对象的方式是？",
    "options": {
      "A": "ClassName()",
      "B": "new ClassName()",
      "C": "ClassName.new()",
      "D": "create ClassName()"
    },
    "answer": [
      "A"
    ],
    "explanation": "仓颉语言直接使用类名加括号实例化对象，不需要new关键字。"
  },
  {
    "id": 1040,
    "type": "multiple",
    "category": "面向对象",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是对象表达式的用途？",
    "options": {
      "A": "创建匿名对象",
      "B": "实现接口",
      "C": "扩展类",
      "D": "替代Lambda表达式"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "对象表达式用于创建匿名对象、实现接口和扩展类。"
  },
  {
    "id": 1041,
    "type": "single",
    "category": "并发编程",
    "difficulty": "简单",
    "question": "仓颉语言中协程上下文包含的主要元素是？",
    "options": {
      "A": "调度器",
      "B": "作业",
      "C": "异常处理器",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "协程上下文包含调度器、作业、异常处理器等元素。"
  },
  {
    "id": 1042,
    "type": "multiple",
    "category": "并发编程",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是原子操作的类型？",
    "options": {
      "A": "AtomicInt",
      "B": "AtomicReference",
      "C": "AtomicBoolean",
      "D": "AtomicLong"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "仓颉语言提供多种原子类型，支持线程安全的操作。"
  },
  {
    "id": 1043,
    "type": "single",
    "category": "内存管理",
    "difficulty": "简单",
    "question": "仓颉语言中对象分配的主要区域是？",
    "options": {
      "A": "堆",
      "B": "栈",
      "C": "方法区",
      "D": "直接内存"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象主要分配在堆内存中，由垃圾回收器管理。"
  },
  {
    "id": 1044,
    "type": "multiple",
    "category": "内存管理",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是内存泄漏的检测方法？",
    "options": {
      "A": "堆转储分析",
      "B": "内存分析器",
      "C": "引用跟踪",
      "D": "日志分析"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "堆转储分析、内存分析器和引用跟踪是检测内存泄漏的有效方法。"
  },
  {
    "id": 1045,
    "type": "single",
    "category": "标准库使用",
    "difficulty": "简单",
    "question": "仓颉语言中用于文件读写的类是？",
    "options": {
      "A": "File",
      "B": "Files",
      "C": "FileSystem",
      "D": "IO"
    },
    "answer": [
      "A"
    ],
    "explanation": "File 类用于文件读写操作。"
  },
  {
    "id": 1046,
    "type": "multiple",
    "category": "标准库使用",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是集合的聚合操作？",
    "options": {
      "A": "sum",
      "B": "average",
      "C": "min",
      "D": "max"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些函数用于计算集合的聚合值，如总和、平均值、最小值和最大值。"
  },
  {
    "id": 1047,
    "type": "single",
    "category": "高级特性",
    "difficulty": "简单",
    "question": "仓颉语言中定义类型别名的关键字是？",
    "options": {
      "A": "type",
      "B": "alias",
      "C": "typedef",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "type 关键字用于定义类型别名，提高代码可读性。"
  },
  {
    "id": 1048,
    "type": "multiple",
    "category": "高级特性",
    "difficulty": "中等",
    "question": "仓颉语言中哪些是注解处理器的应用场景？",
    "options": {
      "A": "代码生成",
      "B": "编译时验证",
      "C": "依赖注入",
      "D": "运行时优化"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "注解处理器主要用于代码生成、编译时验证和依赖注入等场景。"
  },
  {
    "id": 1049,
    "type": "single",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "在仓颉语言中实现响应式编程的最佳方式是？",
    "options": {
      "A": "使用Flow API",
      "B": "使用回调函数",
      "C": "使用事件总线",
      "D": "使用观察者模式"
    },
    "answer": [
      "A"
    ],
    "explanation": "Flow API是仓颉语言中实现响应式编程的推荐方式，提供背压支持和丰富的操作符。"
  },
  {
    "id": 1050,
    "type": "multiple",
    "category": "综合应用",
    "difficulty": "困难",
    "question": "仓颉语言中哪些是微服务架构的最佳实践？",
    "options": {
      "A": "使用HTTP客户端",
      "B": "实现熔断器模式",
      "C": "使用配置管理",
      "D": "实现服务发现"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "这些都是在微服务架构中重要的实践，仓颉语言都提供了良好的支持。"
  },
  {
    "id": 1051,
    "type": "single",
    "category": "综合应用",
    "difficulty": "中等",
    "question": "在仓颉语言中实现单例模式的最佳方式是？",
    "options": {
      "A": "使用对象声明",
      "B": "使用双重检查锁",
      "C": "使用静态内部类",
      "D": "使用枚举"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象声明是仓颉语言中实现单例模式最简洁和安全的方式。"
  }
]