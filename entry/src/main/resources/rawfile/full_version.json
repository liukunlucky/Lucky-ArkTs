[
  {
    "id": 1,
    "type": "single",
    "category": "基础概念",
    "difficulty": "简单",
    "question": "ArkTS是基于哪种语言开发的？",
    "options": {
      "A": "Java",
      "B": "Python",
      "C": "TypeScript",
      "D": "C++"
    },
    "answer": [
      "C"
    ],
    "explanation": "ArkTS是在TypeScript基础上，为鸿蒙生态扩展了声明式UI等能力的开发语言。"
  },
  {
    "id": 2,
    "type": "single",
    "category": "基础概念",
    "difficulty": "简单",
    "question": "ArkTS主要用于开发什么类型的应用？",
    "options": {
      "A": "Web网页应用",
      "B": "鸿蒙原生应用",
      "C": "Android应用",
      "D": "iOS应用"
    },
    "answer": [
      "B"
    ],
    "explanation": "ArkTS是鸿蒙生态的主力应用开发语言，专门用于开发鸿蒙原生应用。"
  },
  {
    "id": 3,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "在ArkTS中，哪个装饰器用于定义组件内的私有状态？",
    "options": {
      "A": "@Component",
      "B": "@State",
      "C": "@Prop",
      "D": "@Link"
    },
    "answer": [
      "B"
    ],
    "explanation": "@State装饰器用于定义组件内部的状态，当状态变化时会触发UI更新。"
  },
  {
    "id": 4,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "ArkTS采用什么UI开发范式？",
    "options": {
      "A": "命令式UI",
      "B": "面向对象UI",
      "C": "声明式UI",
      "D": "函数式UI"
    },
    "answer": [
      "C"
    ],
    "explanation": "ArkTS采用声明式UI范式，开发者只需要描述UI应该是什么样子，而不是如何一步步构建UI。"
  },
  {
    "id": 5,
    "type": "multiple",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "以下哪些是TypeScript/ArkTS的基本数据类型？",
    "options": {
      "A": "string",
      "B": "number",
      "C": "boolean",
      "D": "any"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS支持string、number、boolean、any等TypeScript的所有基本数据类型。"
  },
  {
    "id": 6,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "在ArkTS中，构建UI的必需方法是什么？",
    "options": {
      "A": "create()",
      "B": "build()",
      "C": "render()",
      "D": "construct()"
    },
    "answer": [
      "B"
    ],
    "explanation": "每个ArkTS组件都必须实现build()方法，用于描述UI的结构和布局。"
  },
  {
    "id": 7,
    "type": "single",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "哪个装饰器用于创建自定义组件？",
    "options": {
      "A": "@State",
      "B": "@Component",
      "C": "@Entry",
      "D": "@Builder"
    },
    "answer": [
      "B"
    ],
    "explanation": "@Component装饰器用于定义自定义组件，这是ArkTS UI开发的基础。"
  },
  {
    "id": 8,
    "type": "single",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "哪个装饰器表示应用的主入口组件？",
    "options": {
      "A": "@Component",
      "B": "@Main",
      "C": "@Entry",
      "D": "@App"
    },
    "answer": [
      "C"
    ],
    "explanation": "@Entry装饰器用于标记应用的主入口组件，每个应用有且仅有一个@Entry组件。"
  },
  {
    "id": 9,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "以下哪些装饰器可以用于状态管理？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Link",
      "D": "@Watch"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "@State、@Prop、@Link都是状态管理装饰器，@Watch不是ArkTS的标准装饰器。"
  },
  {
    "id": 10,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "哪个装饰器用于从父组件单向同步数据？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Link",
      "D": "@Provide"
    },
    "answer": [
      "B"
    ],
    "explanation": "@Prop装饰器用于从父组件单向同步数据到子组件，子组件不能修改@Prop变量。"
  },
  {
    "id": 11,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "哪个装饰器用于与父组件双向绑定数据？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Link",
      "D": "@Consume"
    },
    "answer": [
      "C"
    ],
    "explanation": "@Link装饰器实现父子组件之间的双向数据绑定，任何一方的修改都会同步到另一方。"
  },
  {
    "id": 12,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "ArkTS支持哪些布局容器？",
    "options": {
      "A": "Column",
      "B": "Row",
      "C": "Stack",
      "D": "Grid"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "ArkTS提供Column（垂直布局）、Row（水平布局）、Stack（堆叠布局）等基础布局容器。"
  },
  {
    "id": 13,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "在Column布局中，如何设置子组件在主轴上的对齐方式？",
    "options": {
      "A": "alignItems",
      "B": "justifyContent",
      "C": "alignContent",
      "D": "mainAxisAlign"
    },
    "answer": [
      "B"
    ],
    "explanation": "justifyContent属性用于设置主轴（Column中是垂直方向）上的对齐方式。"
  },
  {
    "id": 14,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "如何设置组件的宽度为100%？",
    "options": {
      "A": "width(100)",
      "B": "width('100%')",
      "C": "width('full')",
      "D": "width(1.0)"
    },
    "answer": [
      "B"
    ],
    "explanation": "在ArkTS中，使用字符串形式设置百分比宽度，如width('100%')。"
  },
  {
    "id": 15,
    "type": "single",
    "category": "渲染控制",
    "difficulty": "中等",
    "question": "如何实现条件渲染？",
    "options": {
      "A": "if-else语句",
      "B": "switch语句",
      "C": "三元运算符",
      "D": "if-else在build方法中直接使用"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS支持在build方法中直接使用if-else语句进行条件渲染。"
  },
  {
    "id": 16,
    "type": "single",
    "category": "渲染控制",
    "difficulty": "中等",
    "question": "用于循环渲染的API是什么？",
    "options": {
      "A": "ForEach",
      "B": "for循环",
      "C": "map函数",
      "D": "while循环"
    },
    "answer": [
      "A"
    ],
    "explanation": "ForEach是ArkTS中专门用于循环渲染数组数据的API。"
  },
  {
    "id": 17,
    "type": "multiple",
    "category": "组件通信",
    "difficulty": "困难",
    "question": "以下哪些装饰器可以用于跨组件层级的数据传递？",
    "options": {
      "A": "@Provide",
      "B": "@Consume",
      "C": "@StorageLink",
      "D": "@StorageProp"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "@Provide/@Consume用于组件树内跨层级传递，@StorageLink/@StorageProp用于与AppStorage双向/单向同步。"
  },
  {
    "id": 18,
    "type": "single",
    "category": "生命周期",
    "difficulty": "中等",
    "question": "组件首次创建时调用的生命周期函数是？",
    "options": {
      "A": "aboutToAppear",
      "B": "aboutToDisappear",
      "C": "onPageShow",
      "D": "onPageHide"
    },
    "answer": [
      "A"
    ],
    "explanation": "aboutToAppear在组件创建后、build之前调用，用于初始化操作。"
  },
  {
    "id": 19,
    "type": "single",
    "category": "生命周期",
    "difficulty": "中等",
    "question": "组件销毁前调用的生命周期函数是？",
    "options": {
      "A": "aboutToAppear",
      "B": "aboutToDisappear",
      "C": "onDestroy",
      "D": "onDisappear"
    },
    "answer": [
      "B"
    ],
    "explanation": "aboutToDisappear在组件销毁前调用，用于清理资源。"
  },
  {
    "id": 20,
    "type": "single",
    "category": "事件处理",
    "difficulty": "简单",
    "question": "如何处理按钮的点击事件？",
    "options": {
      "A": "onPress",
      "B": "onClick",
      "C": "onTap",
      "D": "onTouch"
    },
    "answer": [
      "B"
    ],
    "explanation": "Button组件使用onClick回调函数处理点击事件。"
  },
  {
    "id": 21,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置文本的字体大小？",
    "options": {
      "A": "textSize(20)",
      "B": "fontSize(20)",
      "C": "size(20)",
      "D": "font(20)"
    },
    "answer": [
      "B"
    ],
    "explanation": "Text组件使用fontSize方法设置字体大小。"
  },
  {
    "id": 22,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "以下哪些是Text组件支持的样式属性？",
    "options": {
      "A": "fontColor",
      "B": "fontSize",
      "C": "fontWeight",
      "D": "textAlign"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Text组件支持fontColor、fontSize、fontWeight、textAlign等丰富的文本样式属性。"
  },
  {
    "id": 23,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "在ArkTS中发起HTTP请求应该使用什么模块？",
    "options": {
      "A": "http",
      "B": "fetch",
      "C": "request",
      "D": "HttpRequest"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS使用@ohos.net.http模块中的http类来发起HTTP请求。"
  },
  {
    "id": 24,
    "type": "single",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "哪个装饰器用于与AppStorage进行双向同步？",
    "options": {
      "A": "@StorageProp",
      "B": "@StorageLink",
      "C": "@LocalStorage",
      "D": "@AppStorage"
    },
    "answer": [
      "B"
    ],
    "explanation": "@StorageLink装饰器用于与AppStorage进行双向数据同步。"
  },
  {
    "id": 25,
    "type": "single",
    "category": "异步编程",
    "difficulty": "中等",
    "question": "在ArkTS中如何处理异步操作？",
    "options": {
      "A": "async/await",
      "B": "Promise",
      "C": "回调函数",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS支持async/await、Promise和回调函数等多种异步编程方式。"
  },
  {
    "id": 26,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "如何定义一个可选的函数参数？",
    "options": {
      "A": "param?: string",
      "B": "param: string?",
      "C": "optional param: string",
      "D": "param: optional string"
    },
    "answer": [
      "A"
    ],
    "explanation": "TypeScript/ArkTS中使用问号(?)表示可选参数：param?: string。"
  },
  {
    "id": 27,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "如何定义一个接口？",
    "options": {
      "A": "interface User {}",
      "B": "class User {}",
      "C": "type User = {}",
      "D": "struct User {}"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用interface关键字定义接口：interface User { name: string; age: number; }"
  },
  {
    "id": 28,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是ArkTS支持的组件复用方式？",
    "options": {
      "A": "@Component",
      "B": "@Builder",
      "C": "@Extend",
      "D": "@Style"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "@Component用于自定义组件，@Builder用于复用UI描述，@Extend用于扩展组件样式。"
  },
  {
    "id": 29,
    "type": "single",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "@Builder装饰器用于什么目的？",
    "options": {
      "A": "构建函数",
      "B": "复用UI描述",
      "C": "构建布局",
      "D": "构建动画"
    },
    "explanation": "@Builder装饰的方法用于封装UI描述，实现UI的复用。"
  },
  {
    "id": 30,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "在ArkTS中创建属性动画使用什么API？",
    "options": {
      "A": "animateTo",
      "B": "animation",
      "C": "createAnimation",
      "D": "PropertyAnimation"
    },
    "answer": [
      "A"
    ],
    "explanation": "animateTo是ArkTS中用于创建属性动画的主要API。"
  },
  {
    "id": 31,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何进行页面跳转？",
    "options": {
      "A": "router.push()",
      "B": "navigator.push()",
      "C": "Router.pushUrl()",
      "D": "Navigation.push()"
    },
    "answer": [
      "C"
    ],
    "explanation": "使用Router.pushUrl()方法进行页面路由跳转。"
  },
  {
    "id": 32,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "哪个装饰器可以避免不必要的组件重新渲染？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Link",
      "D": "@ObjectLink"
    },
    "answer": [
      "D"
    ],
    "explanation": "@ObjectLink用于观察对象内部属性的变化，避免整个对象变化导致的重新渲染。"
  },
  {
    "id": 33,
    "type": "multiple",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "以下哪些是TypeScript/ArkTS中的高级类型？",
    "options": {
      "A": "联合类型",
      "B": "交叉类型",
      "C": "字面量类型",
      "D": "条件类型"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TypeScript/ArkTS支持联合类型、交叉类型、字面量类型、条件类型等高级类型特性。"
  },
  {
    "id": 34,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义一个泛型函数？",
    "options": {
      "A": "function identity<T>(arg: T): T {}",
      "B": "function identity<T>(arg: T) {}",
      "C": "function identity(arg: T): T {}",
      "D": "function identity<T>(arg: any): T {}"
    },
    "answer": [
      "A"
    ],
    "explanation": "泛型函数在函数名后使用<T>定义类型参数：function identity<T>(arg: T): T { return arg; }"
  },
  {
    "id": 35,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "如何设置组件的点击事件？",
    "options": {
      "A": "onTouch",
      "B": "onPress",
      "C": "onClick",
      "D": "onTap"
    },
    "answer": [
      "C"
    ],
    "explanation": "大部分组件都支持onClick事件来处理点击交互。"
  },
  {
    "id": 36,
    "type": "single",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "List组件的哪个属性用于设置列表项？",
    "options": {
      "A": "items",
      "B": "data",
      "C": "listData",
      "D": "array"
    },
    "answer": [
      "A"
    ],
    "explanation": "List组件使用items属性接收数组数据，用于渲染列表项。"
  },
  {
    "id": 37,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "以下哪些状态管理方式可以持久化数据？",
    "options": {
      "A": "@State",
      "B": "AppStorage",
      "C": "PersistentStorage",
      "D": "LocalStorage"
    },
    "answer": [
      "B",
      "C"
    ],
    "explanation": "AppStorage和PersistentStorage支持数据持久化，@State和LocalStorage是内存级别的状态管理。"
  },
  {
    "id": 38,
    "type": "single",
    "category": "调试开发",
    "difficulty": "简单",
    "question": "在ArkTS中如何输出调试信息？",
    "options": {
      "A": "console.log()",
      "B": "print()",
      "C": "Logger.info()",
      "D": "Log.i()"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS支持标准的console.log()、console.warn()、console.error()等调试输出方法。"
  },
  {
    "id": 39,
    "type": "single",
    "category": "组件通信",
    "difficulty": "中等",
    "question": "子组件如何向父组件传递事件？",
    "options": {
      "A": "@Prop",
      "B": "@Link",
      "C": "@State",
      "D": "自定义事件"
    },
    "answer": [
      "D"
    ],
    "explanation": "子组件通过定义自定义事件（回调函数）的方式向父组件传递事件和数据。"
  },
  {
    "id": 40,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "如何定义一个箭头函数？",
    "options": {
      "A": "function() => {}",
      "B": "() => {}",
      "C": "=> {}",
      "D": "arrow function() {}"
    },
    "answer": [
      "B"
    ],
    "explanation": "箭头函数使用() => {}语法定义。"
  },
  {
    "id": 41,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是ArkTS支持的文本输入组件？",
    "options": {
      "A": "TextInput",
      "B": "TextField",
      "C": "TextArea",
      "D": "Input"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "ArkTS提供TextInput（单行输入）和TextArea（多行输入）两种文本输入组件。"
  },
  {
    "id": 42,
    "type": "single",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "如何获取TextInput的输入内容？",
    "options": {
      "A": "onTextChange",
      "B": "onChange",
      "C": "onInput",
      "D": "onTextInput"
    },
    "answer": [
      "B"
    ],
    "explanation": "TextInput使用onChange事件回调来获取输入内容的变化。"
  },
  {
    "id": 43,
    "type": "single",
    "category": "资源管理",
    "difficulty": "简单",
    "question": "如何引用字符串资源？",
    "options": {
      "A": "$r('app.string.hello')",
      "B": "Resource.string.hello",
      "C": "R.string.hello",
      "D": "$string.hello"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS使用$r('app.string.hello')语法来引用字符串资源。"
  },
  {
    "id": 44,
    "type": "single",
    "category": "资源管理",
    "difficulty": "简单",
    "question": "如何引用图片资源？",
    "options": {
      "A": "$r('app.media.icon')",
      "B": "Resource.media.icon",
      "C": "R.drawable.icon",
      "D": "$media.icon"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS使用统一的$r语法引用各种资源，包括图片：$r('app.media.icon')。"
  },
  {
    "id": 45,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是Flex布局的主要属性？",
    "options": {
      "A": "justifyContent",
      "B": "alignItems",
      "C": "flexDirection",
      "D": "flexWrap"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Flex布局支持justifyContent（主轴对齐）、alignItems（交叉轴对齐）、flexDirection（主轴方向）、flexWrap（换行）等属性。"
  },
  {
    "id": 46,
    "type": "single",
    "category": "手势处理",
    "difficulty": "中等",
    "question": "如何处理滑动手势？",
    "options": {
      "A": "onSwipe",
      "B": "onPan",
      "C": "onGesture",
      "D": "gesture"
    },
    "answer": [
      "B"
    ],
    "explanation": "ArkTS使用gesture(GestureGroup(GesturePriority.Low,PanGesture(...)))来处理滑动等复杂手势。"
  },
  {
    "id": 47,
    "type": "single",
    "category": "主题样式",
    "difficulty": "中等",
    "question": "如何设置应用的主题色？",
    "options": {
      "A": "Theme.setColor()",
      "B": "ThemeManager.setTheme()",
      "C": "在resources/base/profile/theme.json中配置",
      "D": "App.setTheme()"
    },
    "answer": [
      "C"
    ],
    "explanation": "鸿蒙应用的主题色在resources/base/profile/theme.json配置文件中定义。"
  },
  {
    "id": 48,
    "type": "single",
    "category": "包管理",
    "difficulty": "简单",
    "question": "如何导入其他模块？",
    "options": {
      "A": "import",
      "B": "require",
      "C": "include",
      "D": "using"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS使用ES6的import语法导入其他模块：import { something } from '@ohos/some-module'"
  },
  {
    "id": 49,
    "type": "multiple",
    "category": "错误处理",
    "difficulty": "中等",
    "question": "ArkTS支持哪些错误处理机制？",
    "options": {
      "A": "try-catch",
      "B": "throw",
      "C": "Error边界",
      "D": "Promise.catch"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "ArkTS支持try-catch、throw和Promise.catch等错误处理机制，但没有React中的Error边界概念。"
  },
  {
    "id": 50,
    "type": "single",
    "category": "最佳实践",
    "difficulty": "困难",
    "question": "在大型项目中，推荐使用什么方式进行状态管理？",
    "options": {
      "A": "全局@State变量",
      "B": "AppStorage",
      "C": "Redux模式",
      "D": "自定义状态管理类"
    },
    "explanation": "在大型项目中，推荐使用AppStorage进行全局状态管理，结合@StorageLink/@StorageProp实现数据响应式更新。"
  },
  {
    "id": 51,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建一个可复用的自定义组件？",
    "options": {
      "A": "使用 @Component 装饰器",
      "B": "使用 @Custom 装饰器",
      "C": "使用 function 关键字",
      "D": "使用 class 关键字"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Component 装饰器用于定义自定义组件，这是创建可复用UI组件的基础。"
  },
  {
    "id": 52,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "以下关于 @State 和 @Link 的区别，哪些是正确的？",
    "options": {
      "A": "@State 是组件内部状态，@Link 用于父子组件双向绑定",
      "B": "@State 变化会触发UI更新，@Link 不会",
      "C": "@Link 变量不需要初始化，@State 需要",
      "D": "@State 只能用于基础数据类型，@Link 可以用于对象"
    },
    "answer": [
      "A"
    ],
    "explanation": "@State 用于组件内部状态管理，变化会触发UI更新；@Link 用于父子组件间的双向数据绑定，两者变化都会相互同步。"
  },
  {
    "id": 53,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "如何设置组件的背景颜色？",
    "options": {
      "A": "background(color: '#ff0000')",
      "B": "backgroundColor('#ff0000')",
      "C": "background('#ff0000')",
      "D": "bgColor('#ff0000')"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 backgroundColor() 方法设置组件的背景颜色。"
  },
  {
    "id": 54,
    "type": "single",
    "category": "布局",
    "difficulty": "中等",
    "question": "在 Row 布局中，如何设置子组件在交叉轴上的对齐方式？",
    "options": {
      "A": "justifyContent",
      "B": "alignItems",
      "C": "alignContent",
      "D": "crossAxisAlign"
    },
    "answer": [
      "B"
    ],
    "explanation": "alignItems 属性用于设置交叉轴（Row中是垂直方向）上的对齐方式。"
  },
  {
    "id": 55,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 支持的手势事件？",
    "options": {
      "A": "点击 (Tap)",
      "B": "长按 (LongPress)",
      "C": "拖拽 (Pan)",
      "D": "捏合 (Pinch)"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 支持丰富的手势事件，包括点击、长按、拖拽、捏合等常见手势。"
  },
  {
    "id": 56,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建一个简单的缩放动画？",
    "options": {
      "A": "scale({ x: 1.5, y: 1.5 })",
      "B": "transform: scale(1.5)",
      "C": "animation: scale 1.5",
      "D": "animateScale(1.5)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 scale() 方法并传入包含 x 和 y 缩放比例的参数对象来创建缩放动画。"
  },
  {
    "id": 57,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "发起 HTTP GET 请求的正确方式是什么？",
    "options": {
      "A": "http.request('GET', url)",
      "B": "http.get(url)",
      "C": "fetch(url)",
      "D": "request.get(url)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 @ohos.net.http 模块的 http.request() 方法，指定方法为 'GET' 来发起请求。"
  },
  {
    "id": 58,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中数据持久化的方式？",
    "options": {
      "A": "AppStorage",
      "B": "PersistentStorage",
      "C": "LocalStorage",
      "D": "Preferences"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "AppStorage、PersistentStorage 和 Preferences 都支持数据持久化，LocalStorage 是页面级的内存状态管理。"
  },
  {
    "id": 59,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何返回到上一个页面？",
    "options": {
      "A": "Router.back()",
      "B": "Router.pop()",
      "C": "Router.goBack()",
      "D": "Router.backUrl()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Router.back() 方法返回到上一个页面。"
  },
  {
    "id": 60,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "哪个装饰器可以优化类对象的性能，避免不必要的重新渲染？",
    "options": {
      "A": "@State",
      "B": "@Observed",
      "C": "@ObjectLink",
      "D": "@Track"
    },
    "answer": [
      "C"
    ],
    "explanation": "@ObjectLink 装饰器用于观察类对象的属性变化，当只有对象内部属性变化时，不会导致整个对象重新渲染，从而优化性能。"
  },
  {
    "id": 61,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "如何定义一个只读数组？",
    "options": {
      "A": "const arr: number[] = [1,2,3]",
      "B": "readonly arr: number[] = [1,2,3]",
      "C": "let arr: ReadonlyArray<number> = [1,2,3]",
      "D": "var arr: fixed number[] = [1,2,3]"
    },
    "answer": [
      "C"
    ],
    "explanation": "使用 TypeScript 的 ReadonlyArray<T> 类型来定义只读数组。"
  },
  {
    "id": 62,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 List 组件的必需属性？",
    "options": {
      "A": "items",
      "B": "itemGenerator",
      "C": "space",
      "D": "divider"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "List 组件必须设置 items（数据源）和 itemGenerator（列表项生成器）属性。"
  },
  {
    "id": 63,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置组件的圆角？",
    "options": {
      "A": "cornerRadius(10)",
      "B": "borderRadius(10)",
      "C": "roundCorner(10)",
      "D": "radius(10)"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 borderRadius() 方法设置组件的圆角半径。"
  },
  {
    "id": 64,
    "type": "single",
    "category": "组件通信",
    "difficulty": "困难",
    "question": "@Provide 和 @Consume 装饰器的主要作用是什么？",
    "options": {
      "A": "父子组件间双向绑定",
      "B": "跨组件层级的数据传递",
      "C": "组件内部状态管理",
      "D": "全局状态管理"
    },
    "answer": [
      "B"
    ],
    "explanation": "@Provide 和 @Consume 用于在组件树中跨层级传递数据，无需通过中间组件逐层传递。"
  },
  {
    "id": 65,
    "type": "multiple",
    "category": "异步编程",
    "difficulty": "中等",
    "question": "以下哪些关于 Promise 的说法是正确的？",
    "options": {
      "A": "Promise 有三种状态：pending、fulfilled、rejected",
      "B": "then() 方法用于处理成功状态",
      "C": "catch() 方法用于处理失败状态",
      "D": "Promise 创建后状态不可改变"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Promise 有 pending、fulfilled、rejected 三种状态，then()处理成功，catch()处理失败，状态可以从pending变为fulfilled或rejected。"
  },
  {
    "id": 66,
    "type": "single",
    "category": "调试开发",
    "difficulty": "简单",
    "question": "如何输出错误级别的日志？",
    "options": {
      "A": "console.error()",
      "B": "console.warn()",
      "C": "console.log()",
      "D": "console.debug()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 console.error() 方法输出错误级别的日志信息。"
  },
  {
    "id": 67,
    "type": "single",
    "category": "资源管理",
    "difficulty": "中等",
    "question": "如何引用多语言字符串资源？",
    "options": {
      "A": "$r('app.string.hello')",
      "B": "$t('app.string.hello')",
      "C": "$i18n('app.string.hello')",
      "D": "$string('hello')"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 使用统一的 $r 语法引用各种资源，多语言字符串也是通过 $r('app.string.hello') 引用。"
  },
  {
    "id": 68,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是关于 Flex 布局的正确描述？",
    "options": {
      "A": "flexGrow 定义项目的放大比例",
      "B": "flexShrink 定义项目的缩小比例",
      "C": "flexBasis 定义项目在分配多余空间之前的主轴尺寸",
      "D": "flex 是 flexGrow、flexShrink 和 flexBasis 的简写"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Flex 布局支持 flexGrow（放大比例）、flexShrink（缩小比例）、flexBasis（初始尺寸）等属性，flex 是它们的简写形式。"
  },
  {
    "id": 69,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建关键帧动画？",
    "options": {
      "A": "using KeyframeAnimation",
      "B": "@keyframes 规则",
      "C": "createKeyframeAnimation()",
      "D": "ArkTS不支持关键帧动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 KeyframeAnimation 类来创建关键帧动画，定义不同时间点的样式状态。"
  },
  {
    "id": 70,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何处理 HTTP 请求的响应？",
    "options": {
      "A": "使用 then() 方法",
      "B": "使用 async/await",
      "C": "使用回调函数",
      "D": "以上都可以"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS 支持 Promise 的 then() 方法、async/await 语法和回调函数等多种方式处理异步HTTP响应。"
  },
  {
    "id": 71,
    "type": "single",
    "category": "数据存储",
    "difficulty": "简单",
    "question": "Preferences 持久化数据存储在哪里？",
    "options": {
      "A": "应用沙箱目录",
      "B": "系统公共目录",
      "C": "云端存储",
      "D": "内存中"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 数据存储在应用沙箱目录中，每个应用只能访问自己的数据。"
  },
  {
    "id": 72,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是 @Component 装饰器的参数？",
    "options": {
      "A": "struct",
      "B": "builder",
      "C": "customStyles",
      "D": "styles"
    },
    "answer": [
      "B",
      "C"
    ],
    "explanation": "@Component 装饰器可以接受 builder 和 customStyles 等参数，用于配置组件的构建器和样式。"
  },
  {
    "id": 73,
    "type": "single",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "如何设置文本的字体粗细？",
    "options": {
      "A": "fontWeight(FontWeight.Bold)",
      "B": "textWeight('bold')",
      "C": "weight('bold')",
      "D": "fontWeight('bold')"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 fontWeight() 方法并传入 FontWeight 枚举值来设置文本的字体粗细。"
  },
  {
    "id": 74,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何阻止事件冒泡？",
    "options": {
      "A": "event.stopPropagation()",
      "B": "event.preventDefault()",
      "C": "event.cancelBubble()",
      "D": "ArkTS不支持事件冒泡"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用事件对象的 stopPropagation() 方法来阻止事件冒泡。"
  },
  {
    "id": 75,
    "type": "multiple",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "以下哪些是 TypeScript 的类型断言方式？",
    "options": {
      "A": "<string>someValue",
      "B": "someValue as string",
      "C": "(string)someValue",
      "D": "string(someValue)"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "TypeScript 支持两种类型断言语法：尖括号语法 <string>someValue 和 as 语法 someValue as string。"
  },
  {
    "id": 76,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何避免不必要的组件重新渲染？",
    "options": {
      "A": "使用 @State 装饰器",
      "B": "使用 @ObjectLink 装饰器",
      "C": "使用 @Reactive 装饰器",
      "D": "使用 @Memo 装饰器"
    },
    "answer": [
      "B"
    ],
    "explanation": "@ObjectLink 装饰器可以观察对象内部属性的变化，避免整个对象变化导致的重新渲染，从而优化性能。"
  },
  {
    "id": 77,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何传递参数到目标页面？",
    "options": {
      "A": "Router.pushUrl({ url: 'page', params: { id: 1 } })",
      "B": "Router.pushUrl('page?id=1')",
      "C": "Router.pushUrl({ url: 'page', data: { id: 1 } })",
      "D": "Router.pushUrl('page', { id: 1 })"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Router.pushUrl() 方法的 params 属性来传递参数到目标页面。"
  },
  {
    "id": 78,
    "type": "multiple",
    "category": "动画",
    "difficulty": "中等",
    "question": "以下哪些是动画的常见属性？",
    "options": {
      "A": "duration",
      "B": "delay",
      "C": "iterations",
      "D": "curve"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "动画支持 duration（持续时间）、delay（延迟）、iterations（迭代次数）、curve（曲线）等属性配置。"
  },
  {
    "id": 79,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何设置 HTTP 请求超时时间？",
    "options": {
      "A": "在 request() 方法的 options 参数中设置",
      "B": "使用 setTimeout() 方法",
      "C": "在 http.createHttp() 时设置",
      "D": "ArkTS不支持设置超时时间"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 http.request() 方法的 options 参数中设置 readTimeout 和 connectTimeout 来控制超时时间。"
  },
  {
    "id": 80,
    "type": "single",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "如何删除 Preferences 中的一条数据？",
    "options": {
      "A": "preferences.delete()",
      "B": "preferences.remove()",
      "C": "preferences.clear()",
      "D": "preferences.erase()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Preferences 实例的 delete() 方法删除指定的数据项。"
  },
  {
    "id": 81,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义一个枚举类型？",
    "options": {
      "A": "enum Color { Red, Green, Blue }",
      "B": "const enum Color { Red, Green, Blue }",
      "C": "type Color = 'Red' | 'Green' | 'Blue'",
      "D": "interface Color { Red: number, Green: number, Blue: number }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 enum 关键字定义枚举类型：enum Color { Red, Green, Blue }"
  },
  {
    "id": 82,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Scroll 组件的常用属性？",
    "options": {
      "A": "scrollable",
      "B": "scrollBar",
      "C": "edgeEffect",
      "D": "onScroll"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Scroll 组件支持 scrollable（滚动方向）、scrollBar（滚动条）、edgeEffect（边缘效果）、onScroll（滚动事件）等属性。"
  },
  {
    "id": 83,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "@StorageLink 和 @StorageProp 的主要区别是什么？",
    "options": {
      "A": "@StorageLink 双向同步，@StorageProp 单向同步",
      "B": "@StorageLink 用于组件内，@StorageProp 用于组件间",
      "C": "@StorageLink 性能更好，@StorageProp 功能更强大",
      "D": "没有区别，可以互换使用"
    },
    "answer": [
      "A"
    ],
    "explanation": "@StorageLink 与 AppStorage 双向同步，组件内修改会同步到AppStorage；@StorageProp 是单向同步，组件内修改不会影响AppStorage。"
  },
  {
    "id": 84,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何为自定义组件定义必选参数？",
    "options": {
      "A": "使用 @Required 装饰器",
      "B": "在构造函数中定义",
      "C": "使用 @Param 装饰器",
      "D": "ArkTS没有必选参数的概念"
    },
    "answer": [
      "B"
    ],
    "explanation": "在自定义组件的构造函数中定义参数，调用时必须传入这些参数。"
  },
  {
    "id": 85,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 RelativeContainer 相对布局的支持的对齐方式？",
    "options": {
      "A": "alignRules",
      "B": "topToTop",
      "C": "startToStart",
      "D": "centerInParent"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "RelativeContainer 通过 alignRules 属性设置相对定位规则，支持 topToTop、startToStart、centerInParent 等多种对齐方式。"
  },
  {
    "id": 86,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建一个平移动画？",
    "options": {
      "A": "translate({ x: 100, y: 50 })",
      "B": "position(100, 50)",
      "C": "moveTo(100, 50)",
      "D": "translation(100, 50)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 translate() 方法并传入包含 x 和 y 平移距离的参数对象来创建平移动画。"
  },
  {
    "id": 87,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何设置 HTTP 请求头？",
    "options": {
      "A": "在 request() 方法的 header 参数中设置",
      "B": "使用 setHeader() 方法",
      "C": "在 createHttp() 时设置",
      "D": "ArkTS不支持设置请求头"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 http.request() 方法的 options 参数中设置 header 属性来配置请求头。"
  },
  {
    "id": 88,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是关于 PersistentStorage 的正确描述？",
    "options": {
      "A": "数据会持久化到设备存储",
      "B": "需要与 AppStorage 配合使用",
      "C": "支持所有数据类型",
      "D": "数据在应用重启后仍然存在"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "PersistentStorage 将数据持久化到设备存储，需要与AppStorage关联，数据在应用重启后仍然存在，但只支持基础数据类型。"
  },
  {
    "id": 89,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何获取当前页面的路由信息？",
    "options": {
      "A": "Router.getState()",
      "B": "Router.getCurrent()",
      "C": "Router.getActive()",
      "D": "Router.getCurrentRoute()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Router.getState() 方法获取当前的路由状态信息。"
  },
  {
    "id": 90,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何优化长列表的性能？",
    "options": {
      "A": "使用 LazyForEach",
      "B": "使用 ForEach",
      "C": "使用 map 函数",
      "D": "使用数组遍历"
    },
    "answer": [
      "A"
    ],
    "explanation": "LazyForEach 可以延迟创建列表项，只在需要时渲染，适合长列表性能优化。"
  },
  {
    "id": 91,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义一个类型别名？",
    "options": {
      "A": "type Point = { x: number, y: number }",
      "B": "interface Point = { x: number, y: number }",
      "C": "alias Point = { x: number, y: number }",
      "D": "typedef Point = { x: number, y: number }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 type 关键字定义类型别名：type Point = { x: number, y: number }"
  },
  {
    "id": 92,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "以下哪些是 Button 组件的常用属性？",
    "options": {
      "A": "type",
      "B": "stateEffect",
      "C": "backgroundColor",
      "D": "fontSize"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Button 组件支持 type（按钮类型）、stateEffect（状态效果）、backgroundColor（背景色）等属性，但不直接支持fontSize。"
  },
  {
    "id": 93,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Observed 装饰器的作用是什么？",
    "options": {
      "A": "标记类为可观察的",
      "B": "标记状态变量",
      "C": "标记组件",
      "D": "标记方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Observed 装饰器用于标记类，表示该类的属性变化需要被观察，通常与@ObjectLink配合使用。"
  },
  {
    "id": 94,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何定义组件的样式？",
    "options": {
      "A": "使用 @Styles 装饰器",
      "B": "在 build 方法中设置",
      "C": "使用 style 属性",
      "D": "在构造函数中设置"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 @Styles 装饰器定义可复用的组件样式。"
  },
  {
    "id": 95,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Grid 网格布局的常用属性？",
    "options": {
      "A": "columnsTemplate",
      "B": "rowsTemplate",
      "C": "columnsGap",
      "D": "rowsGap"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Grid 组件支持 columnsTemplate（列模板）、rowsTemplate（行模板）、columnsGap（列间距）、rowsGap（行间距）等属性。"
  },
  {
    "id": 96,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建旋转动画？",
    "options": {
      "A": "rotate({ angle: 45 })",
      "B": "rotation(45)",
      "C": "transform: rotate(45deg)",
      "D": "animateRotation(45)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 rotate() 方法并传入包含旋转角度的参数对象来创建旋转动画。"
  },
  {
    "id": 97,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何处理 HTTP 请求的错误？",
    "options": {
      "A": "使用 catch() 方法",
      "B": "使用 try-catch 语句",
      "C": "使用 onError 回调",
      "D": "以上都可以"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS 支持 Promise 的 catch() 方法、try-catch 语句和回调函数等多种方式处理HTTP请求错误。"
  },
  {
    "id": 98,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是 Preferences 支持的数据类型？",
    "options": {
      "A": "string",
      "B": "number",
      "C": "boolean",
      "D": "object"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Preferences 支持 string、number、boolean 等基础数据类型，但不直接支持object类型。"
  },
  {
    "id": 99,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何配置路由页面？",
    "options": {
      "A": "在 main_pages.json 中配置",
      "B": "在 app.ets 中配置",
      "C": "在 package.json 中配置",
      "D": "在 config.json 中配置"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 main_pages.json 文件中配置应用的路由页面信息。"
  },
  {
    "id": 100,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "LazyForEach 与普通 ForEach 的主要区别是什么？",
    "options": {
      "A": "LazyForEach 延迟创建列表项",
      "B": "LazyForEach 性能更好",
      "C": "LazyForEach 支持更多数据类型",
      "D": "LazyForEach 语法更简单"
    },
    "answer": [
      "A"
    ],
    "explanation": "LazyForEach 只在列表项需要显示时才创建对应的组件，而普通 ForEach 会立即创建所有列表项组件。"
  },
  {
    "id": 101,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义一个泛型接口？",
    "options": {
      "A": "interface Result<T> { data: T, success: boolean }",
      "B": "interface<T> Result { data: T, success: boolean }",
      "C": "generic interface Result<T> { data: T, success: boolean }",
      "D": "interface Result<generic T> { data: T, success: boolean }"
    },
    "answer": [
      "A"
    ],
    "explanation": "在接口名后使用 <T> 定义泛型参数：interface Result<T> { data: T, success: boolean }"
  },
  {
    "id": 102,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextInput 组件的常用属性？",
    "options": {
      "A": "placeholder",
      "B": "text",
      "C": "onEditChange",
      "D": "maxLength"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "TextInput 支持 placeholder（占位符）、text（文本内容）、maxLength（最大长度）等属性，但没有onEditChange事件。"
  },
  {
    "id": 103,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "@Watch 装饰器的作用是什么？",
    "options": {
      "A": "监听状态变量的变化",
      "B": "监听组件生命周期",
      "C": "监听用户输入",
      "D": "ArkTS没有@Watch装饰器"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS 没有 @Watch 装饰器，状态管理主要通过 @State、@Prop、@Link 等装饰器实现响应式更新。"
  },
  {
    "id": 104,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何扩展组件的样式？",
    "options": {
      "A": "使用 @Extend 装饰器",
      "B": "使用继承",
      "C": "使用 mixin",
      "D": "使用 @Style 装饰器"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 @Extend 装饰器扩展现有组件的样式。"
  },
  {
    "id": 105,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Stack 布局的常用属性？",
    "options": {
      "A": "alignContent",
      "B": "alignItems",
      "C": "position",
      "D": "zIndex"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Stack 布局支持 alignContent（内容对齐）和 alignItems（项目对齐）属性，position和zIndex是子组件的属性。"
  },
  {
    "id": 106,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建透明度动画？",
    "options": {
      "A": "opacity(0.5)",
      "B": "alpha(0.5)",
      "C": "transparency(0.5)",
      "D": "fade(0.5)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 opacity() 方法设置组件的透明度，可以结合动画实现淡入淡出效果。"
  },
  {
    "id": 107,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何取消 HTTP 请求？",
    "options": {
      "A": "使用 http.request() 返回的HttpRequest对象",
      "B": "使用 abort() 方法",
      "C": "使用 cancel() 方法",
      "D": "ArkTS不支持取消HTTP请求"
    },
    "answer": [
      "A"
    ],
    "explanation": "http.request() 返回 HttpRequest 对象，调用其 destroy() 方法可以取消请求。"
  },
  {
    "id": 108,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是 AppStorage 的常用方法？",
    "options": {
      "A": "setOrCreate",
      "B": "set",
      "C": "get",
      "D": "has"
    },
    "explanation": "AppStorage 支持 setOrCreate、set、get、has 等方法用于数据的存储和读取。"
  },
  {
    "id": 109,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现页面返回时传递数据？",
    "options": {
      "A": "使用 Router.back() 的 options 参数",
      "B": "使用全局状态管理",
      "C": "使用 Intent",
      "D": "ArkTS不支持页面返回传递数据"
    },
    "explanation": "使用 Router.back() 方法的 options 参数传递数据给上一个页面。"
  },
  {
    "id": 110,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何避免图片加载导致的性能问题？",
    "options": {
      "A": "使用缩略图",
      "B": "使用懒加载",
      "C": "使用合适的图片格式",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用缩略图、懒加载和合适的图片格式（如WebP）都可以优化图片加载性能。"
  },
  {
    "id": 111,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "如何定义一个常量？",
    "options": {
      "A": "const MAX_SIZE = 100",
      "B": "let MAX_SIZE = 100",
      "C": "var MAX_SIZE = 100",
      "D": "static MAX_SIZE = 100"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 const 关键字定义常量：const MAX_SIZE = 100"
  },
  {
    "id": 112,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "简单",
    "question": "以下哪些是 Image 组件的图片源类型？",
    "options": {
      "A": "PixelMap",
      "B": "Resource",
      "C": "Drawable",
      "D": "Url"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Image 组件支持 PixelMap（像素图）、Resource（资源引用）、Url（网络图片）等图片源类型。"
  },
  {
    "id": 113,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 的作用范围是什么？",
    "options": {
      "A": "全局应用",
      "B": "当前页面",
      "C": "当前组件树",
      "D": "当前组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "LocalStorage 是页面级的存储，在当前页面及子组件中共享状态。"
  },
  {
    "id": 114,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@BuilderParam 装饰器的作用是什么？",
    "options": {
      "A": "定义构建器参数",
      "B": "定义状态参数",
      "C": "定义样式参数",
      "D": "定义事件参数"
    },
    "answer": [
      "A"
    ],
    "explanation": "@BuilderParam 装饰器用于定义组件的构建器参数，允许父组件传递UI结构给子组件。"
  },
  {
    "id": 115,
    "type": "multiple",
    "category": "布局",
    "difficulty": "简单",
    "question": "以下哪些是 Column 布局的常用对齐方式？",
    "options": {
      "A": "Top",
      "B": "Center",
      "C": "Bottom",
      "D": "SpaceBetween"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Column 布局支持 Top（顶部）、Center（居中）、Bottom（底部）、SpaceBetween（两端对齐）等对齐方式。"
  },
  {
    "id": 116,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何设置动画的缓动曲线？",
    "options": {
      "A": "curve(Curve.EaseIn)",
      "B": "easing('ease-in')",
      "C": "animationCurve(Curve.EaseIn)",
      "D": "timingFunction(Curve.EaseIn)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 curve() 方法设置动画的缓动曲线，如 Curve.EaseIn、Curve.EaseOut 等。"
  },
  {
    "id": 117,
    "type": "single",
    "category": "网络请求",
    "difficulty": "简单",
    "question": "如何判断 HTTP 请求是否成功？",
    "options": {
      "A": "检查 responseCode",
      "B": "检查 status",
      "C": "检查 result",
      "D": "检查 success"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过 HTTP 响应的 responseCode 属性判断请求是否成功，200表示成功。"
  },
  {
    "id": 118,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "简单",
    "question": "以下哪些操作需要存储权限？",
    "options": {
      "A": "访问应用沙箱目录",
      "B": "访问系统相册",
      "C": "访问系统下载目录",
      "D": "访问其他应用数据"
    },
    "answer": [
      "B",
      "C",
      "D"
    ],
    "explanation": "访问应用沙箱目录不需要权限，但访问系统相册、下载目录和其他应用数据需要相应的权限。"
  },
  {
    "id": 119,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现页面跳转动画？",
    "options": {
      "A": "在 Router.pushUrl() 的 options 中设置",
      "B": "使用 PageTransition 组件",
      "C": "使用 animateTo 方法",
      "D": "ArkTS不支持页面跳转动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 PageTransition 组件定义页面转场动画。"
  },
  {
    "id": 120,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何减少应用启动时间？",
    "options": {
      "A": "延迟加载非必要模块",
      "B": "优化图片资源",
      "C": "减少全局状态初始化",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "延迟加载模块、优化资源和减少初始化操作都可以减少应用启动时间。"
  },
  {
    "id": 121,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现接口的继承？",
    "options": {
      "A": "interface B extends A { }",
      "B": "interface B implements A { }",
      "C": "interface B : A { }",
      "D": "interface B inherit A { }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 extends 关键字实现接口继承：interface B extends A { }"
  },
  {
    "id": 122,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Checkbox 组件的常用属性？",
    "options": {
      "A": "select",
      "B": "onChange",
      "C": "name",
      "D": "group"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Checkbox 组件支持 select（选中状态）、onChange（变化事件）、name（名称）等属性，但没有group属性。"
  },
  {
    "id": 123,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "@Consume 装饰器必须与哪个装饰器配合使用？",
    "options": {
      "A": "@Provide",
      "B": "@State",
      "C": "@Link",
      "D": "@StorageLink"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Consume 必须与 @Provide 配合使用，实现跨组件层级的双向数据同步。"
  },
  {
    "id": 124,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建全局的自定义样式？",
    "options": {
      "A": "使用 @Styles 并设置为全局",
      "B": "在 @Component 外定义 @Styles",
      "C": "使用 @GlobalStyles",
      "D": "在 app.ets 中定义样式"
    },
    "answer": [
      "B"
    ],
    "explanation": "在 @Component 装饰器外部定义 @Styles，该样式会成为全局样式。"
  },
  {
    "id": 125,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Flex 布局的 flexDirection 可选值？",
    "options": {
      "A": "Row",
      "B": "Column",
      "C": "RowReverse",
      "D": "ColumnReverse"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Flex 布局的 flexDirection 支持 Row（行）、Column（列）、RowReverse（行反向）、ColumnReverse（列反向）等方向。"
  },
  {
    "id": 126,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建组合动画？",
    "options": {
      "A": "使用 animationGroup()",
      "B": "同时应用多个动画方法",
      "C": "使用 combine() 方法",
      "D": "使用 parallel() 方法"
    },
    "answer": [
      "B"
    ],
    "explanation": "在组件上同时应用多个动画方法（如 translate、rotate、scale等）可以创建组合动画效果。"
  },
  {
    "id": 127,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何上传文件？",
    "options": {
      "A": "使用 http.upload() 方法",
      "B": "在 request() 中设置 method 为 'UPLOAD'",
      "C": "使用 FormData 和 POST 请求",
      "D": "ArkTS不支持文件上传"
    },
    "answer": [
      "C"
    ],
    "explanation": "通过构造 FormData 数据，使用 POST 方法实现文件上传。"
  },
  {
    "id": 128,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是关系型数据库的基本操作？",
    "options": {
      "A": "INSERT",
      "B": "SELECT",
      "C": "UPDATE",
      "D": "DELETE"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "关系型数据库支持 INSERT（插入）、SELECT（查询）、UPDATE（更新）、DELETE（删除）等基本操作。"
  },
  {
    "id": 129,
    "type": "single",
    "category": "路由导航",
    "difficulty": "简单",
    "question": "如何替换当前页面？",
    "options": {
      "A": "Router.replaceUrl()",
      "B": "Router.switchUrl()",
      "C": "Router.changeUrl()",
      "D": "Router.reloadUrl()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Router.replaceUrl() 方法替换当前页面，不会保留当前页面在历史栈中。"
  },
  {
    "id": 130,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化应用的内存使用？",
    "options": {
      "A": "及时释放不再使用的资源",
      "B": "使用对象池",
      "C": "避免内存泄漏",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "释放资源、使用对象池和避免内存泄漏都可以优化应用的内存使用。"
  },
  {
    "id": 131,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义可选接口属性？",
    "options": {
      "A": "name?: string",
      "B": "optional name: string",
      "C": "name: string?",
      "D": "name: optional string"
    },
    "answer": [
      "A"
    ],
    "explanation": "在接口属性名后添加问号表示该属性是可选的：name?: string"
  },
  {
    "id": 132,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Radio 组件的常用属性？",
    "options": {
      "A": "checked",
      "B": "value",
      "C": "group",
      "D": "onChange"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Radio 组件支持 checked（选中状态）、value（值）、group（分组）、onChange（变化事件）等属性。"
  },
  {
    "id": 133,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "Environment 装饰器的作用是什么？",
    "options": {
      "A": "访问设备环境信息",
      "B": "管理应用环境变量",
      "C": "监听系统设置变化",
      "D": "ArkTS没有Environment装饰器"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS 没有 Environment 装饰器，设备环境信息通过其他API获取。"
  },
  {
    "id": 134,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可复用的UI片段？",
    "options": {
      "A": "使用 @Builder 装饰器",
      "B": "使用 @Component 装饰器",
      "C": "使用 @Fragment 装饰器",
      "D": "使用 function 关键字"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 @Builder 装饰器创建可复用的UI构建函数。"
  },
  {
    "id": 135,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridRow 组件的常用属性？",
    "options": {
      "A": "columns",
      "B": "direction",
      "C": "breakpoints",
      "D": "gutter"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "GridRow 组件支持 columns（列数）、direction（方向）、breakpoints（断点）、gutter（间隔）等响应式网格布局属性。"
  },
  {
    "id": 136,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何设置动画的重复次数？",
    "options": {
      "A": "iterations(3)",
      "B": "repeat(3)",
      "C": "loop(3)",
      "D": "cycle(3)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 iterations() 方法设置动画的重复次数，-1表示无限循环。"
  },
  {
    "id": 137,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何处理网络请求的缓存？",
    "options": {
      "A": "在 request() 的 header 中设置缓存策略",
      "B": "使用 Cache API",
      "C": "手动管理缓存数据",
      "D": "以上都可以"
    },
    "answer": [
      "D"
    ],
    "explanation": "可以通过请求头设置、Cache API或手动管理等方式处理网络请求缓存。"
  },
  {
    "id": 138,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是关系型数据库的进阶特性？",
    "options": {
      "A": "事务",
      "B": "索引",
      "C": "触发器",
      "D": "视图"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "关系型数据库支持事务、索引、触发器、视图等进阶特性。"
  },
  {
    "id": 139,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何监听路由变化？",
    "options": {
      "A": "Router.addObserver()",
      "B": "Router.watch()",
      "C": "Router.onChange()",
      "D": "Router.subscribe()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Router.addObserver() 方法添加路由观察者，监听路由状态变化。"
  },
  {
    "id": 140,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何检测和解决内存泄漏？",
    "options": {
      "A": "使用性能分析工具",
      "B": "检查循环引用",
      "C": "及时取消事件监听",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用分析工具、检查循环引用和及时取消监听都可以帮助检测和解决内存泄漏问题。"
  },
  {
    "id": 141,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现类的方法重载？",
    "options": {
      "A": "TypeScript不支持方法重载",
      "B": "使用 override 关键字",
      "C": "定义多个同名方法签名",
      "D": "使用 overload 关键字"
    },
    "answer": [
      "C"
    ],
    "explanation": "TypeScript支持方法重载，通过定义多个方法签名和一个实现签名来实现。"
  },
  {
    "id": 142,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Slider 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "min",
      "C": "max",
      "D": "onChange"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Slider 组件支持 value（当前值）、min（最小值）、max（最大值）、onChange（变化事件）等属性。"
  },
  {
    "id": 143,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@LocalStorageLink 的作用是什么？",
    "options": {
      "A": "与 LocalStorage 双向同步",
      "B": "与 AppStorage 双向同步",
      "C": "与 PersistentStorage 双向同步",
      "D": "组件内部状态管理"
    },
    "answer": [
      "A"
    ],
    "explanation": "@LocalStorageLink 与 LocalStorage 中的属性建立双向同步关系。"
  },
  {
    "id": 144,
    "type": "single",
    "category": "组件开发",
    "difficulty": "困难",
    "question": "@Builder 函数中能否使用 this？",
    "options": {
      "A": "可以，指向当前组件",
      "B": "可以，但有严格限制",
      "C": "不可以，会编译错误",
      "D": "可以，但只能访问静态成员"
    },
    "answer": [
      "B"
    ],
    "explanation": "@Builder 函数中可以使用 this，但只能访问全局变量和当前组件的常量。"
  },
  {
    "id": 145,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 WaterFlow 组件的常用属性？",
    "options": {
      "A": "columnsTemplate",
      "B": "rowsTemplate",
      "C": "itemLayout",
      "D": "layoutDirection"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "WaterFlow 组件支持 columnsTemplate（列模板）和 itemLayout（项布局）等属性。"
  },
  {
    "id": 146,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建弹簧动画？",
    "options": {
      "A": "使用 springMotion()",
      "B": "使用 SpringAnimation",
      "C": "使用 animateSpring()",
      "D": "ArkTS不支持弹簧动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 springMotion() 方法创建基于弹簧物理模型的动画效果。"
  },
  {
    "id": 147,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求重试机制？",
    "options": {
      "A": "手动封装重试逻辑",
      "B": "使用 http.retry() 方法",
      "C": "在 request() 中设置 retryCount",
      "D": "ArkTS不支持请求重试"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS没有内置的请求重试机制，需要手动封装重试逻辑。"
  },
  {
    "id": 148,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是文件系统操作？",
    "options": {
      "A": "读写文件",
      "B": "创建目录",
      "C": "删除文件",
      "D": "文件权限管理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "文件系统支持文件的读写、目录的创建删除、权限管理等操作。"
  },
  {
    "id": 149,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现深链接（Deep Link）？",
    "options": {
      "A": "在 config.json 中配置",
      "B": "使用 Router.handleUrl()",
      "C": "实现 onAppear 生命周期",
      "D": "以上都是"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 config.json 文件的 abilities 中配置 uri 和 skills 实现深链接。"
  },
  {
    "id": 150,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化列表滚动性能？",
    "options": {
      "A": "使用 cachedCount",
      "B": "优化列表项组件",
      "C": "使用 recycle() 方法",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "设置 cachedCount、优化列表项组件和使用回收机制都可以提升列表滚动性能。"
  },
  {
    "id": 151,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现类的继承？",
    "options": {
      "A": "class B extends A { }",
      "B": "class B : A { }",
      "C": "class B implements A { }",
      "D": "class B inherit A { }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 extends 关键字实现类的继承：class B extends A { }"
  },
  {
    "id": 152,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Toggle 组件的常用属性？",
    "options": {
      "A": "isOn",
      "B": "onChange",
      "C": "selectedColor",
      "D": "switchPointColor"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Toggle 组件支持 isOn（开关状态）、onChange（变化事件）、selectedColor（选中颜色）、switchPointColor（滑块颜色）等属性。"
  },
  {
    "id": 153,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "@LocalStorageProp 和 @LocalStorageLink 的主要区别是什么？",
    "options": {
      "A": "@LocalStorageProp 单向同步，@LocalStorageLink 双向同步",
      "B": "@LocalStorageProp 用于组件内，@LocalStorageLink 用于组件间",
      "C": "@LocalStorageProp 性能更好，@LocalStorageLink 功能更强大",
      "D": "没有区别，可以互换使用"
    },
    "answer": [
      "A"
    ],
    "explanation": "@LocalStorageProp 与 LocalStorage 单向同步，组件内修改不会影响LocalStorage；@LocalStorageLink 与 LocalStorage 双向同步，组件内修改会同步到LocalStorage。"
  },
  {
    "id": 154,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建条件构建器？",
    "options": {
      "A": "使用 @Builder 和 if 语句",
      "B": "使用 @ConditionalBuilder",
      "C": "使用 @IfBuilder",
      "D": "ArkTS不支持条件构建器"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 @Builder 函数中使用 if 语句实现条件构建逻辑。"
  },
  {
    "id": 155,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridCol 组件的常用属性？",
    "options": {
      "A": "span",
      "B": "offset",
      "C": "order",
      "D": "span"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "GridCol 组件支持 span（跨越列数）、offset（偏移列数）、order（排序）等属性。"
  },
  {
    "id": 156,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建共享元素转场动画？",
    "options": {
      "A": "使用 sharedTransition",
      "B": "使用 SharedElement",
      "C": "使用 transitionShare",
      "D": "ArkTS不支持共享元素转场"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 sharedTransition 方法配置共享元素转场动画。"
  },
  {
    "id": 157,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何设置请求的优先级？",
    "options": {
      "A": "在 request() 的 options 中设置 priority",
      "B": "使用 setPriority() 方法",
      "C": "在 createHttp() 时设置",
      "D": "ArkTS不支持设置请求优先级"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 http.request() 方法的 options 参数中设置 priority 属性来配置请求优先级。"
  },
  {
    "id": 158,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是关系型数据库的事务特性（ACID）？",
    "options": {
      "A": "原子性",
      "B": "一致性",
      "C": "隔离性",
      "D": "持久性"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "关系型数据库的事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性。"
  },
  {
    "id": 159,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何清除路由历史栈？",
    "options": {
      "A": "Router.clear()",
      "B": "Router.clearHistory()",
      "C": "Router.clearStack()",
      "D": "Router.removeAll()"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 Router.clearHistory() 方法清除路由历史栈。"
  },
  {
    "id": 160,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何优化图片内存占用？",
    "options": {
      "A": "使用合适的图片尺寸",
      "B": "及时释放不再使用的图片",
      "C": "使用图片压缩",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用合适尺寸、及时释放和压缩图片都可以优化图片内存占用。"
  },
  {
    "id": 161,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义抽象类？",
    "options": {
      "A": "abstract class Animal { }",
      "B": "class abstract Animal { }",
      "C": "class Animal abstract { }",
      "D": "abstract class Animal abstract { }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 abstract 关键字定义抽象类：abstract class Animal { }"
  },
  {
    "id": 162,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Progress 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "total",
      "C": "type",
      "D": "color"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Progress 组件支持 value（当前值）、total（总值）、type（类型）、color（颜色）等属性。"
  },
  {
    "id": 163,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "如何监听 AppStorage 中特定属性的变化？",
    "options": {
      "A": "使用 @StorageLink 或 @StorageProp",
      "B": "使用 AppStorage.on() 方法",
      "C": "使用 @Watch 装饰器",
      "D": "ArkTS不支持监听AppStorage变化"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 @StorageLink 或 @StorageProp 装饰的变量会自动响应AppStorage中对应属性的变化。"
  },
  {
    "id": 164,
    "type": "single",
    "category": "组件开发",
    "difficulty": "困难",
    "question": "@BuilderParam 可以接收哪些类型的参数？",
    "options": {
      "A": "只有无参的@Builder函数",
      "B": "无参或有参的@Builder函数",
      "C": "任何函数",
      "D": "只有箭头函数"
    },
    "answer": [
      "B"
    ],
    "explanation": "@BuilderParam 可以接收无参或有参的@Builder函数，需要在定义时指定参数类型。"
  },
  {
    "id": 165,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是关于 ListItem 组件的正确描述？",
    "options": {
      "A": "是List的子组件",
      "B": "支持swipeAction属性",
      "C": "支持selectable属性",
      "D": "可以独立使用"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "ListItem是List的子组件，支持swipeAction（滑动操作）、selectable（可选性）等属性，通常不能独立于List使用。"
  },
  {
    "id": 166,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建物理动画效果？",
    "options": {
      "A": "使用 physicsMotion()",
      "B": "使用 PhysicsAnimation",
      "C": "使用 animatePhysics()",
      "D": "ArkTS不支持物理动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 physicsMotion() 方法创建基于物理模型的动画效果。"
  },
  {
    "id": 167,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何下载文件？",
    "options": {
      "A": "使用 http.download() 方法",
      "B": "使用 request() 设置 method 为 'DOWNLOAD'",
      "C": "使用 request() 并处理二进制数据",
      "D": "ArkTS不支持文件下载"
    },
    "answer": [
      "C"
    ],
    "explanation": "通过 http.request() 获取文件二进制数据，然后使用文件系统API保存到本地。"
  },
  {
    "id": 168,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是文件系统的基本操作？",
    "options": {
      "A": "readText",
      "B": "writeText",
      "C": "list",
      "D": "delete"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "文件系统支持 readText（读取文本）、writeText（写入文本）、list（列表）、delete（删除）等基本操作。"
  },
  {
    "id": 169,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现自定义路由拦截？",
    "options": {
      "A": "使用 Router.beforeEach()",
      "B": "使用路由观察者",
      "C": "在目标页面中判断",
      "D": "ArkTS不支持路由拦截"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 Router.addObserver() 添加路由观察者，在回调中实现拦截逻辑。"
  },
  {
    "id": 170,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何减少包体积？",
    "options": {
      "A": "移除未使用的资源",
      "B": "使用代码混淆",
      "C": "按需引入模块",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "移除未使用资源、代码混淆和按需引入模块都可以减少应用包体积。"
  },
  {
    "id": 171,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现接口的多继承？",
    "options": {
      "A": "interface C extends A, B { }",
      "B": "interface C : A, B { }",
      "C": "interface C implements A, B { }",
      "D": "TypeScript不支持接口多继承"
    },
    "answer": [
      "A"
    ],
    "explanation": "接口支持多继承，使用 extends 关键字并用逗号分隔：interface C extends A, B { }"
  },
  {
    "id": 172,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextArea 组件的常用属性？",
    "options": {
      "A": "text",
      "B": "placeholder",
      "C": "maxLength",
      "D": "onChange"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextArea 组件支持 text（文本内容）、placeholder（占位符）、maxLength（最大长度）、onChange（变化事件）等属性。"
  },
  {
    "id": 173,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的中间件？",
    "options": {
      "A": "使用 @Middleware 装饰器",
      "B": "封装自定义状态管理类",
      "C": "使用 AppStorage 的监听机制",
      "D": "ArkTS不支持状态管理中间件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过封装自定义状态管理类，在其中实现中间件逻辑，如日志、持久化等。"
  },
  {
    "id": 174,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建动态组件？",
    "options": {
      "A": "使用 @DynamicComponent",
      "B": "使用条件渲染",
      "C": "使用 Builder 函数",
      "D": "ArkTS不支持动态组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件渲染（if-else）或动态组件名实现动态组件功能。"
  },
  {
    "id": 175,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Badge 组件的常用属性？",
    "options": {
      "A": "count",
      "B": "position",
      "C": "maxCount",
      "D": "style"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Badge 组件支持 count（计数）、position（位置）、maxCount（最大显示数）、style（样式）等属性。"
  },
  {
    "id": 176,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建路径动画？",
    "options": {
      "A": "使用 motionPath()",
      "B": "使用 PathAnimation",
      "C": "使用 animatePath()",
      "D": "ArkTS不支持路径动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 motionPath() 方法创建沿着指定路径运动的动画效果。"
  },
  {
    "id": 177,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的批量处理？",
    "options": {
      "A": "使用 Promise.all()",
      "B": "使用 http.batch() 方法",
      "C": "使用 BatchRequest 类",
      "D": "ArkTS不支持请求批量处理"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Promise.all() 方法并发执行多个请求，实现批量处理。"
  },
  {
    "id": 178,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是 Preferences 的进阶操作？",
    "options": {
      "A": "数据加密",
      "B": "数据迁移",
      "C": "数据备份",
      "D": "数据同步"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Preferences 支持数据加密、迁移、备份等进阶操作，但不直接支持数据同步。"
  },
  {
    "id": 179,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何获取路由参数？",
    "options": {
      "A": "在 onPageShow 中通过 Router.getParams()",
      "B": "在 @State 中定义",
      "C": "通过 props 传递",
      "D": "在 build 方法中访问"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 onPageShow 生命周期中使用 Router.getParams() 获取路由参数。"
  },
  {
    "id": 180,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何优化首屏加载时间？",
    "options": {
      "A": "代码分割",
      "B": "资源预加载",
      "C": "减少初始渲染组件",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "代码分割、资源预加载和减少初始渲染组件都可以优化首屏加载时间。"
  },
  {
    "id": 181,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义只读属性？",
    "options": {
      "A": "readonly name: string;",
      "B": "const name: string;",
      "C": "name: readonly string;",
      "D": "name: string readonly;"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 readonly 关键字定义只读属性：readonly name: string;"
  },
  {
    "id": 182,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 DatePicker 组件的常用属性？",
    "options": {
      "A": "start",
      "B": "end",
      "C": "selected",
      "D": "onChange"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "DatePicker 组件支持 start（开始日期）、end（结束日期）、selected（选中日期）、onChange（变化事件）等属性。"
  },
  {
    "id": 183,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的依赖注入？",
    "options": {
      "A": "使用 @Inject 装饰器",
      "B": "使用 @Provide 和 @Consume",
      "C": "使用全局状态管理",
      "D": "ArkTS不支持依赖注入"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 @Provide 和 @Consume 装饰器可以实现类似依赖注入的状态管理功能。"
  },
  {
    "id": 184,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建高阶组件？",
    "options": {
      "A": "使用 @HigherOrderComponent",
      "B": "使用函数返回组件",
      "C": "使用 @Component 继承",
      "D": "ArkTS不支持高阶组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过函数接收组件参数并返回新组件的方式创建高阶组件。"
  },
  {
    "id": 185,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Navigation 组件的常用属性？",
    "options": {
      "A": "title",
      "B": "menus",
      "C": "toolbar",
      "D": "hideBackButton"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Navigation 组件支持 title（标题）、menus（菜单）、toolbar（工具栏）、hideBackButton（隐藏返回按钮）等属性。"
  },
  {
    "id": 186,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建粒子动画？",
    "options": {
      "A": "使用 ParticleSystem",
      "B": "使用 particleAnimation()",
      "C": "使用 animateParticles()",
      "D": "ArkTS不支持粒子动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 ParticleSystem 创建粒子动画效果。"
  },
  {
    "id": 187,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何设置请求的认证信息？",
    "options": {
      "A": "在 header 中设置 Authorization",
      "B": "使用 setAuth() 方法",
      "C": "在 createHttp() 时设置",
      "D": "ArkTS不支持请求认证"
    },
    "answer": [
      "A"
    ],
    "explanation": "在请求头中设置 Authorization 字段传递认证信息。"
  },
  {
    "id": 188,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是分布式数据管理的特性？",
    "options": {
      "A": "跨设备数据同步",
      "B": "数据冲突解决",
      "C": "数据加密传输",
      "D": "自动数据备份"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "分布式数据管理支持跨设备数据同步、数据冲突解决和数据加密传输等特性。"
  },
  {
    "id": 189,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由守卫？",
    "options": {
      "A": "使用 Router.beforeEnter()",
      "B": "使用路由观察者拦截",
      "C": "在目标页面中判断",
      "D": "ArkTS不支持路由守卫"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过路由观察者在路由变化前进行拦截和判断，实现路由守卫功能。"
  },
  {
    "id": 190,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何优化动画性能？",
    "options": {
      "A": "使用硬件加速",
      "B": "减少动画复杂度",
      "C": "使用合适的动画时长",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用硬件加速、减少动画复杂度和使用合适时长都可以优化动画性能。"
  },
  {
    "id": 191,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义命名空间？",
    "options": {
      "A": "namespace Validation { }",
      "B": "module Validation { }",
      "C": "package Validation { }",
      "D": "scope Validation { }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 namespace 关键字定义命名空间：namespace Validation { }"
  },
  {
    "id": 192,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TimePicker 组件的常用属性？",
    "options": {
      "A": "selected",
      "B": "useMilitaryTime",
      "C": "onChange",
      "D": "interval"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TimePicker 组件支持 selected（选中时间）、useMilitaryTime（24小时制）、onChange（变化事件）、interval（时间间隔）等属性。"
  },
  {
    "id": 193,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的撤销/重做功能？",
    "options": {
      "A": "使用 @UndoRedo 装饰器",
      "B": "封装支持历史记录的状态管理类",
      "C": "使用 AppStorage 的版本管理",
      "D": "ArkTS不支持撤销重做功能"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过封装自定义状态管理类，在其中维护状态历史记录，实现撤销/重做功能。"
  },
  {
    "id": 194,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建插槽组件？",
    "options": {
      "A": "使用 @Slot 装饰器",
      "B": "使用 @BuilderParam",
      "C": "使用 slot 属性",
      "D": "ArkTS不支持插槽组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 @BuilderParam 装饰器创建支持插槽的自定义组件。"
  },
  {
    "id": 195,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Panel 组件的常用属性？",
    "options": {
      "A": "mode",
      "B": "fullHeight",
      "C": "dragBar",
      "D": "minHeight"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Panel 组件支持 mode（模式）、fullHeight（全高）、dragBar（拖动条）、minHeight（最小高度）等属性。"
  },
  {
    "id": 196,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建视差滚动效果？",
    "options": {
      "A": "使用 parallaxScroll()",
      "B": "使用 ParallaxComponent",
      "C": "使用 scrollParallax()",
      "D": "ArkTS不支持视差滚动"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 parallaxScroll() 方法创建视差滚动效果。"
  },
  {
    "id": 197,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的熔断机制？",
    "options": {
      "A": "手动封装熔断逻辑",
      "B": "使用 http.circuitBreaker()",
      "C": "在 request() 中设置 circuitBreaker",
      "D": "ArkTS不支持熔断机制"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS没有内置的熔断机制，需要手动封装熔断逻辑。"
  },
  {
    "id": 198,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据加密的常用算法？",
    "options": {
      "A": "AES",
      "B": "RSA",
      "C": "SHA",
      "D": "MD5"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据加密常用AES（对称加密）、RSA（非对称加密）、SHA（哈希）、MD5（哈希）等算法。"
  },
  {
    "id": 199,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的懒加载？",
    "options": {
      "A": "使用 Router.lazyLoad()",
      "B": "使用动态import()",
      "C": "使用 LazyComponent",
      "D": "ArkTS不支持路由懒加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过动态 import() 语法实现路由组件的懒加载。"
  },
  {
    "id": 200,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化电池消耗？",
    "options": {
      "A": "减少不必要的网络请求",
      "B": "优化定位服务使用",
      "C": "减少屏幕亮度",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "减少网络请求、优化定位服务和调整屏幕亮度都可以优化电池消耗。"
  },
  {
    "id": 201,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现混入（Mixin）模式？",
    "options": {
      "A": "使用 extends 关键字",
      "B": "使用 implements 关键字",
      "C": "使用交叉类型和类表达式",
      "D": "TypeScript不支持混入模式"
    },
    "answer": [
      "C"
    ],
    "explanation": "通过交叉类型和类表达式实现混入模式：class MyClass extends BaseClass implements Mixin1, Mixin2 { }"
  },
  {
    "id": 202,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Search 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "placeholder",
      "C": "onSubmit",
      "D": "onChange"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Search 组件支持 value（搜索值）、placeholder（占位符）、onSubmit（提交事件）、onChange（变化事件）等属性。"
  },
  {
    "id": 203,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的快照功能？",
    "options": {
      "A": "使用 @Snapshot 装饰器",
      "B": "手动保存状态副本",
      "C": "使用 AppStorage 的快照方法",
      "D": "ArkTS不支持状态快照"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动保存状态副本来实现状态快照功能，用于状态回滚或调试。"
  },
  {
    "id": 204,
    "type": "single",
    "category": "组件开发",
    "difficulty": "困难",
    "question": "如何创建可拖拽组件？",
    "options": {
      "A": "使用 @Draggable 装饰器",
      "B": "使用 PanGesture 手势",
      "C": "使用 drag() 方法",
      "D": "ArkTS不支持拖拽组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 PanGesture 手势识别器实现组件的拖拽功能。"
  },
  {
    "id": 205,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Swiper 组件的常用属性？",
    "options": {
      "A": "index",
      "B": "autoPlay",
      "C": "interval",
      "D": "indicator"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Swiper 组件支持 index（当前索引）、autoPlay（自动播放）、interval（间隔时间）、indicator（指示器）等属性。"
  },
  {
    "id": 206,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建3D变换动画？",
    "options": {
      "A": "使用 transform3d()",
      "B": "使用 perspective() 和 rotate3d()",
      "C": "使用 ThreeDAnimation",
      "D": "ArkTS不支持3D动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 perspective() 设置透视点，配合 rotate3d() 等3D变换方法创建3D动画效果。"
  },
  {
    "id": 207,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何设置请求的重试次数？",
    "options": {
      "A": "在 request() 的 options 中设置 retryCount",
      "B": "使用 http.retry() 方法",
      "C": "手动封装重试逻辑",
      "D": "ArkTS不支持请求重试"
    },
    "answer": [
      "C"
    ],
    "explanation": "ArkTS没有内置的重试机制，需要手动封装重试逻辑。"
  },
  {
    "id": 208,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是分布式数据管理的核心概念？",
    "options": {
      "A": "KV数据模型",
      "B": "关系型数据模型",
      "C": "数据同步",
      "D": "权限管理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式数据管理支持KV数据模型、关系型数据模型、数据同步和权限管理等核心概念。"
  },
  {
    "id": 209,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的嵌套导航？",
    "options": {
      "A": "使用 Router.nested() 方法",
      "B": "在页面中再使用 Navigation 组件",
      "C": "使用 @NestedRouter 装饰器",
      "D": "ArkTS不支持嵌套导航"
    },
    "answer": [
      "B"
    ],
    "explanation": "在页面组件内部再使用 Navigation 组件实现嵌套导航效果。"
  },
  {
    "id": 210,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何优化大规模数据渲染？",
    "options": {
      "A": "使用虚拟列表",
      "B": "使用分页加载",
      "C": "使用数据缓存",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "虚拟列表、分页加载和数据缓存都可以优化大规模数据渲染性能。"
  },
  {
    "id": 211,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义泛型约束？",
    "options": {
      "A": "interface Lengthwise { length: number } function loggingIdentity<T extends Lengthwise>(arg: T): T { }",
      "B": "interface Lengthwise { length: number } function loggingIdentity<T: Lengthwise>(arg: T): T { }",
      "C": "interface Lengthwise { length: number } function loggingIdentity<T where T: Lengthwise>(arg: T): T { }",
      "D": "interface Lengthwise { length: number } function loggingIdentity<T implements Lengthwise>(arg: T): T { }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 extends 关键字定义泛型约束：function loggingIdentity<T extends Lengthwise>(arg: T): T { }"
  },
  {
    "id": 212,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Rating 组件的常用属性？",
    "options": {
      "A": "rating",
      "B": "indicator",
      "C": "onChange",
      "D": "stars"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Rating 组件支持 rating（评分值）、indicator（指示器）、onChange（变化事件）等属性，但没有stars属性。"
  },
  {
    "id": 213,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的类型安全？",
    "options": {
      "A": "使用 TypeScript 的类型系统",
      "B": "使用 @TypeSafe 装饰器",
      "C": "使用运行时类型检查",
      "D": "ArkTS不支持类型安全的状态管理"
    },
    "answer": [
      "A"
    ],
    "explanation": "充分利用 TypeScript 的静态类型系统，为状态定义精确的类型注解，实现类型安全。"
  },
  {
    "id": 214,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可折叠组件？",
    "options": {
      "A": "使用 @Collapsible 装饰器",
      "B": "使用条件渲染和动画",
      "C": "使用 FoldableComponent",
      "D": "ArkTS不支持可折叠组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件渲染配合高度或透明度的动画效果实现可折叠组件。"
  },
  {
    "id": 215,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 AdaptiveBox 组件的常用属性？",
    "options": {
      "A": "direction",
      "B": "alignItems",
      "C": "justifyContent",
      "D": "flexWrap"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "AdaptiveBox 组件支持 direction（方向）、alignItems（交叉轴对齐）、justifyContent（主轴对齐）等属性。"
  },
  {
    "id": 216,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建逐帧动画？",
    "options": {
      "A": "使用 frameAnimation()",
      "B": "使用 FrameAnimator",
      "C": "使用 animateFrames()",
      "D": "ArkTS不支持逐帧动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 FrameAnimator 创建逐帧动画，通过一系列图片帧实现动画效果。"
  },
  {
    "id": 217,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的拦截器？",
    "options": {
      "A": "使用 http.interceptor()",
      "B": "封装自定义HTTP客户端",
      "C": "使用 Interceptor 类",
      "D": "ArkTS不支持请求拦截器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过封装自定义HTTP客户端，在发送请求前后添加拦截逻辑。"
  },
  {
    "id": 218,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据备份的策略？",
    "options": {
      "A": "全量备份",
      "B": "增量备份",
      "C": "差异备份",
      "D": "实时备份"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据备份支持全量备份、增量备份、差异备份和实时备份等策略。"
  },
  {
    "id": 219,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的权限控制？",
    "options": {
      "A": "使用 Router.guard() 方法",
      "B": "在路由观察者中判断权限",
      "C": "使用 @RouteGuard 装饰器",
      "D": "ArkTS不支持路由权限控制"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过路由观察者在路由跳转前检查用户权限，实现路由权限控制。"
  },
  {
    "id": 220,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化渲染性能？",
    "options": {
      "A": "减少组件嵌套层级",
      "B": "使用 shouldComponentUpdate 类似机制",
      "C": "优化图片资源",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "减少嵌套层级、避免不必要的重新渲染和优化资源都可以提升渲染性能。"
  },
  {
    "id": 221,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现装饰器工厂？",
    "options": {
      "A": "function color(value: string) { return function (target) { } }",
      "B": "function @color(value: string) { }",
      "C": "factory function color(value: string) { }",
      "D": "TypeScript不支持装饰器工厂"
    },
    "answer": [
      "A"
    ],
    "explanation": "装饰器工厂是一个返回装饰器函数的函数：function color(value: string) { return function (target) { } }"
  },
  {
    "id": 222,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Marquee 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "loop",
      "C": "scrollAmount",
      "D": "behavior"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Marquee 组件支持 value（文本内容）、loop（循环次数）、scrollAmount（滚动速度）等属性。"
  },
  {
    "id": 223,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的持久化策略？",
    "options": {
      "A": "使用 PersistentStorage",
      "B": "手动序列化到本地存储",
      "C": "使用第三方状态管理库",
      "D": "以上都是"
    },
    "explanation": "可以使用 PersistentStorage、手动序列化或第三方库实现状态持久化。"
  },
  {
    "id": 224,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可缩放组件？",
    "options": {
      "A": "使用 @Zoomable 装饰器",
      "B": "使用 PinchGesture 手势",
      "C": "使用 scale() 方法",
      "D": "ArkTS不支持缩放组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 PinchGesture 手势识别器实现组件的缩放功能。"
  },
  {
    "id": 225,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Counter 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "min",
      "C": "max",
      "D": "step"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Counter 组件支持 value（当前值）、min（最小值）、max（最大值）、step（步长）等属性。"
  },
  {
    "id": 226,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建 morphing 变形动画？",
    "options": {
      "A": "使用 morph() 方法",
      "B": "使用 ShapeAnimation",
      "C": "使用 animateMorph()",
      "D": "ArkTS不支持变形动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 ShapeAnimation 创建形状变形动画效果。"
  },
  {
    "id": 227,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何设置请求的缓存策略？",
    "options": {
      "A": "在 header 中设置 Cache-Control",
      "B": "使用 http.cache() 方法",
      "C": "在 createHttp() 时设置",
      "D": "ArkTS不支持请求缓存"
    },
    "answer": [
      "A"
    ],
    "explanation": "在请求头中设置 Cache-Control 等缓存相关字段来控制缓存策略。"
  },
  {
    "id": 228,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据迁移的常见场景？",
    "options": {
      "A": "应用版本升级",
      "B": "数据结构变更",
      "C": "数据库引擎更换",
      "D": "设备更换"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "应用版本升级、数据结构变更、数据库引擎更换和设备更换都可能需要数据迁移。"
  },
  {
    "id": 229,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的传参类型安全？",
    "options": {
      "A": "使用 TypeScript 接口定义参数类型",
      "B": "使用 @RouteParams 装饰器",
      "C": "使用路由参数验证",
      "D": "ArkTS不支持路由参数类型安全"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过 TypeScript 接口定义路由参数的类型，实现编译时类型检查。"
  },
  {
    "id": 230,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何优化应用启动速度？",
    "options": {
      "A": "减少主包体积",
      "B": "延迟加载非核心模块",
      "C": "优化资源加载顺序",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "减少主包体积、延迟加载模块和优化资源加载都可以提升应用启动速度。"
  },
  {
    "id": 231,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义映射类型？",
    "options": {
      "A": "type Readonly<T> = { readonly [P in keyof T]: T[P] }",
      "B": "type Readonly<T> = { const [P in keyof T]: T[P] }",
      "C": "type Readonly<T> = { fixed [P in keyof T]: T[P] }",
      "D": "type Readonly<T> = { static [P in keyof T]: T[P] }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 in 关键字定义映射类型：type Readonly<T> = { readonly [P in keyof T]: T[P] }"
  },
  {
    "id": 232,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Gauge 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "min",
      "C": "max",
      "D": "colors"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Gauge 组件支持 value（当前值）、min（最小值）、max（最大值）、colors（颜色数组）等属性。"
  },
  {
    "id": 233,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的调试工具？",
    "options": {
      "A": "使用 Redux DevTools",
      "B": "自定义状态监听和日志",
      "C": "使用 @Debug 装饰器",
      "D": "ArkTS不支持状态调试"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过自定义状态变化监听和日志输出，实现状态管理的调试功能。"
  },
  {
    "id": 234,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可排序列表？",
    "options": {
      "A": "使用 @Sortable 装饰器",
      "B": "使用 LongPressGesture 和 PanGesture",
      "C": "使用 sort() 方法",
      "D": "ArkTS不支持排序列表"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过长按手势和拖拽手势配合实现列表项的排序功能。"
  },
  {
    "id": 235,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 SideBar 组件的常用属性？",
    "options": {
      "A": "show",
      "B": "width",
      "C": "position",
      "D": "animation"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "SideBar 组件支持 show（显示状态）、width（宽度）、position（位置）等属性。"
  },
  {
    "id": 236,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建打字机效果动画？",
    "options": {
      "A": "使用 typewriter() 方法",
      "B": "使用文本逐字显示和定时器",
      "C": "使用 TypewriterAnimation",
      "D": "ArkTS不支持打字机动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过定时器逐字更新文本内容，配合透明度和位置动画实现打字机效果。"
  },
  {
    "id": 237,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的队列管理？",
    "options": {
      "A": "使用 http.queue() 方法",
      "B": "手动管理请求队列",
      "C": "使用 QueueRequest 类",
      "D": "ArkTS不支持请求队列"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动管理请求队列，控制请求的并发数量和执行顺序。"
  },
  {
    "id": 238,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据压缩的常用算法？",
    "options": {
      "A": "GZIP",
      "B": "ZIP",
      "C": "LZ4",
      "D": "Snappy"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据压缩常用GZIP、ZIP、LZ4、Snappy等算法。"
  },
  {
    "id": 239,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的动效配置？",
    "options": {
      "A": "在 Router.pushUrl() 的 options 中设置",
      "B": "使用 PageTransition 组件",
      "C": "使用 @RouteTransition 装饰器",
      "D": "ArkTS不支持路由动效"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 PageTransition 组件为每个页面单独配置转场动画效果。"
  },
  {
    "id": 240,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化网络请求性能？",
    "options": {
      "A": "使用请求合并",
      "B": "使用数据缓存",
      "C": "使用CDN加速",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "请求合并、数据缓存和CDN加速都可以优化网络请求性能。"
  },
  {
    "id": 241,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现条件类型？",
    "options": {
      "A": "type T = X extends Y ? A : B",
      "B": "type T = if X extends Y then A else B",
      "C": "type T = X extends Y : A : B",
      "D": "type T = condition X extends Y A else B"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用三元运算符定义条件类型：type T = X extends Y ? A : B"
  },
  {
    "id": 242,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 QRCode 组件的常用属性？",
    "options": {
      "A": "value",
      "B": "color",
      "C": "backgroundColor",
      "D": "size"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "QRCode 组件支持 value（二维码内容）、color（颜色）、backgroundColor（背景色）、size（尺寸）等属性。"
  },
  {
    "id": 243,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的序列化？",
    "options": {
      "A": "使用 JSON.stringify()",
      "B": "使用自定义序列化器",
      "C": "使用 @Serializable 装饰器",
      "D": "ArkTS不支持状态序列化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过自定义序列化器处理复杂对象和循环引用等序列化场景。"
  },
  {
    "id": 244,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可滚动的标签页？",
    "options": {
      "A": "使用 ScrollableTabs",
      "B": "使用 Tabs 和 Scroll 组合",
      "C": "使用 @ScrollableTab 装饰器",
      "D": "ArkTS不支持滚动标签页"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 Tabs 组件和 Scroll 组件组合实现可滚动的标签页效果。"
  },
  {
    "id": 245,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Canvas 组件的常用方法？",
    "options": {
      "A": "fillRect",
      "B": "strokeRect",
      "C": "drawImage",
      "D": "measureText"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Canvas 组件支持 fillRect（填充矩形）、strokeRect（描边矩形）、drawImage（绘制图片）、measureText（测量文本）等方法。"
  },
  {
    "id": 246,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建粒子系统动画？",
    "options": {
      "A": "使用 ParticleEmitter",
      "B": "使用 particleSystem()",
      "C": "使用 animateParticles()",
      "D": "ArkTS不支持粒子系统"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 ParticleEmitter 创建和管理粒子系统动画。"
  },
  {
    "id": 247,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的进度监控？",
    "options": {
      "A": "使用 onProgress 回调",
      "B": "使用 http.progress() 方法",
      "C": "使用 ProgressMonitor 类",
      "D": "ArkTS不支持请求进度监控"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过请求的 onProgress 回调函数监控上传或下载进度。"
  },
  {
    "id": 248,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据加密的最佳实践？",
    "options": {
      "A": "使用强加密算法",
      "B": "安全存储密钥",
      "C": "定期更换密钥",
      "D": "使用HTTPS传输"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据加密的最佳实践包括使用强算法、安全存储密钥、定期更换密钥和使用安全传输。"
  },
  {
    "id": 249,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的预加载？",
    "options": {
      "A": "使用 Router.preload()",
      "B": "使用动态import()提前加载",
      "C": "使用 @Preload 装饰器",
      "D": "ArkTS不支持路由预加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过动态 import() 语法提前加载路由组件，实现预加载功能。"
  },
  {
    "id": 250,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现应用的懒加载？",
    "options": {
      "A": "使用动态import()",
      "B": "使用 LazyModule",
      "C": "使用 @Lazy 装饰器",
      "D": "ArkTS不支持懒加载"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过动态 import() 语法实现模块和组件的懒加载，减少初始包体积。"
  },
  {
    "id": 251,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何使用模板字面量类型？",
    "options": {
      "A": "type World = 'world' type Greeting = `hello ${World}`",
      "B": "type World = 'world' type Greeting = 'hello ' + World",
      "C": "type World = 'world' type Greeting = concat('hello ', World)",
      "D": "type World = 'world' type Greeting = 'hello {World}'"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用反引号和${}语法定义模板字面量类型：type World = 'world'; type Greeting = `hello ${World}`"
  },
  {
    "id": 252,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 AlertDialog 组件的常用方法？",
    "options": {
      "A": "show",
      "B": "confirm",
      "C": "dismiss",
      "D": "setContent"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "AlertDialog 组件支持 show（显示）和 dismiss（关闭）等方法。"
  },
  {
    "id": 253,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的中间件链？",
    "options": {
      "A": "使用 @MiddlewareChain 装饰器",
      "B": "使用函数组合模式",
      "C": "使用 MiddlewarePipeline 类",
      "D": "ArkTS不支持中间件链"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过函数组合模式将多个中间件连接成处理链。"
  },
  {
    "id": 254,
    "type": "single",
    "category": "组件开发",
    "difficulty": "困难",
    "question": "如何创建可配置的主题组件？",
    "options": {
      "A": "使用 @Themeable 装饰器",
      "B": "使用 @Consume 注入主题数据",
      "C": "使用 ThemeManager 类",
      "D": "ArkTS不支持主题组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @Consume 装饰器注入主题数据，实现响应式主题切换。"
  },
  {
    "id": 255,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Refresh 组件的常用属性？",
    "options": {
      "A": "refreshing",
      "B": "onRefresh",
      "C": "offset",
      "D": "friction"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Refresh 组件支持 refreshing（刷新状态）、onRefresh（刷新事件）、offset（偏移量）、friction（摩擦系数）等属性。"
  },
  {
    "id": 256,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建震动动画效果？",
    "options": {
      "A": "使用 shake() 方法",
      "B": "使用多个快速平移动画",
      "C": "使用 VibrationAnimation",
      "D": "ArkTS不支持震动动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过多个快速反向的平移动画组合实现震动效果。"
  },
  {
    "id": 257,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的依赖管理？",
    "options": {
      "A": "使用 http.dependency() 方法",
      "B": "手动管理请求依赖关系",
      "C": "使用 DependencyGraph 类",
      "D": "ArkTS不支持请求依赖管理"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动管理请求间的依赖关系，确保请求按正确顺序执行。"
  },
  {
    "id": 258,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据验证的常见方法？",
    "options": {
      "A": "数据类型验证",
      "B": "数据范围验证",
      "C": "数据格式验证",
      "D": "数据逻辑验证"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据验证包括数据类型、范围、格式和逻辑验证等多个方面。"
  },
  {
    "id": 259,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的状态持久化？",
    "options": {
      "A": "使用 Router.persistState()",
      "B": "手动保存路由状态到本地存储",
      "C": "使用 @PersistRoute 装饰器",
      "D": "ArkTS不支持路由状态持久化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动保存路由状态到本地存储，应用重启时恢复路由状态。"
  },
  {
    "id": 260,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化数据查询性能？",
    "options": {
      "A": "使用索引",
      "B": "优化查询语句",
      "C": "使用数据缓存",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用索引、优化查询语句和数据缓存都可以提升数据查询性能。"
  },
  {
    "id": 261,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现递归类型？",
    "options": {
      "A": "interface TreeNode { value: number; children: TreeNode[] }",
      "B": "interface TreeNode { value: number; children: Array<TreeNode> }",
      "C": "interface TreeNode { value: number; children: TreeNodes }",
      "D": "interface TreeNode { value: number; children: recursive TreeNode[] }"
    },
    "answer": [
      "A"
    ],
    "explanation": "在接口中直接引用自身类型实现递归类型：interface TreeNode { value: number; children: TreeNode[] }"
  },
  {
    "id": 262,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextClock 组件的常用属性？",
    "options": {
      "A": "format",
      "B": "timeZone",
      "C": "onDateChange",
      "D": "showSeconds"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextClock 组件支持 format（格式）、timeZone（时区）、onDateChange（日期变化事件）等属性。"
  },
  {
    "id": 263,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的性能监控？",
    "options": {
      "A": "使用 @Profile 装饰器",
      "B": "自定义状态变化监听和性能统计",
      "C": "使用 StateMonitor 类",
      "D": "ArkTS不支持状态性能监控"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过自定义状态变化监听，统计状态更新频率和耗时，实现性能监控。"
  },
  {
    "id": 264,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的表单验证组件？",
    "options": {
      "A": "使用 @Validatable 装饰器",
      "B": "使用 @BuilderParam 接收验证规则",
      "C": "使用 FormValidator 类",
      "D": "ArkTS不支持表单验证"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收验证规则函数，实现可配置的表单验证。"
  },
  {
    "id": 265,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 WaterFlow 组件的性能优化属性？",
    "options": {
      "A": "cachedCount",
      "B": "editMode",
      "C": "layoutDirection",
      "D": "columnsTemplate"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "WaterFlow 组件的 cachedCount（缓存数量）和 editMode（编辑模式）可以用于性能优化。"
  },
  {
    "id": 266,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建视差滚动动画？",
    "options": {
      "A": "使用 parallax() 方法",
      "B": "使用 ScrollParallax 组件",
      "C": "使用多个图层不同的滚动速度",
      "D": "ArkTS不支持视差滚动"
    },
    "answer": [
      "C"
    ],
    "explanation": "通过设置多个图层以不同速度滚动，创建视差滚动效果。"
  },
  {
    "id": 267,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的mock测试？",
    "options": {
      "A": "使用 http.mock() 方法",
      "B": "封装可配置的HTTP客户端",
      "C": "使用 MockAdapter 类",
      "D": "ArkTS不支持请求mock"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过封装可配置的HTTP客户端，在测试环境下返回模拟数据。"
  },
  {
    "id": 268,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据同步的常见策略？",
    "options": {
      "A": "定时同步",
      "B": "增量同步",
      "C": "冲突解决策略",
      "D": "断点续传"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据同步支持定时同步、增量同步、冲突解决和断点续传等策略。"
  },
  {
    "id": 269,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的动画配置？",
    "options": {
      "A": "在页面组件中使用 @RouteAnimation",
      "B": "使用 PageTransition 和 sharedTransition",
      "C": "在 Router.pushUrl() 中设置动画参数",
      "D": "ArkTS不支持路由动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 PageTransition 配置页面转场动画，sharedTransition 配置共享元素动画。"
  },
  {
    "id": 270,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现代码分割？",
    "options": {
      "A": "使用动态 import()",
      "B": "使用 CodeSplit 组件",
      "C": "使用 @Split 装饰器",
      "D": "ArkTS不支持代码分割"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过动态 import() 语法实现代码分割，按需加载模块。"
  },
  {
    "id": 271,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义字符串字面量类型？",
    "options": {
      "A": "type Direction = 'left' | 'right' | 'top' | 'bottom'",
      "B": "type Direction = string['left', 'right', 'top', 'bottom']",
      "C": "type Direction = enum('left', 'right', 'top', 'bottom')",
      "D": "type Direction = string in ['left', 'right', 'top', 'bottom']"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用联合类型定义字符串字面量类型：type Direction = 'left' | 'right' | 'top' | 'bottom'"
  },
  {
    "id": 272,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 XComponent 组件的常用能力？",
    "options": {
      "A": "原生渲染",
      "B": "3D图形",
      "C": "自定义绘制",
      "D": "视频播放"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "XComponent 组件支持原生渲染、3D图形、自定义绘制和视频播放等能力。"
  },
  {
    "id": 273,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的类型推导？",
    "options": {
      "A": "使用 TypeScript 的类型推断",
      "B": "使用 @Infer 装饰器",
      "C": "使用运行时类型检查",
      "D": "ArkTS不支持类型推导"
    },
    "answer": [
      "A"
    ],
    "explanation": "充分利用 TypeScript 的类型推断能力，减少手动类型注解。"
  },
  {
    "id": 274,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的国际化组件？",
    "options": {
      "A": "使用 @I18n 装饰器",
      "B": "使用 @Consume 注入国际化数据",
      "C": "使用 I18nManager 类",
      "D": "ArkTS不支持国际化组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @Consume 装饰器注入国际化数据，实现多语言支持。"
  },
  {
    "id": 275,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Shape 组件的常用形状？",
    "options": {
      "A": "Rectangle",
      "B": "Circle",
      "C": "Ellipse",
      "D": "Path"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Shape 组件支持 Rectangle（矩形）、Circle（圆形）、Ellipse（椭圆）、Path（路径）等形状。"
  },
  {
    "id": 276,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建波浪动画效果？",
    "options": {
      "A": "使用 wave() 方法",
      "B": "使用正弦函数控制形状变化",
      "C": "使用 WaveAnimation",
      "D": "ArkTS不支持波浪动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过正弦函数控制形状的顶点位置，创建波浪动画效果。"
  },
  {
    "id": 277,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的认证刷新？",
    "options": {
      "A": "使用 http.refreshToken()",
      "B": "拦截401响应并自动刷新token",
      "C": "使用 AuthRefresher 类",
      "D": "ArkTS不支持认证刷新"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过拦截401未授权响应，自动刷新认证token并重试请求。"
  },
  {
    "id": 278,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据归档的常见策略？",
    "options": {
      "A": "按时间归档",
      "B": "按大小归档",
      "C": "按访问频率归档",
      "D": "按重要性归档"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据归档可以按时间、大小、访问频率和重要性等策略进行。"
  },
  {
    "id": 279,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的降级策略？",
    "options": {
      "A": "使用 Router.fallback()",
      "B": "配置404页面和错误处理",
      "C": "使用 @FallbackRoute 装饰器",
      "D": "ArkTS不支持路由降级"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过配置404错误页面和全局错误处理，实现路由降级策略。"
  },
  {
    "id": 280,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化组件创建性能？",
    "options": {
      "A": "使用 @Reusable 装饰器",
      "B": "避免在渲染中创建新对象",
      "C": "使用对象池",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用可复用组件、避免渲染中创建对象和使用对象池都可以优化组件创建性能。"
  },
  {
    "id": 281,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型守卫？",
    "options": {
      "A": "function isString(value: any): value is string { return typeof value === 'string' }",
      "B": "function isString(value: any): boolean { return typeof value === 'string' }",
      "C": "function isString(value: any): asserts value is string { if (typeof value !== 'string') throw new Error() }",
      "D": "function isString(value: any): string { return String(value) }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 value is Type 语法定义类型守卫函数：function isString(value: any): value is string { return typeof value === 'string' }"
  },
  {
    "id": 282,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 PluginComponent 的常用场景？",
    "options": {
      "A": "第三方库集成",
      "B": "原生能力扩展",
      "C": "跨平台组件",
      "D": "性能监控"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "PluginComponent 常用于第三方库集成、原生能力扩展和跨平台组件开发。"
  },
  {
    "id": 283,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的懒加载？",
    "options": {
      "A": "使用 @LazyState 装饰器",
      "B": "使用 getter 和 setter 延迟初始化",
      "C": "使用 LazyStateManager 类",
      "D": "ArkTS不支持状态懒加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 getter 和 setter 在首次访问时初始化状态，实现懒加载。"
  },
  {
    "id": 284,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的权限组件？",
    "options": {
      "A": "使用 @Permission 装饰器",
      "B": "使用条件渲染和权限数据",
      "C": "使用 PermissionManager 类",
      "D": "ArkTS不支持权限组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件渲染结合权限数据，控制组件的显示和功能。"
  },
  {
    "id": 285,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridContainer 的响应式属性？",
    "options": {
      "A": "breakpoints",
      "B": "columns",
      "C": "gutter",
      "D": "margin"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "GridContainer 支持 breakpoints（断点）、columns（列数）、gutter（间隔）等响应式属性。"
  },
  {
    "id": 286,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建布料模拟动画？",
    "options": {
      "A": "使用 clothSimulation()",
      "B": "使用物理引擎和质点弹簧系统",
      "C": "使用 ClothAnimation",
      "D": "ArkTS不支持布料动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过物理引擎和质点弹簧系统模拟布料物理特性，创建逼真的布料动画。"
  },
  {
    "id": 287,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的数据转换？",
    "options": {
      "A": "在 then() 中手动转换",
      "B": "使用 map() 操作符",
      "C": "使用 DataTransformer 类",
      "D": "ArkTS不支持数据转换"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 Promise 的 then() 回调中手动转换响应数据格式。"
  },
  {
    "id": 288,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据索引的优化策略？",
    "options": {
      "A": "复合索引",
      "B": "部分索引",
      "C": "覆盖索引",
      "D": "哈希索引"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据索引优化包括复合索引、部分索引、覆盖索引和哈希索引等策略。"
  },
  {
    "id": 289,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的滚动恢复？",
    "options": {
      "A": "使用 Router.restoreScroll()",
      "B": "手动保存和恢复滚动位置",
      "C": "使用 @ScrollRestore 装饰器",
      "D": "ArkTS不支持滚动恢复"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动保存离开时的滚动位置，返回时恢复到相应位置。"
  },
  {
    "id": 290,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现虚拟化长列表？",
    "options": {
      "A": "使用 LazyForEach",
      "B": "使用 RecyclerView 类似机制",
      "C": "使用 VirtualList 组件",
      "D": "ArkTS不支持虚拟列表"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 LazyForEach 实现列表项的虚拟化，只渲染可见区域的项。"
  },
  {
    "id": 291,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何定义索引签名？",
    "options": {
      "A": "interface StringArray { [index: number]: string }",
      "B": "interface StringArray { index: number -> string }",
      "C": "interface StringArray { (index: number): string }",
      "D": "interface StringArray { get(index: number): string }"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 [index: type]: valueType 语法定义索引签名：interface StringArray { [index: number]: string }"
  },
  {
    "id": 292,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 CanvasRenderer 的常用方法？",
    "options": {
      "A": "fillRect",
      "B": "strokeRect",
      "C": "clearRect",
      "D": "getContext"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "CanvasRenderer 支持 fillRect（填充矩形）、strokeRect（描边矩形）、clearRect（清除矩形）等方法。"
  },
  {
    "id": 293,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的压缩？",
    "options": {
      "A": "使用 @Compressed 装饰器",
      "B": "使用差异算法减少状态更新",
      "C": "使用 StateCompressor 类",
      "D": "ArkTS不支持状态压缩"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过差异算法比较状态变化，只更新发生变化的部分，减少状态传输量。"
  },
  {
    "id": 294,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的图表组件？",
    "options": {
      "A": "使用 @Chart 装饰器",
      "B": "使用 @BuilderParam 接收配置数据",
      "C": "使用 ChartEngine 类",
      "D": "ArkTS不支持图表组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收图表配置数据，实现可配置的图表组件。"
  },
  {
    "id": 295,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Stack 组件的层级管理属性？",
    "options": {
      "A": "zIndex",
      "B": "position",
      "C": "align",
      "D": "fit"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Stack 组件的 zIndex（层级）和 position（位置）属性用于管理子组件的层级关系。"
  },
  {
    "id": 296,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建流光动画效果？",
    "options": {
      "A": "使用 flow() 方法",
      "B": "使用线性渐变和位移动画",
      "C": "使用 FlowAnimation",
      "D": "ArkTS不支持流光动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过线性渐变背景配合位移动画，创建流光效果。"
  },
  {
    "id": 297,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的链路追踪？",
    "options": {
      "A": "使用 http.trace() 方法",
      "B": "在请求头中添加追踪ID",
      "C": "使用 TraceMonitor 类",
      "D": "ArkTS不支持链路追踪"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在请求头中添加唯一追踪ID，实现请求链路的追踪和调试。"
  },
  {
    "id": 298,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据清理的常见策略？",
    "options": {
      "A": "按时间清理",
      "B": "按大小清理",
      "C": "按访问记录清理",
      "D": "按业务逻辑清理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据清理可以按时间、大小、访问记录和业务逻辑等策略进行。"
  },
  {
    "id": 299,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的A/B测试？",
    "options": {
      "A": "使用 Router.abTest()",
      "B": "根据用户分组动态选择路由",
      "C": "使用 ABTestRouter 类",
      "D": "ArkTS不支持A/B测试"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据用户分组信息，在路由跳转时动态选择不同的目标页面。"
  },
  {
    "id": 300,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化图片加载性能？",
    "options": {
      "A": "使用合适的图片格式",
      "B": "使用图片懒加载",
      "C": "使用图片压缩",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "选择合适的图片格式、实现懒加载和使用压缩都可以优化图片加载性能。"
  },
  {
    "id": 301,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中声明字符串变量的正确方式是？",
    "options": {
      "A": "let str: string = 'hello'",
      "B": "var str: String = 'hello'",
      "C": "string str = 'hello'",
      "D": "str: string = 'hello'"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 let 声明变量，字符串类型为 string，正确语法是 let str: string = 'hello'"
  },
  {
    "id": 302,
    "type": "single",
    "category": "组件开发",
    "difficulty": "简单",
    "question": "以下哪个是 ArkTS 中的基础容器组件？",
    "options": {
      "A": "Text",
      "B": "Column",
      "C": "Button",
      "D": "Image"
    },
    "answer": [
      "B"
    ],
    "explanation": "Column 是 ArkTS 中常用的垂直布局容器组件，属于基础容器组件"
  },
  {
    "id": 303,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中的状态装饰器？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Link",
      "D": "@Store"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "@State、@Prop、@Link 都是 ArkTS 中的状态装饰器，用于组件间的状态管理，没有 @Store 装饰器"
  },
  {
    "id": 304,
    "type": "single",
    "category": "布局设计",
    "difficulty": "简单",
    "question": "想要实现水平排列的组件布局，应使用哪个容器组件？",
    "options": {
      "A": "Row",
      "B": "Column",
      "C": "List",
      "D": "Stack"
    },
    "answer": [
      "A"
    ],
    "explanation": "Row 组件用于实现水平方向的布局，Column 用于垂直方向布局"
  },
  {
    "id": 305,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确定义一个函数？",
    "options": {
      "A": "function add (a: number, b: number): number { return a + b }",
      "B": "func add (a: number, b: number): number { return a + b }",
      "C": "def add (a: number, b: number): number { return a + b }",
      "D": "method add (a: number, b: number): number { return a + b }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 使用 function 关键字定义函数，语法为 function 函数名 (参数): 返回类型 { ... }"
  },
  {
    "id": 306,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "以下哪些是 ArkTS 中的交互组件？",
    "options": {
      "A": "Button",
      "B": "TextField",
      "C": "Checkbox",
      "D": "Text"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Button（按钮）、TextField（输入框）、Checkbox（复选框）都是交互组件，Text 是文本展示组件"
  },
  {
    "id": 307,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@State 装饰器的作用是？",
    "options": {
      "A": "用于父组件向子组件传递只读状态",
      "B": "用于标记组件内部的状态，状态变化会触发 UI 更新",
      "C": "用于实现父子组件双向数据绑定",
      "D": "用于跨组件共享全局状态"
    },
    "answer": [
      "B"
    ],
    "explanation": "@State 用于标记组件内部的状态变量，当变量值发生变化时，会自动触发组件的重新渲染"
  },
  {
    "id": 308,
    "type": "single",
    "category": "应用配置",
    "difficulty": "中等",
    "question": "鸿蒙应用的配置文件通常放在哪个目录？",
    "options": {
      "A": "entry/src/main/resources",
      "B": "entry/src/main/config",
      "C": "entry/src/main/ets",
      "D": "entry/src/main/manifest"
    },
    "answer": [
      "D"
    ],
    "explanation": "鸿蒙应用的配置文件（如 config.json）通常存放在 entry/src/main/manifest 目录下"
  },
  {
    "id": 309,
    "type": "multiple",
    "category": "布局属性",
    "difficulty": "中等",
    "question": "以下哪些属性可以用于设置组件的尺寸？",
    "options": {
      "A": "width",
      "B": "height",
      "C": "size",
      "D": "layoutWeight"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "width 和 height 用于设置组件的具体尺寸，layoutWeight 用于设置布局权重，没有 size 属性"
  },
  {
    "id": 310,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，注释的正确写法是？",
    "options": {
      "A": "// 这是单行注释",
      "B": "/* 这是单行注释 /",
      "C": "",
      "D": "# 这是单行注释"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中单行注释使用 //，多行注释使用 / */"
  },
  {
    "id": 311,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "组件初始化时会调用哪个生命周期函数？",
    "options": {
      "A": "onCreate ()",
      "B": "onInit ()",
      "C": "onAppear ()",
      "D": "onShow ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onCreate () 是组件初始化时调用的生命周期函数，在组件创建时执行"
  },
  {
    "id": 312,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "困难",
    "question": "关于 ArkTS 中的路由管理，以下说法正确的有？",
    "options": {
      "A": "可以使用 router.pushUrl () 进行页面跳转",
      "B": "可以使用 router.back () 返回上一页",
      "C": "路由参数可以通过 router.getParams () 获取",
      "D": "路由配置在 main_pages.json 文件中"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 中路由管理相关的 API 包括 router.pushUrl () 跳转页面、router.back () 返回上一页，通过 router.getParams () 获取参数，路由配置在 main_pages.json 文件中"
  },
  {
    "id": 313,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置组件的背景颜色为红色？",
    "options": {
      "A": ".background (Color.Red)",
      "B": ".bg ('red')",
      "C": ".backgroundColor ('red')",
      "D": ".color (Color.Red)"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用.background () 方法设置组件背景色，参数可以是 Color 类的静态属性"
  },
  {
    "id": 314,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Link 装饰器的作用是？",
    "options": {
      "A": "用于父组件向子组件传递状态，子组件可修改并同步给父组件",
      "B": "用于标记组件内部的私有状态",
      "C": "用于跨组件共享状态",
      "D": "用于从全局状态中获取值"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Link 用于实现父子组件间的双向数据绑定，子组件修改状态会同步到父组件"
  },
  {
    "id": 315,
    "type": "multiple",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中支持的基本数据类型有哪些？",
    "options": {
      "A": "number",
      "B": "string",
      "C": "boolean",
      "D": "object"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 支持 number（数值）、string（字符串）、boolean（布尔值）、object（对象）等基本数据类型"
  },
  {
    "id": 316,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示图片的组件是？",
    "options": {
      "A": "Image",
      "B": "Picture",
      "C": "Photo",
      "D": "Img"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 Image 组件显示图片，通过 src 属性指定图片路径"
  },
  {
    "id": 317,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "想要实现层叠布局，应使用哪个容器组件？",
    "options": {
      "A": "Stack",
      "B": "Layer",
      "C": "Cascade",
      "D": "Overlay"
    },
    "answer": [
      "A"
    ],
    "explanation": "Stack 组件用于实现层叠布局，子组件会按照添加顺序依次堆叠显示"
  },
  {
    "id": 318,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中常用的事件处理方法？",
    "options": {
      "A": ".onClick (() => {})",
      "B": ".onTouch (() => {})",
      "C": ".onChange (() => {})",
      "D": ".onPress (() => {})"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "onClick（点击事件）、onTouch（触摸事件）、onChange（变化事件）都是 ArkTS 中常用的事件处理方法，没有 onPress 方法"
  },
  {
    "id": 319,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何定义一个接口？",
    "options": {
      "A": "interface Person { name: string; age: number }",
      "B": "interface Person { name: string, age: number }",
      "C": "interface Person { name string; age number }",
      "D": "interface Person { name: string; age: number; }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中定义接口使用 interface 关键字，属性之间使用分号分隔，最后一个属性后可以省略分号"
  },
  {
    "id": 320,
    "type": "single",
    "category": "组件开发",
    "difficulty": "简单",
    "question": "@Component 装饰器的作用是？",
    "options": {
      "A": "标记一个自定义组件",
      "B": "标记应用的入口组件",
      "C": "标记一个页面组件",
      "D": "标记一个共享组件"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Component 装饰器用于标记一个自定义组件，使其可以在其他组件中使用"
  },
  {
    "id": 321,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个 API 可以获取当前设备的信息？",
    "options": {
      "A": "deviceManager.getDeviceList ()",
      "B": "deviceManager.getLocalDeviceInfo ()",
      "C": "deviceManager.getRemoteDeviceInfo ()",
      "D": "deviceManager.getDeviceInfo ()"
    },
    "answer": [
      "B"
    ],
    "explanation": "deviceManager.getLocalDeviceInfo () 用于获取当前设备的信息，getDeviceList () 用于获取设备列表"
  },
  {
    "id": 322,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的边框？",
    "options": {
      "A": ".borderWidth (2)",
      "B": ".borderColor (Color.Black)",
      "C": ".borderRadius (5)",
      "D": ".border ('solid')"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "borderWidth 设置边框宽度，borderColor 设置边框颜色，borderRadius 设置边框圆角，ArkTS 中没有 border 方法设置边框样式"
  },
  {
    "id": 323,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Prop 装饰器与 @Link 装饰器的主要区别是？",
    "options": {
      "A": "@Prop 是单向绑定，@Link 是双向绑定",
      "B": "@Prop 是双向绑定，@Link 是单向绑定",
      "C": "@Prop 用于跨组件，@Link 用于组件内部",
      "D": "@Prop 用于数组，@Link 用于对象"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Prop 是父组件向子组件的单向数据绑定，子组件修改不会影响父组件；@Link 是双向绑定，子组件修改会同步到父组件"
  },
  {
    "id": 324,
    "type": "single",
    "category": "布局设计",
    "difficulty": "简单",
    "question": "如何设置组件在父容器中居中显示？",
    "options": {
      "A": ".align (Alignment.Center)",
      "B": ".center ()",
      "C": ".position ('center')",
      "D": ".layoutAlign ('center')"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.align (Alignment.Center) 方法可以设置组件在父容器中居中显示，Alignment 是 ArkTS 中的对齐枚举类"
  },
  {
    "id": 325,
    "type": "multiple",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪些是合法的循环语句？",
    "options": {
      "A": "for (let i = 0; i < 10; i++) { ... }",
      "B": "for (let item of array) { ... }",
      "C": "while (condition) { ... }",
      "D": "do { ... } while (condition)"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 支持 for 循环、for...of 循环、while 循环和 do...while 循环等常见循环语句"
  },
  {
    "id": 326,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示列表数据的组件是？",
    "options": {
      "A": "List",
      "B": "ListView",
      "C": "RecyclerView",
      "D": "Array"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 List 组件显示列表数据，配合 ListItem 组件使用"
  },
  {
    "id": 327,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "组件从界面消失时会调用哪个生命周期函数？",
    "options": {
      "A": "onDisappear ()",
      "B": "onDestroy ()",
      "C": "onHide ()",
      "D": "onExit ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onDisappear () 在组件从界面消失时调用，onDestroy () 在组件销毁时调用"
  },
  {
    "id": 328,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由跳转的方式？",
    "options": {
      "A": "pushUrl",
      "B": "replaceUrl",
      "C": "pushPath",
      "D": "replacePath"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "ArkTS 中路由跳转的方式主要有 pushUrl（压入新页面）和 replaceUrl（替换当前页面）"
  },
  {
    "id": 329,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置文本组件的字体大小？",
    "options": {
      "A": ".fontSize (16)",
      "B": ".textSize (16)",
      "C": ".size (16)",
      "D": ".font (16)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.fontSize () 方法设置文本组件的字体大小，参数为数值类型"
  },
  {
    "id": 330,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何定义一个空数组？",
    "options": {
      "A": "let arr: number [] = []",
      "B": "let arr: array = []",
      "C": "let arr = new Array ()",
      "D": "let arr: [] = []"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中定义空数组的正确方式是指定数组元素类型，如 let arr: number [] = [] 表示数字类型的空数组"
  },
  {
    "id": 331,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@Builder 装饰器的作用是？",
    "options": {
      "A": "定义可复用的 UI 片段",
      "B": "定义组件的生命周期",
      "C": "定义组件的样式",
      "D": "定义组件的事件"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Builder 用于定义可复用的 UI 片段，类似于其他框架中的模板，可以在组件中多次调用"
  },
  {
    "id": 332,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "关于鸿蒙分布式数据管理，以下说法正确的有？",
    "options": {
      "A": "AppStorage 用于应用级别的数据共享",
      "B": "LocalStorage 用于组件级别的数据存储",
      "C": "DistributedData 用于跨设备数据同步",
      "D": "Preferences 用于持久化数据存储"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "鸿蒙提供了多种数据管理方式：AppStorage 应用级共享、LocalStorage 组件级存储、DistributedData 跨设备同步、Preferences 持久化存储"
  },
  {
    "id": 333,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪个属性可以设置组件之间的间距？",
    "options": {
      "A": "spacing",
      "B": "margin",
      "C": "padding",
      "D": "gap"
    },
    "answer": [
      "A"
    ],
    "explanation": "Row 和 Column 容器组件可以通过 spacing 属性设置子组件之间的间距"
  },
  {
    "id": 334,
    "type": "single",
    "category": "事件处理",
    "difficulty": "简单",
    "question": "如何为按钮添加点击事件？",
    "options": {
      "A": "Button (' 点击 ').onClick (() => { console.log (' 点击了 ') })",
      "B": "Button (' 点击 ').click (() => { console.log (' 点击了 ') })",
      "C": "Button (' 点击 ', () => { console.log (' 点击了 ') })",
      "D": "Button (' 点击 ').on ('click', () => { console.log (' 点击了 ') })"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用.onClick () 方法为组件添加点击事件，参数为事件处理函数"
  },
  {
    "id": 335,
    "type": "multiple",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪些是合法的条件语句？",
    "options": {
      "A": "if (condition) { ... }",
      "B": "if (condition) { ... } else { ... }",
      "C": "if (condition) { ... } else if (condition) { ... } else { ... }",
      "D": "switch (value) { case 1: ... break; default: ... }"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 支持 if、if...else、if...else if...else 和 switch 等常见条件语句"
  },
  {
    "id": 336,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于输入文本的组件是？",
    "options": {
      "A": "TextField",
      "B": "TextInput",
      "C": "EditText",
      "D": "InputText"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 TextField 组件实现文本输入功能"
  },
  {
    "id": 337,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "AppStorage 和 LocalStorage 的主要区别是？",
    "options": {
      "A": "AppStorage 是应用级别的全局存储，LocalStorage 是组件级别的局部存储",
      "B": "AppStorage 是持久化存储，LocalStorage 是内存存储",
      "C": "AppStorage 用于跨设备共享，LocalStorage 用于本地存储",
      "D": "AppStorage 容量更大，LocalStorage 容量更小"
    },
    "answer": [
      "A"
    ],
    "explanation": "AppStorage 是应用级别的全局状态存储，整个应用都可以访问；LocalStorage 是组件级别的状态存储，仅在当前组件及其子组件中有效"
  },
  {
    "id": 338,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "以下哪些方法可以设置文本的样式？",
    "options": {
      "A": ".fontWeight (FontWeight.Bold)",
      "B": ".fontStyle (FontStyle.Italic)",
      "C": ".textDecoration (TextDecoration.Underline)",
      "D": ".textAlign (TextAlign.Center)"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "以上方法都可以用于设置文本样式：fontWeight 设置字重，fontStyle 设置字体样式，textDecoration 设置文本装饰，textAlign 设置文本对齐方式"
  },
  {
    "id": 339,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，如何声明一个常量？",
    "options": {
      "A": "const PI: number = 3.14",
      "B": "constant PI: number = 3.14",
      "C": "final PI: number = 3.14",
      "D": "let PI: number = 3.14"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 const 关键字声明常量，常量声明后不能被修改"
  },
  {
    "id": 340,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@Entry 装饰器的作用是？",
    "options": {
      "A": "标记应用的入口组件",
      "B": "标记组件的入口函数",
      "C": "标记页面的入口路径",
      "D": "标记组件的初始化方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Entry 装饰器用于标记应用的入口组件，应用启动时会加载该组件"
  },
  {
    "id": 341,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个 API 可以实现跨设备页面跳转？",
    "options": {
      "A": "deviceRouter.pushRemoteUrl ()",
      "B": "router.pushDistributedUrl ()",
      "C": "distributedRouter.pushUrl ()",
      "D": "remoteRouter.pushUrl ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "deviceRouter.pushRemoteUrl () 用于实现跨设备页面跳转，是鸿蒙分布式能力的重要 API"
  },
  {
    "id": 342,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中的常用布局容器？",
    "options": {
      "A": "Column",
      "B": "Row",
      "C": "Stack",
      "D": "Grid"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Column（垂直布局）、Row（水平布局）、Stack（层叠布局）、Grid（网格布局）都是 ArkTS 中常用的布局容器"
  },
  {
    "id": 343,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何获取点击事件的坐标信息？",
    "options": {
      "A": ".onClick ((event: ClickEvent) => { console.log (event.x, event.y) })",
      "B": ".onClick ((x: number, y: number) => { console.log (x, y) })",
      "C": ".onClick (() => { console.log (this.x, this.y) })",
      "D": ".onClick (event => { console.log (event.offsetX, event.offsetY) })"
    },
    "answer": [
      "A"
    ],
    "explanation": "点击事件的处理函数可以接收 ClickEvent 类型的参数，通过该参数的 x 和 y 属性获取点击坐标"
  },
  {
    "id": 344,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，箭头函数的正确写法是？",
    "options": {
      "A": "(a: number, b: number) => a + b",
      "B": "function (a: number, b: number) => a + b",
      "C": "(a: number, b: number) -> a + b",
      "D": "a: number, b: number => a + b"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中箭头函数的语法是 (参数) => 表达式或语句块，如 (a: number, b: number) => a + b"
  },
  {
    "id": 345,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中的选择类组件？",
    "options": {
      "A": "Checkbox",
      "B": "Radio",
      "C": "Switch",
      "D": "Picker"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Checkbox（复选框）、Radio（单选框）、Switch（开关）都是选择类组件，Picker 是选择器组件"
  },
  {
    "id": 346,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "组件布局发生变化时会调用哪个生命周期函数？",
    "options": {
      "A": "onLayout ()",
      "B": "onResize ()",
      "C": "onRelayout ()",
      "D": "onChangeLayout ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onLayout () 在组件布局发生变化时调用，可以在该函数中处理布局相关的逻辑"
  },
  {
    "id": 347,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由参数传递的方式有哪些？",
    "options": {
      "A": "通过 url 的 query 参数传递",
      "B": "通过 params 属性传递",
      "C": "通过全局变量传递",
      "D": "通过 AppStorage 传递"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 中路由参数传递的方式包括：url 的 query 参数、params 属性、全局变量和 AppStorage 等"
  },
  {
    "id": 348,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置组件的内边距？",
    "options": {
      "A": ".padding (10)",
      "B": ".innerPadding (10)",
      "C": ".paddingInside (10)",
      "D": ".inner (10)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.padding () 方法设置组件的内边距，参数可以是统一的数值或分别指定上下左右的数值"
  },
  {
    "id": 349,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何定义一个类的构造函数？",
    "options": {
      "A": "constructor (name: string) { this.name = name }",
      "B": "construct (name: string) { this.name = name }",
      "C": "class Constructor (name: string) { this.name = name }",
      "D": "new (name: string) { this.name = name }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 constructor 关键字定义类的构造函数，用于初始化类的实例"
  },
  {
    "id": 350,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何在组件中使用自定义样式？",
    "options": {
      "A": "@Styles function customStyle () { .background (Color.Red) }",
      "B": "style customStyle () { background: red; }",
      "C": ".customStyle { background: red; }",
      "D": "function customStyle () { return { background: Color.Red } }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 @Styles 装饰器定义自定义样式函数，在函数中通过链式调用设置组件样式"
  },
  {
    "id": 351,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个模块用于实现鸿蒙设备间的服务调用？",
    "options": {
      "A": "abilityManager",
      "B": "serviceManager",
      "C": "distributedService",
      "D": "remoteAbility"
    },
    "answer": [
      "A"
    ],
    "explanation": "abilityManager 模块提供了跨设备能力调用的相关 API，用于实现鸿蒙设备间的服务调用"
  },
  {
    "id": 352,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些属性可以用于控制组件的布局位置？",
    "options": {
      "A": "position",
      "B": "offset",
      "C": "margin",
      "D": "align"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "position 设置绝对定位，offset 设置相对偏移，margin 设置外边距，align 设置对齐方式，都可以控制组件的布局位置"
  },
  {
    "id": 353,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何为输入框添加文本变化事件？",
    "options": {
      "A": "TextField ().onChange ((value: string) => { console.log (value) })",
      "B": "TextField ().onTextChange ((value: string) => { console.log (value) })",
      "C": "TextField ().onInput ((value: string) => { console.log (value) })",
      "D": "TextField ().onValueChange ((value: string) => { console.log (value) })"
    },
    "answer": [
      "A"
    ],
    "explanation": "TextField 组件使用.onChange () 方法监听文本变化事件，事件处理函数接收当前输入的文本值"
  },
  {
    "id": 354,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 length 属性表示什么？",
    "options": {
      "A": "数组中元素的个数",
      "B": "数组的容量",
      "C": "数组的最大索引",
      "D": "数组占用的内存大小"
    },
    "answer": [
      "A"
    ],
    "explanation": "数组的 length 属性表示数组中元素的个数，是一个只读属性"
  },
  {
    "id": 355,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "以下哪些是 ArkTS 中的媒体类组件？",
    "options": {
      "A": "Image",
      "B": "Video",
      "C": "Audio",
      "D": "Canvas"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Image（图片）、Video（视频）、Audio（音频）都是媒体类组件，Canvas 是画布组件"
  },
  {
    "id": 356,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Provide 和 @Consume 装饰器的作用是？",
    "options": {
      "A": "用于跨层级组件间的状态共享",
      "B": "用于父子组件间的状态传递",
      "C": "用于组件内部的状态管理",
      "D": "用于全局状态的管理"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Provide 和 @Consume 是一对装饰器，用于跨层级的组件间状态共享，无需通过中间组件传递"
  },
  {
    "id": 357,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的外边距？",
    "options": {
      "A": ".margin (10)",
      "B": ".margin ({ top: 5, bottom: 5 })",
      "C": ".marginLeft (10)",
      "D": ".marginRight (10)"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 提供了多种设置外边距的方法：统一设置、按方向设置、单独设置左右边距等"
  },
  {
    "id": 358,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何对数组进行过滤操作？",
    "options": {
      "A": "array.filter (item => item > 10)",
      "B": "array.where (item => item > 10)",
      "C": "array.select (item => item > 10)",
      "D": "array.find (item => item > 10)"
    },
    "answer": [
      "A"
    ],
    "explanation": "数组的 filter () 方法用于过滤数组元素，返回满足条件的元素组成的新数组"
  },
  {
    "id": 359,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何定义一个带参数的自定义组件？",
    "options": {
      "A": "@Component struct MyComponent { private title: string; build () { ... } }",
      "B": "@Component struct MyComponent (title: string) { build () { ... } }",
      "C": "@Component function MyComponent (title: string) { ... }",
      "D": "@Component class MyComponent { constructor (title: string) { ... } }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中自定义组件通过定义私有属性接收参数，使用时通过属性赋值传递参数"
  },
  {
    "id": 360,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个 API 可以监听设备连接状态的变化？",
    "options": {
      "A": "deviceManager.on ('deviceChange', callback)",
      "B": "deviceManager.listen ('connection', callback)",
      "C": "deviceManager.watch ('deviceStatus', callback)",
      "D": "deviceManager.observe ('deviceConnection', callback)"
    },
    "answer": [
      "A"
    ],
    "explanation": "deviceManager.on ('deviceChange', callback) 用于监听设备连接状态的变化，当设备连接或断开时会触发回调函数"
  },
  {
    "id": 361,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持滚动？",
    "options": {
      "A": "Scroll",
      "B": "List",
      "C": "Grid",
      "D": "Column"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Scroll 是专门的滚动容器，List 和 Grid 在内容超出显示区域时也支持滚动，Column 本身不支持滚动"
  },
  {
    "id": 362,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何为列表项添加点击事件？",
    "options": {
      "A": "ListItem ().onClick (() => { ... })",
      "B": "List ().onItemClick ((index: number) => { ... })",
      "C": "ListItem ({ onClick: () => { ... } })",
      "D": "List ({ onItemClick: () => { ... } })"
    },
    "answer": [
      "A"
    ],
    "explanation": "ListItem 组件可以直接通过.onClick () 方法添加点击事件，处理当前列表项的点击逻辑"
  },
  {
    "id": 363,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，如何访问对象的属性？",
    "options": {
      "A": "obj.property 或 obj ['property']",
      "B": "obj->property",
      "C": "obj::property",
      "D": "obj.getProperty ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中访问对象属性可以使用点语法（obj.property）或方括号语法（obj ['property']）"
  },
  {
    "id": 364,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "中等",
    "question": "以下哪些组件可以用于显示数据集合？",
    "options": {
      "A": "List",
      "B": "Grid",
      "C": "Tabs",
      "D": "Swiper"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "List（列表）和 Grid（网格）用于显示数据集合，Tabs（标签页）和 Swiper（轮播）主要用于页面切换"
  },
  {
    "id": 365,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "如何从 AppStorage 中获取状态？",
    "options": {
      "A": "@StorageProp ('key') value: string",
      "B": "@AppStorage ('key') value: string",
      "C": "@GetStorage ('key') value: string",
      "D": "@Storage ('key') value: string"
    },
    "answer": [
      "A"
    ],
    "explanation": "@StorageProp 装饰器用于从 AppStorage 中获取指定 key 的状态，并建立单向绑定"
  },
  {
    "id": 366,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的阴影效果？",
    "options": {
      "A": ".shadow ({ radius: 5, color: Color.Gray })",
      "B": ".shadowRadius (5)",
      "C": ".shadowColor (Color.Gray)",
      "D": ".boxShadow ('5px 5px 5px gray')"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "ArkTS 中可以通过.shadow () 方法设置阴影的综合属性，也可以通过.shadowRadius ()、.shadowColor () 等方法单独设置阴影的各个属性"
  },
  {
    "id": 367,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何实现异步操作？",
    "options": {
      "A": "使用 async/await",
      "B": "使用 Promise",
      "C": "使用 callback",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS 支持多种异步操作方式，包括 async/await、Promise 和回调函数（callback）"
  },
  {
    "id": 368,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何在组件中使用条件渲染？",
    "options": {
      "A": "if (condition) { Text (' 显示 ') }",
      "B": "<if condition={condition}><Text>显示</Text></if>",
      "C": "Condition (condition).then (() => Text (' 显示 '))",
      "D": "showIf (condition, () => Text (' 显示 '))"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中直接使用 if 语句进行条件渲染，当条件为 true 时渲染对应的组件"
  },
  {
    "id": 369,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个模块用于实现鸿蒙设备间的数据同步？",
    "options": {
      "A": "distributedData",
      "B": "syncManager",
      "C": "dataSync",
      "D": "distributedSync"
    },
    "answer": [
      "A"
    ],
    "explanation": "distributedData 模块提供了分布式数据管理的相关 API，用于实现鸿蒙设备间的数据同步"
  },
  {
    "id": 370,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些属性可以用于设置布局的弹性效果？",
    "options": {
      "A": "flexGrow",
      "B": "flexShrink",
      "C": "flexBasis",
      "D": "layoutWeight"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "flexGrow、flexShrink、flexBasis 是弹性布局的标准属性，layoutWeight 是 ArkTS 中用于设置布局权重的属性，也具有弹性效果"
  },
  {
    "id": 371,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何为滑动组件添加滑动事件？",
    "options": {
      "A": ".onScroll ((x: number, y: number) => { ... })",
      "B": ".onSwipe ((x: number, y: number) => { ... })",
      "C": ".onDrag ((x: number, y: number) => { ... })",
      "D": ".onMove ((x: number, y: number) => { ... })"
    },
    "answer": [
      "A"
    ],
    "explanation": "滑动组件使用.onScroll () 方法添加滑动事件，事件处理函数接收滑动的 x 和 y 坐标参数"
  },
  {
    "id": 372,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，typeof 运算符的作用是？",
    "options": {
      "A": "返回变量的类型",
      "B": "定义变量的类型",
      "C": "检查变量是否为指定类型",
      "D": "转换变量的类型"
    },
    "answer": [
      "A"
    ],
    "explanation": "typeof 运算符用于返回变量的类型，如 typeof 'hello' 返回'string'"
  },
  {
    "id": 373,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中的导航类组件？",
    "options": {
      "A": "Tabs",
      "B": "Navigator",
      "C": "SideBarContainer",
      "D": "TitleBar"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Tabs（标签导航）、Navigator（导航链接）、SideBarContainer（侧边栏导航）都是导航类组件"
  },
  {
    "id": 374,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@StorageLink 装饰器的作用是？",
    "options": {
      "A": "与 AppStorage 建立双向绑定",
      "B": "与 LocalStorage 建立双向绑定",
      "C": "与全局状态建立单向绑定",
      "D": "与父组件状态建立双向绑定"
    },
    "answer": [
      "A"
    ],
    "explanation": "@StorageLink 装饰器用于与 AppStorage 中的状态建立双向绑定，组件修改状态会同步到 AppStorage"
  },
  {
    "id": 375,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的透明度？",
    "options": {
      "A": ".opacity (0.5)",
      "B": ".transparent (0.5)",
      "C": ".alpha (0.5)",
      "D": ".transparency (0.5)"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用.opacity () 方法设置组件的透明度，参数为 0 到 1 之间的数值，0 表示完全透明，1 表示完全不透明"
  },
  {
    "id": 376,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何将字符串转换为数字？",
    "options": {
      "A": "Number ('123')",
      "B": "parseInt ('123')",
      "C": "+'123'",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "ArkTS 中可以通过 Number ()、parseInt () 或 + 运算符将字符串转换为数字"
  },
  {
    "id": 377,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何实现组件的循环渲染？",
    "options": {
      "A": "ForEach (items, item => Text (item.name), item => item.id)",
      "B": "items.map (item => Text (item.name))",
      "C": "for (let item of items) { Text (item.name) }",
      "D": "Loop (items, item => Text (item.name))"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 ForEach 组件实现循环渲染，参数包括数据源、渲染函数和键生成函数"
  },
  {
    "id": 378,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个 API 可以获取当前设备的网络状态？",
    "options": {
      "A": "network.getStatus ()",
      "B": "connectivity.getNetworkStatus ()",
      "C": "netManager.getStatus ()",
      "D": "networkManager.getNetworkStatus ()"
    },
    "answer": [
      "B"
    ],
    "explanation": "connectivity.getNetworkStatus () 用于获取当前设备的网络状态，包括网络类型、连接状态等信息"
  },
  {
    "id": 379,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些是 Scroll 组件的常用属性？",
    "options": {
      "A": "scrollable",
      "B": "scrollBar",
      "C": "onScroll",
      "D": "scrollTo"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "scrollable 设置滚动方向，scrollBar 设置滚动条显示方式，onScroll 设置滚动事件，scrollTo 用于滚动到指定位置，都是 Scroll 组件的常用属性"
  },
  {
    "id": 380,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何为开关组件添加状态变化事件？",
    "options": {
      "A": "Switch ().onChange ((isOn: boolean) => { ... })",
      "B": "Switch ().onCheck ((isOn: boolean) => { ... })",
      "C": "Switch ().onToggle ((isOn: boolean) => { ... })",
      "D": "Switch ().onSwitch ((isOn: boolean) => { ... })"
    },
    "answer": [
      "A"
    ],
    "explanation": "Switch 组件使用.onChange () 方法添加状态变化事件，事件处理函数接收开关的状态（布尔值）"
  },
  {
    "id": 381,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 push () 方法的作用是？",
    "options": {
      "A": "向数组末尾添加元素",
      "B": "向数组开头添加元素",
      "C": "删除数组末尾的元素",
      "D": "删除数组开头的元素"
    },
    "answer": [
      "A"
    ],
    "explanation": "数组的 push () 方法用于向数组末尾添加一个或多个元素，并返回新的长度"
  },
  {
    "id": 382,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "中等",
    "question": "以下哪些组件可以用于显示进度？",
    "options": {
      "A": "Progress",
      "B": "Slider",
      "C": "Rating",
      "D": "ProgressBar"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Progress（进度条）、Slider（滑块）、Rating（评分）都可以用于显示进度或程度，ArkTS 中没有 ProgressBar 组件"
  },
  {
    "id": 383,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "如何修改 AppStorage 中的状态？",
    "options": {
      "A": "AppStorage.SetOrCreate ('key', value)",
      "B": "AppStorage.set ('key', value)",
      "C": "AppStorage.update ('key', value)",
      "D": "AppStorage.change ('key', value)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 AppStorage.SetOrCreate ('key', value) 方法修改 AppStorage 中的状态，如果 key 不存在则创建"
  },
  {
    "id": 384,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的颜色？",
    "options": {
      "A": ".fontColor (Color.Red)",
      "B": ".textColor (Color.Red)",
      "C": ".color (Color.Red)",
      "D": ".textFontColor (Color.Red)"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "ArkTS 中可以使用.fontColor () 或.color () 方法设置文本的颜色"
  },
  {
    "id": 385,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何定义一个泛型函数？",
    "options": {
      "A": "function identity<T>(arg: T): T { return arg }",
      "B": "function identity(arg: any): any { return arg }",
      "C": "function<T> identity (arg: T): T { return arg }",
      "D": "generic function identity (arg: T): T { return arg }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中定义泛型函数的语法是在函数名后使用<T>声明类型参数，如 function identity<T>(arg: T): T { return arg }"
  },
  {
    "id": 386,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@Extend 装饰器的作用是？",
    "options": {
      "A": "扩展已有组件的功能",
      "B": "继承父组件的属性",
      "C": "实现组件的多态",
      "D": "封装组件的样式"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Extend 装饰器用于扩展已有组件的功能，可以为特定组件添加新的方法或样式"
  },
  {
    "id": 387,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个 API 可以实现跨设备数据共享？",
    "options": {
      "A": "distributedData.createKVManager ()",
      "B": "dataShare.createShareManager ()",
      "C": "shareData.createDistributedManager ()",
      "D": "kvStore.createDistributedStore ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "distributedData.createKVManager () 用于创建分布式键值对管理器，实现跨设备数据共享"
  },
  {
    "id": 388,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些是 Grid 组件的常用属性？",
    "options": {
      "A": "columnsTemplate",
      "B": "rowsTemplate",
      "C": "onItemClick",
      "D": "spacing"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "columnsTemplate 设置列模板，rowsTemplate 设置行模板，onItemClick 设置点击事件，spacing 设置间距，都是 Grid 组件的常用属性"
  },
  {
    "id": 389,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何为复选框添加状态变化事件？",
    "options": {
      "A": "Checkbox ().onChange ((isChecked: boolean) => { ... })",
      "B": "Checkbox ().onCheck ((isChecked: boolean) => { ... })",
      "C": "Checkbox ().onSelect ((isChecked: boolean) => { ... })",
      "D": "Checkbox ().onToggle ((isChecked: boolean) => { ... })"
    },
    "answer": [
      "A"
    ],
    "explanation": "Checkbox 组件使用.onChange () 方法添加状态变化事件，事件处理函数接收复选框的选中状态（布尔值）"
  },
  {
    "id": 390,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 map () 方法的作用是？",
    "options": {
      "A": "对数组中的每个元素进行处理，返回新数组",
      "B": "过滤数组中的元素，返回满足条件的元素",
      "C": "对数组中的元素进行累加，返回一个值",
      "D": "查找数组中满足条件的第一个元素"
    },
    "answer": [
      "A"
    ],
    "explanation": "数组的 map () 方法对数组中的每个元素执行指定的函数，返回一个由执行结果组成的新数组"
  },
  {
    "id": 391,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中的交互反馈组件？",
    "options": {
      "A": "Toast",
      "B": "Dialog",
      "C": "Menu",
      "D": "Badge"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Toast（提示框）、Dialog（对话框）、Menu（菜单）都是交互反馈组件，Badge 是标记组件"
  },
  {
    "id": 392,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 和 AppStorage 的主要区别是？",
    "options": {
      "A": "LocalStorage 是组件级的，AppStorage 是应用级的",
      "B": "LocalStorage 是持久化的，AppStorage 是内存中的",
      "C": "LocalStorage 支持跨设备，AppStorage 只支持本地",
      "D": "LocalStorage 容量更大，AppStorage 容量更小"
    },
    "answer": [
      "A"
    ],
    "explanation": "LocalStorage 是组件级别的状态存储，仅在当前组件及其子组件中有效；AppStorage 是应用级别的全局状态存储，整个应用都可以访问"
  },
  {
    "id": 393,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的圆角？",
    "options": {
      "A": ".borderRadius (10)",
      "B": ".border ({ radius: 10 })",
      "C": ".round (10)",
      "D": ".cornerRadius (10)"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "ArkTS 中可以使用.borderRadius () 方法或.border () 方法的 radius 参数设置组件的圆角"
  },
  {
    "id": 394,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何处理 Promise 异步操作？",
    "options": {
      "A": "使用.then () 和.catch () 方法",
      "B": "使用 async/await 关键字",
      "C": "以上都是",
      "D": "以上都不是"
    },
    "answer": [
      "C"
    ],
    "explanation": "ArkTS 中处理 Promise 异步操作可以使用.then () 和.catch () 方法，也可以使用 async/await 关键字"
  },
  {
    "id": 395,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何在组件中使用插槽？",
    "options": {
      "A": "使用 @BuilderParam 定义插槽，使用时在组件标签内添加内容",
      "B": " 使用<slot>标签定义插槽，使用时在组件标签内添加内容 ",
      "C": "使用 slot 属性定义插槽，使用时通过 slot 属性指定内容",
      "D": "使用 slot () 方法定义插槽，使用时通过 slot () 方法添加内容"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 @BuilderParam 装饰器定义组件的插槽，使用组件时在组件标签内添加的内容会填充到插槽中"
  },
  {
    "id": 396,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪个 API 可以获取附近的鸿蒙设备列表？",
    "options": {
      "A": "deviceManager.getDeviceList ()",
      "B": "deviceDiscovery.discoverDevices ()",
      "C": "nearbyDevices.getDeviceList ()",
      "D": "deviceFinder.findDevices ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "deviceManager.getDeviceList () 用于获取附近已连接的鸿蒙设备列表，是分布式开发的常用 API"
  },
  {
    "id": 397,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些是 List 组件的常用属性？",
    "options": {
      "A": "listDirection",
      "B": "divider",
      "C": "onScrollIndex",
      "D": "cachedCount"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "listDirection 设置列表方向，divider 设置分隔线，onScrollIndex 设置滚动到指定索引，cachedCount 设置缓存数量，都是 List 组件的常用属性"
  },
  {
    "id": 398,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何为滑块组件添加值变化事件？",
    "options": {
      "A": "Slider ().onChange ((value: number) => { ... })",
      "B": "Slider ().onValueChange ((value: number) => { ... })",
      "C": "Slider ().onSlide ((value: number) => { ... })",
      "D": "Slider ().onMove ((value: number) => { ... })"
    },
    "answer": [
      "A"
    ],
    "explanation": "Slider 组件使用.onChange () 方法添加值变化事件，事件处理函数接收滑块的当前值"
  },
  {
    "id": 399,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，对象的 keys () 方法的作用是？",
    "options": {
      "A": "返回对象所有属性的键组成的数组",
      "B": "返回对象所有属性的值组成的数组",
      "C": "返回对象所有属性的键值对组成的数组",
      "D": "检查对象是否包含指定的键"
    },
    "answer": [
      "A"
    ],
    "explanation": "Object.keys () 方法返回一个由对象自身的可枚举属性的键组成的数组"
  },
  {
    "id": 400,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "中等",
    "question": "以下哪些是 ArkTS 中的辅助类组件？",
    "options": {
      "A": "Divider",
      "B": "Blank",
      "C": "Spacer",
      "D": "Loading"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Divider（分隔线）、Blank（空白区域）、Spacer（间隔器）、Loading（加载指示器）都是辅助类组件，用于辅助布局和交互"
  },
  {
    "id": 401,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现函数的柯里化？",
    "options": {
      "A": "使用 curry 关键字",
      "B": "使用高阶函数返回函数",
      "C": "使用 @Curry 装饰器",
      "D": "TypeScript不支持函数柯里化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过高阶函数返回新函数的方式实现柯里化：const add = (a: number) => (b: number) => a + b"
  },
  {
    "id": 402,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextPicker 组件的常用属性？",
    "options": {
      "A": "range",
      "B": "selected",
      "C": "onChange",
      "D": "value"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextPicker 组件支持 range（数据范围）、selected（选中索引）、onChange（变化事件）等属性。"
  },
  {
    "id": 403,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的时光旅行？",
    "options": {
      "A": "使用 @TimeTravel 装饰器",
      "B": "维护状态历史记录",
      "C": "使用 StateTimeMachine 类",
      "D": "ArkTS不支持时光旅行"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过维护状态的历史记录，实现状态的撤销、重做和时光旅行功能。"
  },
  {
    "id": 404,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的加载状态组件？",
    "options": {
      "A": "使用 @Loading 装饰器",
      "B": "使用 @BuilderParam 接收加载状态",
      "C": "使用 LoadingManager 类",
      "D": "ArkTS不支持加载状态组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收加载状态和内容，实现可配置的加载组件。"
  },
  {
    "id": 405,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 List 组件的性能优化属性？",
    "options": {
      "A": "cachedCount",
      "B": "scroller",
      "C": "edgeEffect",
      "D": "divider"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "List 组件的 cachedCount（缓存数量）和 scroller（滚动控制器）可以用于性能优化。"
  },
  {
    "id": 406,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建流体模拟动画？",
    "options": {
      "A": "使用 fluidSimulation()",
      "B": "使用物理引擎和粒子系统",
      "C": "使用 FluidAnimation",
      "D": "ArkTS不支持流体动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过物理引擎和粒子系统模拟流体物理特性，创建逼真的流体动画。"
  },
  {
    "id": 407,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的并发控制？",
    "options": {
      "A": "使用 http.concurrency() 方法",
      "B": "使用 Promise.all 和限制函数",
      "C": "使用 ConcurrencyController 类",
      "D": "ArkTS不支持并发控制"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 Promise.all 配合并发限制函数，控制同时执行的请求数量。"
  },
  {
    "id": 408,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据分片的常见策略？",
    "options": {
      "A": "水平分片",
      "B": "垂直分片",
      "C": "范围分片",
      "D": "哈希分片"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据分片支持水平分片、垂直分片、范围分片和哈希分片等策略。"
  },
  {
    "id": 409,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的模态展示？",
    "options": {
      "A": "使用 Router.showModal()",
      "B": "使用模态对话框组件",
      "C": "使用 @ModalRoute 装饰器",
      "D": "ArkTS不支持模态路由"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过模态对话框组件实现路由内容的模态展示效果。"
  },
  {
    "id": 410,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的预加载？",
    "options": {
      "A": "使用 @Preload 装饰器",
      "B": "提前创建但不渲染组件",
      "C": "使用 PreloadManager 类",
      "D": "ArkTS不支持组件预加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过提前创建组件实例但不立即渲染，实现组件的预加载。"
  },
  {
    "id": 411,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现函数的记忆化？",
    "options": {
      "A": "使用 memoize 关键字",
      "B": "使用闭包缓存计算结果",
      "C": "使用 @Memoize 装饰器",
      "D": "TypeScript不支持函数记忆化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过闭包缓存函数计算结果，避免重复计算：const memoize = (fn: Function) => { const cache = new Map(); return (...args) => { /* 缓存逻辑 */ } }"
  },
  {
    "id": 412,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextTimer 组件的常用属性？",
    "options": {
      "A": "format",
      "B": "countDown",
      "C": "onTick",
      "D": "interval"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextTimer 组件支持 format（格式）、countDown（倒计时）、onTick（计时事件）等属性。"
  },
  {
    "id": 413,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的乐观更新？",
    "options": {
      "A": "使用 @Optimistic 装饰器",
      "B": "先更新UI再同步到服务器",
      "C": "使用 OptimisticUpdate 类",
      "D": "ArkTS不支持乐观更新"
    },
    "answer": [
      "B"
    ],
    "explanation": "在请求发送前先更新UI状态，请求失败时回滚状态，实现更好的用户体验。"
  },
  {
    "id": 414,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的错误边界组件？",
    "options": {
      "A": "使用 @ErrorBoundary 装饰器",
      "B": "使用 try-catch 和子组件渲染",
      "C": "使用 ErrorBoundaryManager 类",
      "D": "ArkTS不支持错误边界"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 try-catch 捕获子组件错误，并渲染降级UI，实现错误边界功能。"
  },
  {
    "id": 415,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridRow 的响应式断点属性？",
    "options": {
      "A": "xs",
      "B": "sm",
      "C": "md",
      "D": "lg"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "GridRow 支持 xs（超小）、sm（小）、md（中）、lg（大）等响应式断点。"
  },
  {
    "id": 416,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建心跳动画效果？",
    "options": {
      "A": "使用 heartbeat() 方法",
      "B": "使用缩放动画的循环序列",
      "C": "使用 HeartbeatAnimation",
      "D": "ArkTS不支持心跳动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过缩放动画的循环序列模拟心跳的收缩和扩张效果。"
  },
  {
    "id": 417,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的优先级调度？",
    "options": {
      "A": "使用 http.priority() 方法",
      "B": "手动管理请求优先级队列",
      "C": "使用 PriorityScheduler 类",
      "D": "ArkTS不支持优先级调度"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动管理请求优先级队列，确保高优先级请求优先执行。"
  },
  {
    "id": 418,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据版本控制的常见策略？",
    "options": {
      "A": "乐观锁",
      "B": "悲观锁",
      "C": "时间戳版本",
      "D": "增量版本"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据版本控制支持乐观锁、悲观锁、时间戳版本和增量版本等策略。"
  },
  {
    "id": 419,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的深度链接解析？",
    "options": {
      "A": "使用 Router.parseDeepLink()",
      "B": "手动解析URL参数和路径",
      "C": "使用 DeepLinkParser 类",
      "D": "ArkTS不支持深度链接"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手动解析深度链接的URL参数和路径，映射到对应的路由和参数。"
  },
  {
    "id": 420,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化事件处理性能？",
    "options": {
      "A": "使用事件委托",
      "B": "防抖和节流",
      "C": "避免内联函数",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "事件委托、防抖节流和避免内联函数都可以优化事件处理性能。"
  },
  {
    "id": 421,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的安全转换？",
    "options": {
      "A": "使用 as 关键字",
      "B": "使用类型守卫",
      "C": "使用类型断言函数",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "as 关键字、类型守卫和类型断言函数都可以实现类型的安全转换。"
  },
  {
    "id": 422,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Web 组件的常用属性？",
    "options": {
      "A": "src",
      "B": "onPageStart",
      "C": "onPageFinish",
      "D": "javaScriptAccess"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Web 组件支持 src（网址）、onPageStart（页面开始加载）、onPageFinish（页面加载完成）等属性。"
  },
  {
    "id": 423,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的分布式同步？",
    "options": {
      "A": "使用 @Distributed 装饰器",
      "B": "使用分布式数据管理API",
      "C": "使用 DistributedState 类",
      "D": "ArkTS不支持分布式同步"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过鸿蒙的分布式数据管理API，实现跨设备的状态同步。"
  },
  {
    "id": 424,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的骨架屏组件？",
    "options": {
      "A": "使用 @Skeleton 装饰器",
      "B": "使用 @BuilderParam 接收骨架配置",
      "C": "使用 SkeletonManager 类",
      "D": "ArkTS不支持骨架屏"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收骨架屏的配置数据，实现可配置的骨架屏组件。"
  },
  {
    "id": 425,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 AspectRatio 组件的常用属性？",
    "options": {
      "A": "ratio",
      "B": "adjustMode",
      "C": "minWidth",
      "D": "maxHeight"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "AspectRatio 组件支持 ratio（宽高比）和 adjustMode（调整模式）等属性。"
  },
  {
    "id": 426,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建烟雾模拟动画？",
    "options": {
      "A": "使用 smokeSimulation()",
      "B": "使用粒子系统和噪声函数",
      "C": "使用 SmokeAnimation",
      "D": "ArkTS不支持烟雾动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过粒子系统和噪声函数模拟烟雾的流动和扩散效果。"
  },
  {
    "id": 427,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的自动重试？",
    "options": {
      "A": "使用 http.autoRetry() 方法",
      "B": "封装支持重试的请求函数",
      "C": "使用 AutoRetry 类",
      "D": "ArkTS不支持自动重试"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过封装支持自动重试的请求函数，在失败时自动重试指定次数。"
  },
  {
    "id": 428,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据一致性的保证机制？",
    "options": {
      "A": "事务",
      "B": "锁机制",
      "C": "一致性哈希",
      "D": "副本同步"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据一致性可以通过事务、锁机制、一致性哈希和副本同步等机制保证。"
  },
  {
    "id": 429,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的过渡动画配置？",
    "options": {
      "A": "使用 Router.setTransition()",
      "B": "使用 PageTransition 组件",
      "C": "使用 @RouteTransition 装饰器",
      "D": "ArkTS不支持路由过渡动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用 PageTransition 组件为每个页面配置个性化的转场动画效果。"
  },
  {
    "id": 430,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的懒渲染？",
    "options": {
      "A": "使用 @LazyRender 装饰器",
      "B": "使用条件渲染和 Intersection Observer",
      "C": "使用 LazyRenderManager 类",
      "D": "ArkTS不支持懒渲染"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件渲染和 Intersection Observer API，在组件进入视口时才进行渲染。"
  },
  {
    "id": 431,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现函数的组合？",
    "options": {
      "A": "使用 compose 关键字",
      "B": "使用高阶函数组合多个函数",
      "C": "使用 @Compose 装饰器",
      "D": "TypeScript不支持函数组合"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过高阶函数将多个函数组合成一个新函数：const compose = (...fns) => (x) => fns.reduceRight((v, f) => f(v), x)"
  },
  {
    "id": 432,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 RichText 组件的常用属性？",
    "options": {
      "A": "content",
      "B": "onStart",
      "C": "onComplete",
      "D": "value"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "RichText 组件支持 content（富文本内容）、onStart（加载开始）、onComplete（加载完成）等属性。"
  },
  {
    "id": 433,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的选择性订阅？",
    "options": {
      "A": "使用 @Select 装饰器",
      "B": "使用 computed 和 watch 模式",
      "C": "使用 SelectiveSubscription 类",
      "D": "ArkTS不支持选择性订阅"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 computed 属性和 watch 模式，只订阅需要的状态变化，减少不必要的更新。"
  },
  {
    "id": 434,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的拖拽排序组件？",
    "options": {
      "A": "使用 @DragSort 装饰器",
      "B": "使用手势识别和状态管理",
      "C": "使用 DragSortManager 类",
      "D": "ArkTS不支持拖拽排序"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过手势识别和状态管理，实现列表项的拖拽排序功能。"
  },
  {
    "id": 435,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Flex 布局的弹性属性？",
    "options": {
      "A": "flexGrow",
      "B": "flexShrink",
      "C": "flexBasis",
      "D": "flexWrap"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Flex 布局支持 flexGrow（放大比例）、flexShrink（缩小比例）、flexBasis（初始大小）等弹性属性。"
  },
  {
    "id": 436,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建弹跳动画效果？",
    "options": {
      "A": "使用 bounce() 方法",
      "B": "使用弹簧动画和阻尼参数",
      "C": "使用 BounceAnimation",
      "D": "ArkTS不支持弹跳动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过弹簧动画配合适当的阻尼参数，模拟物体的弹跳物理效果。"
  },
  {
    "id": 437,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的链路监控？",
    "options": {
      "A": "使用 http.monitor() 方法",
      "B": "在关键节点添加性能监控",
      "C": "使用 LinkMonitor 类",
      "D": "ArkTS不支持链路监控"
    },
    "answer": [
      "B"
    ],
    "explanation": "在请求的关键节点添加性能监控点，收集和分析请求链路性能数据。"
  },
  {
    "id": 438,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据压缩的优化策略？",
    "options": {
      "A": "字典压缩",
      "B": "行程压缩",
      "C": "哈夫曼编码",
      "D": "LZ77算法"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据压缩可以使用字典压缩、行程压缩、哈夫曼编码和LZ77等算法优化。"
  },
  {
    "id": 439,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的守卫链？",
    "options": {
      "A": "使用 Router.guardChain()",
      "B": "组合多个路由守卫函数",
      "C": "使用 GuardChain 类",
      "D": "ArkTS不支持守卫链"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过组合多个路由守卫函数，形成完整的路由守卫链。"
  },
  {
    "id": 440,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现内存泄漏检测？",
    "options": {
      "A": "使用 @LeakDetect 装饰器",
      "B": "使用弱引用和垃圾回收监控",
      "C": "使用 LeakDetector 类",
      "D": "ArkTS不支持内存泄漏检测"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过弱引用和垃圾回收监控，检测和定位内存泄漏问题。"
  },
  {
    "id": 441,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归查询？",
    "options": {
      "A": "使用 infer 关键字",
      "B": "使用条件类型和递归",
      "C": "使用 TypeQuery 操作符",
      "D": "TypeScript不支持递归查询"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件类型和递归实现复杂类型的查询和提取：type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }"
  },
  {
    "id": 442,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Video 组件的常用事件？",
    "options": {
      "A": "onStart",
      "B": "onPause",
      "C": "onFinish",
      "D": "onError"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Video 组件支持 onStart（开始播放）、onPause（暂停）、onFinish（播放完成）、onError（播放错误）等事件。"
  },
  {
    "id": 443,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的快照对比？",
    "options": {
      "A": "使用 @SnapshotCompare 装饰器",
      "B": "使用深比较算法对比状态快照",
      "C": "使用 SnapshotComparator 类",
      "D": "ArkTS不支持快照对比"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过深比较算法对比不同时间点的状态快照，分析状态变化。"
  },
  {
    "id": 444,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的无限滚动组件？",
    "options": {
      "A": "使用 @InfiniteScroll 装饰器",
      "B": "使用滚动监听和分页加载",
      "C": "使用 InfiniteScrollManager 类",
      "D": "ArkTS不支持无限滚动"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过滚动监听和分页加载机制，实现无限滚动列表功能。"
  },
  {
    "id": 445,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Blank 组件的常用场景？",
    "options": {
      "A": "占位空间",
      "B": "间隔布局",
      "C": "填充剩余空间",
      "D": "对齐辅助"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Blank 组件可用于占位空间、间隔布局、填充剩余空间和对齐辅助等场景。"
  },
  {
    "id": 446,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建光晕动画效果？",
    "options": {
      "A": "使用 glow() 方法",
      "B": "使用径向渐变和透明度动画",
      "C": "使用 GlowAnimation",
      "D": "ArkTS不支持光晕动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过径向渐变背景配合透明度动画，创建光晕扩散效果。"
  },
  {
    "id": 447,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的签名验证？",
    "options": {
      "A": "使用 http.sign() 方法",
      "B": "在请求头中添加签名信息",
      "C": "使用 SignatureValidator 类",
      "D": "ArkTS不支持签名验证"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在请求头中添加基于请求内容和密钥生成的签名，实现请求的签名验证。"
  },
  {
    "id": 448,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据恢复的常见策略？",
    "options": {
      "A": "从备份恢复",
      "B": "从事务日志恢复",
      "C": "从副本恢复",
      "D": "增量恢复"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据恢复支持从备份恢复、从事务日志恢复、从副本恢复和增量恢复等策略。"
  },
  {
    "id": 449,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的元数据配置？",
    "options": {
      "A": "使用 Router.meta() 方法",
      "B": "扩展路由配置对象",
      "C": "使用 @RouteMeta 装饰器",
      "D": "ArkTS不支持路由元数据"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过扩展路由配置对象，添加权限、标题等元数据信息。"
  },
  {
    "id": 450,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化CSS样式性能？",
    "options": {
      "A": "减少样式规则数量",
      "B": "避免深层嵌套",
      "C": "使用CSS变量",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "减少样式规则、避免深层嵌套和使用CSS变量都可以优化样式性能。"
  },
  {
    "id": 451,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现异步迭代器？",
    "options": {
      "A": "使用 async function* 语法",
      "B": "使用 AsyncIterator 接口",
      "C": "使用 @AsyncIterable 装饰器",
      "D": "TypeScript不支持异步迭代器"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 async function* 语法定义异步生成器函数，实现异步迭代器。"
  },
  {
    "id": 452,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Canvas 的绘图上下文方法？",
    "options": {
      "A": "beginPath",
      "B": "moveTo",
      "C": "lineTo",
      "D": "closePath"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Canvas 的绘图上下文支持 beginPath（开始路径）、moveTo（移动点）、lineTo（画线）、closePath（闭合路径）等方法。"
  },
  {
    "id": 453,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的变更传播优化？",
    "options": {
      "A": "使用 @PropagateOptimize 装饰器",
      "B": "使用不可变数据和结构共享",
      "C": "使用 ChangePropagator 类",
      "D": "ArkTS不支持变更传播优化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过不可变数据和结构共享，减少状态变更时的传播范围。"
  },
  {
    "id": 454,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的步骤条组件？",
    "options": {
      "A": "使用 @Steps 装饰器",
      "B": "使用 @BuilderParam 接收步骤配置",
      "C": "使用 StepsManager 类",
      "D": "ArkTS不支持步骤条"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收步骤配置数据，实现可配置的步骤条组件。"
  },
  {
    "id": 455,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 RelativeContainer 的相对定位规则？",
    "options": {
      "A": "top",
      "B": "bottom",
      "C": "center",
      "D": "baseline"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "RelativeContainer 支持 top（顶部对齐）、bottom（底部对齐）、center（居中对齐）等相对定位规则。"
  },
  {
    "id": 456,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建闪烁动画效果？",
    "options": {
      "A": "使用 blink() 方法",
      "B": "使用透明度动画的快速切换",
      "C": "使用 BlinkAnimation",
      "D": "ArkTS不支持闪烁动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过透明度动画的快速切换，创建元素的闪烁效果。"
  },
  {
    "id": 457,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的负载均衡？",
    "options": {
      "A": "使用 http.balance() 方法",
      "B": "使用多个端点和服务发现",
      "C": "使用 LoadBalancer 类",
      "D": "ArkTS不支持负载均衡"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过多个服务端点和服务发现机制，实现请求的负载均衡。"
  },
  {
    "id": 458,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据查询的优化技巧？",
    "options": {
      "A": "使用索引",
      "B": "避免 SELECT *",
      "C": "分页查询",
      "D": "预编译语句"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据查询优化可以使用索引、避免SELECT*、分页查询和预编译语句等技巧。"
  },
  {
    "id": 459,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的keep-alive？",
    "options": {
      "A": "使用 Router.keepAlive()",
      "B": "使用条件渲染和状态保持",
      "C": "使用 @KeepAlive 装饰器",
      "D": "ArkTS不支持keep-alive"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件渲染和状态保持机制，实现路由组件的keep-alive功能。"
  },
  {
    "id": 460,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现渲染的批处理？",
    "options": {
      "A": "使用 @BatchRender 装饰器",
      "B": "使用微任务队列合并更新",
      "C": "使用 BatchRenderer 类",
      "D": "ArkTS不支持批处理"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过微任务队列合并多个状态更新，减少不必要的重复渲染。"
  },
  {
    "id": 461,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的分布式条件类型？",
    "options": {
      "A": "使用 distribute 关键字",
      "B": "在条件类型中使用泛型联合类型",
      "C": "使用 DistributedCondition 类型",
      "D": "TypeScript不支持分布式条件类型"
    },
    "answer": [
      "B"
    ],
    "explanation": "在条件类型中使用泛型联合类型时，TypeScript会自动进行分布式计算：type ToArray<T> = T extends any ? T[] : never"
  },
  {
    "id": 462,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextInput 的键盘类型？",
    "options": {
      "A": "Normal",
      "B": "Number",
      "C": "Email",
      "D": "Password"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextInput 支持 Normal（普通）、Number（数字）、Email（邮箱）、Password（密码）等键盘类型。"
  },
  {
    "id": 463,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的懒计算？",
    "options": {
      "A": "使用 @LazyComputed 装饰器",
      "B": "使用 getter 和缓存机制",
      "C": "使用 LazyComputation 类",
      "D": "ArkTS不支持懒计算"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 getter 属性和缓存机制，在首次访问时计算并缓存结果。"
  },
  {
    "id": 464,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的颜色选择器组件？",
    "options": {
      "A": "使用 @ColorPicker 装饰器",
      "B": "使用 @BuilderParam 接收颜色配置",
      "C": "使用 ColorPickerManager 类",
      "D": "ArkTS不支持颜色选择器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收颜色配置和回调函数，实现可配置的颜色选择器。"
  },
  {
    "id": 465,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Stack 的对齐方式？",
    "options": {
      "A": "TopStart",
      "B": "TopEnd",
      "C": "BottomStart",
      "D": "Center"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Stack 组件支持 TopStart（左上）、TopEnd（右上）、BottomStart（左下）、Center（居中）等对齐方式。"
  },
  {
    "id": 466,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建水面反射动画？",
    "options": {
      "A": "使用 waterReflection()",
      "B": "使用镜像变换和波动效果",
      "C": "使用 WaterReflectionAnimation",
      "D": "ArkTS不支持水面反射"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过镜像变换和波动效果模拟水面的反射和涟漪效果。"
  },
  {
    "id": 467,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的格式转换？",
    "options": {
      "A": "使用 http.transform() 方法",
      "B": "在拦截器中转换请求响应格式",
      "C": "使用 FormatTransformer 类",
      "D": "ArkTS不支持格式转换"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在请求拦截器中转换请求和响应的数据格式。"
  },
  {
    "id": 468,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据分区的常见策略？",
    "options": {
      "A": "范围分区",
      "B": "列表分区",
      "C": "哈希分区",
      "D": "复合分区"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据分区支持范围分区、列表分区、哈希分区和复合分区等策略。"
  },
  {
    "id": 469,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的动态注册？",
    "options": {
      "A": "使用 Router.register()",
      "B": "动态更新路由配置",
      "C": "使用 @DynamicRoute 装饰器",
      "D": "ArkTS不支持动态注册"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过动态更新路由配置对象，实现路由的动态注册和注销。"
  },
  {
    "id": 470,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化字体加载性能？",
    "options": {
      "A": "使用系统字体",
      "B": "字体子集化",
      "C": "字体预加载",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用系统字体、字体子集化和预加载都可以优化字体加载性能。"
  },
  {
    "id": 471,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现Promise的链式调用？",
    "options": {
      "A": "使用 then() 方法返回新Promise",
      "B": "使用 chain() 方法",
      "C": "使用 @Chainable 装饰器",
      "D": "TypeScript不支持Promise链式调用"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过在 then() 方法中返回新的Promise，实现链式调用：promise.then().then().catch()"
  },
  {
    "id": 472,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextArea 的常用属性？",
    "options": {
      "A": "maxLines",
      "B": "placeholderColor",
      "C": "textAlign",
      "D": "caretColor"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextArea 组件支持 maxLines（最大行数）、placeholderColor（占位符颜色）、textAlign（文本对齐）、caretColor（光标颜色）等属性。"
  },
  {
    "id": 473,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的快照序列化？",
    "options": {
      "A": "使用 @SnapshotSerialize 装饰器",
      "B": "使用自定义序列化器处理复杂对象",
      "C": "使用 SnapshotSerializer 类",
      "D": "ArkTS不支持快照序列化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过自定义序列化器处理循环引用、函数等复杂对象的序列化。"
  },
  {
    "id": 474,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的评分组件？",
    "options": {
      "A": "使用 @Rating 装饰器",
      "B": "使用 @BuilderParam 接收评分配置",
      "C": "使用 RatingManager 类",
      "D": "ArkTS不支持评分组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收评分配置和回调函数，实现可配置的评分组件。"
  },
  {
    "id": 475,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Grid 的布局属性？",
    "options": {
      "A": "template",
      "B": "gap",
      "C": "justifyItems",
      "D": "alignItems"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Grid 组件支持 template（模板）、gap（间隔）、justifyItems（项目主轴对齐）、alignItems（项目交叉轴对齐）等属性。"
  },
  {
    "id": 476,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建脉冲动画效果？",
    "options": {
      "A": "使用 pulse() 方法",
      "B": "使用循环的缩放动画",
      "C": "使用 PulseAnimation",
      "D": "ArkTS不支持脉冲动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过循环的缩放动画模拟元素的脉冲效果。"
  },
  {
    "id": 477,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的流量控制？",
    "options": {
      "A": "使用 http.throttle() 方法",
      "B": "使用令牌桶或漏桶算法",
      "C": "使用 FlowController 类",
      "D": "ArkTS不支持流量控制"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过令牌桶或漏桶算法控制请求的发送速率，实现流量控制。"
  },
  {
    "id": 478,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据备份的验证方法？",
    "options": {
      "A": "校验和验证",
      "B": "完整性验证",
      "C": "恢复测试",
      "D": "差异对比"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据备份验证可以使用校验和、完整性验证、恢复测试和差异对比等方法。"
  },
  {
    "id": 479,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的标签页管理？",
    "options": {
      "A": "使用 Router.tab() 方法",
      "B": "使用 Tabs 组件管理多个页面",
      "C": "使用 @TabRoute 装饰器",
      "D": "ArkTS不支持标签页路由"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 Tabs 组件管理多个页面，实现标签页形式的路由导航。"
  },
  {
    "id": 480,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现虚拟DOM优化？",
    "options": {
      "A": "使用 @VirtualDOM 装饰器",
      "B": "使用差异算法减少实际DOM操作",
      "C": "使用 VirtualDOMEngine 类",
      "D": "ArkTS不支持虚拟DOM"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过差异算法比较虚拟DOM树，只更新发生变化的部分，减少实际DOM操作。"
  },
  {
    "id": 481,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的逆变和协变？",
    "options": {
      "A": "使用 in 和 out 关键字",
      "B": "使用泛型约束",
      "C": "使用 Variance 注解",
      "D": "TypeScript不支持逆变协变"
    },
    "answer": [
      "A"
    ],
    "explanation": "在泛型类型参数中使用 in（逆变）和 out（协变）关键字：interface Processor<in T, out U> { }"
  },
  {
    "id": 482,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 ImageAnimator 的常用属性？",
    "options": {
      "A": "images",
      "B": "state",
      "C": "duration",
      "D": "reverse"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "ImageAnimator 组件支持 images（图片数组）、state（播放状态）、duration（持续时间）等属性。"
  },
  {
    "id": 483,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的原子操作？",
    "options": {
      "A": "使用 @Atomic 装饰器",
      "B": "使用事务保证操作的原子性",
      "C": "使用 AtomicOperation 类",
      "D": "ArkTS不支持原子操作"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过事务机制保证多个状态操作的原子性，要么全部成功，要么全部失败。"
  },
  {
    "id": 484,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的轮播图组件？",
    "options": {
      "A": "使用 @Carousel 装饰器",
      "B": "使用 @BuilderParam 接收轮播配置",
      "C": "使用 CarouselManager 类",
      "D": "ArkTS不支持轮播图"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收轮播配置和内容，实现可配置的轮播图组件。"
  },
  {
    "id": 485,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Row 的对齐方式？",
    "options": {
      "A": "Start",
      "B": "Center",
      "C": "End",
      "D": "SpaceBetween"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Row 组件支持 Start（起始）、Center（居中）、End（末尾）、SpaceBetween（两端对齐）等对齐方式。"
  },
  {
    "id": 486,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建粒子轨迹动画？",
    "options": {
      "A": "使用 particleTrail()",
      "B": "使用粒子系统和路径动画",
      "C": "使用 ParticleTrailAnimation",
      "D": "ArkTS不支持粒子轨迹"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过粒子系统和路径动画，创建粒子沿着指定轨迹运动的动画效果。"
  },
  {
    "id": 487,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的上下文传递？",
    "options": {
      "A": "使用 http.context() 方法",
      "B": "在请求头中传递上下文信息",
      "C": "使用 RequestContext 类",
      "D": "ArkTS不支持上下文传递"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在请求头中传递跟踪ID、用户信息等上下文数据。"
  },
  {
    "id": 488,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据迁移的验证方法？",
    "options": {
      "A": "数据一致性检查",
      "B": "业务逻辑验证",
      "C": "性能基准测试",
      "D": "回滚测试"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据迁移验证可以使用一致性检查、业务逻辑验证、性能测试和回滚测试等方法。"
  },
  {
    "id": 489,
    "type": "single",
    "category": "路由导航",
    "difficulty": "困难",
    "question": "如何实现路由的渐进式加载？",
    "options": {
      "A": "使用 Router.progressiveLoad()",
      "B": "使用代码分割和懒加载",
      "C": "使用 @ProgressiveRoute 装饰器",
      "D": "ArkTS不支持渐进式加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过代码分割和懒加载技术，实现路由组件的渐进式加载。"
  },
  {
    "id": 490,
    "type": "single",
    "category": "性能优化",
    "difficulty": "中等",
    "question": "如何优化JSON处理性能？",
    "options": {
      "A": "使用原生JSON方法",
      "B": "避免深层嵌套",
      "C": "使用流式解析",
      "D": "以上都是"
    },
    "answer": [
      "D"
    ],
    "explanation": "使用原生方法、避免深层嵌套和使用流式解析都可以优化JSON处理性能。"
  },
  {
    "id": 491,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现Generator函数的异步版本？",
    "options": {
      "A": "使用 async function* 语法",
      "B": "使用 AsyncGenerator 接口",
      "C": "使用 @AsyncGenerator 装饰器",
      "D": "TypeScript不支持异步Generator"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 async function* 语法定义异步Generator函数，支持 await 和 yield。"
  },
  {
    "id": 492,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextClock 的格式化选项？",
    "options": {
      "A": "hh:mm:ss",
      "B": "yyyy-MM-dd",
      "C": "EEEE",
      "D": "a"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextClock 支持 hh:mm:ss（时分秒）、yyyy-MM-dd（年月日）、EEEE（星期几）、a（上午/下午）等格式化选项。"
  },
  {
    "id": 493,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的冲突解决？",
    "options": {
      "A": "使用 @ConflictResolution 装饰器",
      "B": "使用时间戳或版本号解决冲突",
      "C": "使用 ConflictResolver 类",
      "D": "ArkTS不支持冲突解决"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过时间戳、版本号或最后写入胜出等策略解决状态冲突。"
  },
  {
    "id": 494,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的树形组件？",
    "options": {
      "A": "使用 @Tree 装饰器",
      "B": "使用递归组件和配置数据",
      "C": "使用 TreeManager 类",
      "D": "ArkTS不支持树形组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归组件和树形配置数据，实现可配置的树形结构组件。"
  },
  {
    "id": 495,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Flex 的换行属性？",
    "options": {
      "A": "NoWrap",
      "B": "Wrap",
      "C": "WrapReverse",
      "D": "Stretch"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Flex 布局支持 NoWrap（不换行）、Wrap（换行）、WrapReverse（反向换行）等换行方式。"
  },
  {
    "id": 496,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建摇摆动画效果？",
    "options": {
      "A": "使用 swing() 方法",
      "B": "使用旋转动画的往复运动",
      "C": "使用 SwingAnimation",
      "D": "ArkTS不支持摇摆动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过旋转动画的往复运动模拟钟摆的摇摆效果。"
  },
  {
    "id": 497,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的服务降级？",
    "options": {
      "A": "使用 http.fallback() 方法",
      "B": "提供备用方案和默认数据",
      "C": "使用 FallbackService 类",
      "D": "ArkTS不支持服务降级"
    },
    "answer": [
      "B"
    ],
    "explanation": "在请求失败时提供备用方案和默认数据，保证基本功能的可用性。"
  },
  {
    "id": 498,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据归档的触发条件？",
    "options": {
      "A": "时间条件",
      "B": "空间条件",
      "C": "业务条件",
      "D": "性能条件"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据归档可以根据时间、空间、业务需求和性能要求等条件触发。"
  },
  {
    "id": 499,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的面包屑导航？",
    "options": {
      "A": "使用 Router.breadcrumb()",
      "B": "根据路由历史生成面包屑",
      "C": "使用 @Breadcrumb 装饰器",
      "D": "ArkTS不支持面包屑导航"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据路由历史记录生成面包屑路径，提供清晰的导航信息。"
  },
  {
    "id": 500,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现应用的预渲染？",
    "options": {
      "A": "使用 @Prerender 装饰器",
      "B": "在构建时生成静态页面",
      "C": "使用 PrerenderEngine 类",
      "D": "ArkTS不支持预渲染"
    },
    "answer": [
      "B"
    ],
    "explanation": "在应用构建时生成关键页面的静态版本，提升首屏加载性能。"
  },
  {
    "id": 501,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，布尔类型的取值为？",
    "options": {
      "A": "true 和 false",
      "B": "True 和 False",
      "C": "1 和 0",
      "D": "yes 和 no"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中布尔类型的取值只能是 true（真）和 false（假），为小写形式"
  },
  {
    "id": 502,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些装饰器可以用于标记自定义组件的特性？",
    "options": {
      "A": "@Component",
      "B": "@Entry",
      "C": "@Builder",
      "D": "@Extend"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "@Component 用于标记自定义组件，@Entry 标记应用入口组件；@Builder 用于定义 UI 片段，@Extend 用于扩展组件，不属于组件特性标记"
  },
  {
    "id": 503,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "子组件修改 @Prop 装饰的状态，会对父组件产生什么影响？",
    "options": {
      "A": "不影响父组件",
      "B": "父组件状态同步修改",
      "C": "父组件会重新渲染",
      "D": "会抛出异常"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Prop 是单向绑定，子组件修改不会影响父组件的源状态"
  },
  {
    "id": 504,
    "type": "single",
    "category": "布局设计",
    "difficulty": "简单",
    "question": "Column 容器的默认排列方向是？",
    "options": {
      "A": "垂直方向",
      "B": "水平方向",
      "C": "层叠方向",
      "D": "网格方向"
    },
    "answer": [
      "A"
    ],
    "explanation": "Column 容器默认按垂直方向排列子组件，Row 容器默认按水平方向排列"
  },
  {
    "id": 505,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些属于触摸事件的类型？",
    "options": {
      "A": "onTouchStart",
      "B": "onTouchMove",
      "C": "onTouchEnd",
      "D": "onTouchCancel"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "触摸事件包括触摸开始（onTouchStart）、触摸移动（onTouchMove）、触摸结束（onTouchEnd）和触摸取消（onTouchCancel）"
  },
  {
    "id": 506,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示简短提示信息的组件是？",
    "options": {
      "A": "Toast",
      "B": "Dialog",
      "C": "Alert",
      "D": "Tip"
    },
    "answer": [
      "A"
    ],
    "explanation": "Toast 组件用于显示简短的提示信息，会在一段时间后自动消失"
  },
  {
    "id": 507,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "鸿蒙分布式任务调度主要依赖哪个模块？",
    "options": {
      "A": "taskDispatcher",
      "B": "distributedTask",
      "C": "taskScheduler",
      "D": "remoteTask"
    },
    "answer": [
      "A"
    ],
    "explanation": "taskDispatcher 模块提供了分布式任务调度能力，支持跨设备任务分发与执行"
  },
  {
    "id": 508,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由跳转时可以传递哪些类型的参数？",
    "options": {
      "A": "字符串",
      "B": "数字",
      "C": "对象",
      "D": "函数"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "路由参数支持字符串、数字、对象等可序列化类型，函数无法作为路由参数传递"
  },
  {
    "id": 509,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置组件的宽度为自适应内容？",
    "options": {
      "A": ".width ('auto')",
      "B": ".width ('wrap')",
      "C": ".width ('content')",
      "D": ".width ('fit')"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.width ('auto') 设置组件宽度自适应内容，根据内容自动调整宽度"
  },
  {
    "id": 510,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确定义一个二维数组？",
    "options": {
      "A": "let matrix: number [][] = [[1, 2], [3, 4]]",
      "B": "let matrix: array [array] = [[1, 2], [3, 4]]",
      "C": "let matrix: [][] number = [[1, 2], [3, 4]]",
      "D": "let matrix = new Array (2).new Array (2)"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中二维数组的定义方式为类型 [][]，如 number [][] 表示数字类型的二维数组"
  },
  {
    "id": 511,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "组件即将显示在界面上时会调用哪个生命周期函数？",
    "options": {
      "A": "onAppear ()",
      "B": "onShow ()",
      "C": "onWillAppear ()",
      "D": "onDisplay ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onAppear () 在组件即将显示在界面上时调用，可用于初始化显示相关数据"
  },
  {
    "id": 512,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "以下哪些状态装饰器支持跨组件层级传递？",
    "options": {
      "A": "@Provide",
      "B": "@Consume",
      "C": "@Link",
      "D": "@Prop"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "@Provide 和 @Consume 是一对跨层级状态共享装饰器，无需通过中间组件传递；@Link 和 @Prop 用于父子组件间传递"
  },
  {
    "id": 513,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "layoutWeight 属性的作用是？",
    "options": {
      "A": "设置组件在父容器中的权重比例",
      "B": "设置组件的宽度和高度比例",
      "C": "设置组件的显示优先级",
      "D": "设置组件的缩放比例"
    },
    "answer": [
      "A"
    ],
    "explanation": "layoutWeight 用于设置组件在父容器中剩余空间的分配比例，实现弹性布局效果"
  },
  {
    "id": 514,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "手势事件中，用于处理滑动手势的方法是？",
    "options": {
      "A": ".onSwipe ((event: SwipeEvent) => {})",
      "B": ".onSlide ((event: SlideEvent) => {})",
      "C": ".onDrag ((event: DragEvent) => {})",
      "D": ".onFling ((event: FlingEvent) => {})"
    },
    "answer": [
      "A"
    ],
    "explanation": "onSwipe () 方法用于处理滑动手势，接收 SwipeEvent 参数，包含滑动方向、距离等信息"
  },
  {
    "id": 515,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "以下哪些组件属于输入类组件？",
    "options": {
      "A": "TextField",
      "B": "TextArea",
      "C": "Search",
      "D": "Picker"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextField（单行输入）、TextArea（多行输入）、Search（搜索框）、Picker（选择器）都属于输入类组件"
  },
  {
    "id": 516,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "如何实现鸿蒙设备间的消息通信？",
    "options": {
      "A": "使用 messaging 模块",
      "B": "使用 socket 模块",
      "C": "使用 notification 模块",
      "D": "使用 eventHub 模块"
    },
    "answer": [
      "A"
    ],
    "explanation": "messaging 模块提供了跨设备消息传递能力，支持设备间的即时通信"
  },
  {
    "id": 517,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由栈的最大深度是多少？",
    "options": {
      "A": "16",
      "B": "32",
      "C": "64",
      "D": "无限制"
    },
    "answer": [
      "A"
    ],
    "explanation": "鸿蒙路由栈的最大深度为 16，超过后会抛出路由栈溢出异常"
  },
  {
    "id": 518,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的背景？",
    "options": {
      "A": ".background (Color.Red)",
      "B": ".backgroundImage ('image.png')",
      "C": ".backgroundGradient (gradient)",
      "D": ".bg ('red')"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "background () 设置纯色背景，backgroundImage () 设置图片背景，backgroundGradient () 设置渐变背景；ArkTS 中没有 bg () 方法"
  },
  {
    "id": 519,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，null 和 undefined 的区别是？",
    "options": {
      "A": "null 表示空值，undefined 表示未定义",
      "B": "null 表示未定义，undefined 表示空值",
      "C": "两者没有区别",
      "D": "null 是对象类型，undefined 是基本类型"
    },
    "answer": [
      "A"
    ],
    "explanation": "null 表示变量被赋予了空值，undefined 表示变量声明但未赋值或对象属性不存在"
  },
  {
    "id": 520,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件的 build () 方法的作用是？",
    "options": {
      "A": "定义组件的 UI 结构",
      "B": "定义组件的生命周期",
      "C": "定义组件的事件处理",
      "D": "定义组件的样式"
    },
    "answer": [
      "A"
    ],
    "explanation": "build () 方法是自定义组件的核心方法，用于描述组件的 UI 结构和布局"
  },
  {
    "id": 521,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些是组件的生命周期函数？",
    "options": {
      "A": "onCreate ()",
      "B": "onAppear ()",
      "C": "onDisappear ()",
      "D": "onDestroy ()"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "鸿蒙组件生命周期包括：创建（onCreate）、显示（onAppear）、消失（onDisappear）、销毁（onDestroy）"
  },
  {
    "id": 522,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "当 @State 装饰的状态发生变化时，会触发什么操作？",
    "options": {
      "A": "组件重新渲染",
      "B": "应用重启",
      "C": "页面跳转",
      "D": "无任何操作"
    },
    "answer": [
      "A"
    ],
    "explanation": "@State 装饰的状态是组件内部的响应式状态，状态变化会触发组件的重新渲染"
  },
  {
    "id": 523,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Grid 组件中，columnsTemplate 属性的作用是？",
    "options": {
      "A": "定义列的数量和宽度比例",
      "B": "定义行的数量和高度比例",
      "C": "定义网格的间距",
      "D": "定义网格的对齐方式"
    },
    "answer": [
      "A"
    ],
    "explanation": "columnsTemplate 用于定义 Grid 组件的列布局，如 '1fr 1fr 1fr' 表示 3 列且宽度相等"
  },
  {
    "id": 524,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "困难",
    "question": "以下哪些是手势识别的类型？",
    "options": {
      "A": "TapGesture",
      "B": "LongPressGesture",
      "C": "PinchGesture",
      "D": "RotateGesture"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "ArkTS 支持多种手势识别：Tap（点击）、LongPress（长按）、Pinch（捏合）、Rotate（旋转）等"
  },
  {
    "id": 525,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示评分的组件是？",
    "options": {
      "A": "Rating",
      "B": "Score",
      "C": "Star",
      "D": "Rate"
    },
    "answer": [
      "A"
    ],
    "explanation": "Rating 组件用于显示评分，通常以星星图标表示，支持用户交互修改评分"
  },
  {
    "id": 526,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式文件系统的主要 API 在哪个模块？",
    "options": {
      "A": "distributedFileSystem",
      "B": "fileManager",
      "C": "distributedFile",
      "D": "storageManager"
    },
    "answer": [
      "A"
    ],
    "explanation": "distributedFileSystem 模块提供了分布式文件系统的操作 API，支持跨设备文件访问"
  },
  {
    "id": 527,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由配置文件 main_pages.json 中可以配置哪些信息？",
    "options": {
      "A": "页面路径",
      "B": "页面名称",
      "C": "页面参数",
      "D": "页面样式"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "main_pages.json 主要配置页面的路径和名称，用于路由管理，不包含页面参数和样式配置"
  },
  {
    "id": 528,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的边框样式为虚线？",
    "options": {
      "A": ".borderStyle (BorderStyle.Dashed)",
      "B": ".border ('dashed')",
      "C": ".borderDash ()",
      "D": ".dashedBorder (true)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.borderStyle () 方法设置边框样式，参数为 BorderStyle 枚举值，如 Dashed 表示虚线"
  },
  {
    "id": 529,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何判断一个变量是否为数组？",
    "options": {
      "A": "Array.isArray (variable)",
      "B": "typeof variable === 'array'",
      "C": "variable instanceof Array",
      "D": "variable.isArray ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "Array.isArray () 是判断变量是否为数组的推荐方法，typeof 返回 'object'，instanceof 在跨 iframe 时可能不准确"
  },
  {
    "id": 530,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件可以通过哪些方式复用？",
    "options": {
      "A": "直接在其他组件中引用",
      "B": "通过 @Builder 封装 UI 片段",
      "C": "通过 @Extend 扩展已有组件",
      "D": "通过 export 导出供其他模块使用"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "自定义组件的复用方式包括直接引用、@Builder 封装、@Extend 扩展和模块导出等"
  },
  {
    "id": 531,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onDestroy () 生命周期函数在什么时候调用？",
    "options": {
      "A": "组件被销毁时",
      "B": "组件从界面消失时",
      "C": "应用退出时",
      "D": "设备休眠时"
    },
    "answer": [
      "A"
    ],
    "explanation": "onDestroy () 在组件被销毁时调用，可用于释放资源、取消订阅等清理操作"
  },
  {
    "id": 532,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "AppStorage 中的状态变化会如何影响使用 @StorageProp 的组件？",
    "options": {
      "A": "组件会重新渲染",
      "B": "组件不会有任何变化",
      "C": "应用会重启",
      "D": "会触发 onChange 事件"
    },
    "answer": [
      "A"
    ],
    "explanation": "@StorageProp 与 AppStorage 建立单向绑定，当 AppStorage 中的状态变化时，组件会重新渲染"
  },
  {
    "id": 533,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Scroll 组件支持哪些滚动方向？",
    "options": {
      "A": "垂直滚动",
      "B": "水平滚动",
      "C": "自由滚动",
      "D": "网格滚动"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Scroll 组件支持 vertical（垂直）、horizontal（水平）和 free（自由）三种滚动方向"
  },
  {
    "id": 534,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "长按手势的识别时间阈值是多少？",
    "options": {
      "A": "500ms",
      "B": "1000ms",
      "C": "1500ms",
      "D": "2000ms"
    },
    "answer": [
      "A"
    ],
    "explanation": "长按手势的默认识别时间阈值为 500ms，超过此时长会触发长按事件"
  },
  {
    "id": 535,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示进度条的组件是？",
    "options": {
      "A": "Progress",
      "B": "ProgressBar",
      "C": "Slider",
      "D": "ProgressIndicator"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 Progress 组件显示进度条，支持线性和环形两种样式"
  },
  {
    "id": 536,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是鸿蒙分布式能力的核心特性？",
    "options": {
      "A": "设备虚拟化",
      "B": "跨设备协同",
      "C": "分布式数据管理",
      "D": "分布式任务调度"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "鸿蒙分布式能力的核心特性包括设备虚拟化、跨设备协同、分布式数据管理和分布式任务调度等"
  },
  {
    "id": 537,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.clear () 方法的作用是？",
    "options": {
      "A": "清空路由栈",
      "B": "清除当前页面",
      "C": "清除路由参数",
      "D": "重置路由配置"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.clear () 用于清空路由栈中的所有页面，通常配合 router.replaceUrl () 实现首页跳转"
  },
  {
    "id": 538,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的对齐方式？",
    "options": {
      "A": ".textAlign (TextAlign.Center)",
      "B": ".align (Alignment.Center)",
      "C": ".textAlign ('center')",
      "D": ".alignment (TextAlign.Center)"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "textAlign () 直接设置文本对齐，align () 设置组件在父容器中的对齐方式，也会影响文本显示"
  },
  {
    "id": 539,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何实现对象的深拷贝？",
    "options": {
      "A": "使用 JSON.parse (JSON.stringify (obj))",
      "B": "使用 Object.assign ({}, obj)",
      "C": "使用扩展运算符 {...obj}",
      "D": "使用 obj.clone ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "JSON.parse (JSON.stringify (obj)) 是实现对象深拷贝的常用方法，其他选项均为浅拷贝"
  },
  {
    "id": 540,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@BuilderParam 装饰器的作用是？",
    "options": {
      "A": "定义组件的插槽参数",
      "B": "定义组件的属性参数",
      "C": "定义组件的事件参数",
      "D": "定义组件的样式参数"
    },
    "answer": [
      "A"
    ],
    "explanation": "@BuilderParam 用于定义组件的插槽参数，允许父组件传递自定义 UI 片段到子组件"
  },
  {
    "id": 541,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数会在组件可见性变化时触发？",
    "options": {
      "A": "onAppear ()",
      "B": "onDisappear ()",
      "C": "onVisibilityChange ()",
      "D": "onShow ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "onAppear () 在组件变为可见时触发，onDisappear () 在组件变为不可见时触发，用于处理可见性变化逻辑"
  },
  {
    "id": 542,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Consume 装饰器需要与哪个装饰器配合使用？",
    "options": {
      "A": "@Provide",
      "B": "@State",
      "C": "@Link",
      "D": "@Prop"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Provide 和 @Consume 是一对装饰器，用于跨层级组件间的状态共享，需配合使用"
  },
  {
    "id": 543,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Stack 组件的子组件默认的对齐方式是？",
    "options": {
      "A": "左上角",
      "B": "居中",
      "C": "右下角",
      "D": "填满容器"
    },
    "answer": [
      "A"
    ],
    "explanation": "Stack 组件的子组件默认左上角对齐，可通过 alignContent 属性修改对齐方式"
  },
  {
    "id": 544,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些事件支持冒泡？",
    "options": {
      "A": "点击事件",
      "B": "触摸事件",
      "C": "滚动事件",
      "D": "手势事件"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "点击事件和触摸事件支持事件冒泡，从子组件向父组件传递；滚动事件和手势事件不支持冒泡"
  },
  {
    "id": 545,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示标签页的组件是？",
    "options": {
      "A": "Tabs",
      "B": "TabLayout",
      "C": "TabView",
      "D": "TabBar"
    },
    "answer": [
      "A"
    ],
    "explanation": "Tabs 组件用于实现标签页功能，配合 TabContent 组件使用，实现多页面切换"
  },
  {
    "id": 546,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式服务开发中，如何注册一个服务？",
    "options": {
      "A": "using service xxx from './xxx.service'",
      "B": "registerService ('serviceName', serviceImpl)",
      "C": "export default class MyService implements IService",
      "D": "@Service decorator"
    },
    "answer": [
      "A"
    ],
    "explanation": "鸿蒙分布式服务通过 using service 语法注册服务，指定服务路径和名称"
  },
  {
    "id": 547,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由导航的方式？",
    "options": {
      "A": "编程式导航",
      "B": "声明式导航",
      "C": "分布式导航",
      "D": "嵌套导航"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "鸿蒙路由支持编程式导航（API 调用）、声明式导航（组件方式）、分布式导航（跨设备）和嵌套导航（页面内嵌套路由）"
  },
  {
    "id": 548,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的渐变背景？",
    "options": {
      "A": ".backgroundGradient ({ type: GradientType.Linear, colors: [Color.Red, Color.Blue] })",
      "B": ".gradientBackground ('linear', ['red', 'blue'])",
      "C": ".background ('linear-gradient (red, blue)')",
      "D": ".setGradient ({ type: 'linear', colors: ['red', 'blue'] })"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.backgroundGradient () 方法设置渐变背景，参数为包含渐变类型和颜色的对象"
  },
  {
    "id": 549,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，字符串的 concat () 方法的作用是？",
    "options": {
      "A": "连接两个或多个字符串",
      "B": "分割字符串为数组",
      "C": "替换字符串中的字符",
      "D": "转换字符串为大写"
    },
    "answer": [
      "A"
    ],
    "explanation": "concat () 方法用于连接两个或多个字符串，返回一个新的字符串，不改变原字符串"
  },
  {
    "id": 550,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些方法可以实现组件的条件渲染？",
    "options": {
      "A": "if 语句",
      "B": "Show () 组件",
      "C": "Visibility 属性",
      "D": "display 属性"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "ArkTS 中可通过 if 语句（完全不渲染）和 Visibility 属性（隐藏但保留空间）实现条件渲染"
  },
  {
    "id": 551,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "组件收到新的属性值时会调用哪个生命周期函数？",
    "options": {
      "A": "onUpdate ()",
      "B": "onPropsChange ()",
      "C": "onPropertyUpdate ()",
      "D": "onChange ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onUpdate () 在组件收到新的属性值时调用，可用于处理属性变化相关逻辑"
  },
  {
    "id": 552,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 的作用域是？",
    "options": {
      "A": "当前组件及其子组件",
      "B": "整个应用",
      "C": "当前页面",
      "D": "所有设备"
    },
    "answer": [
      "A"
    ],
    "explanation": "LocalStorage 是组件级别的状态存储，作用域限定在当前组件及其子组件"
  },
  {
    "id": 553,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置子组件间距？",
    "options": {
      "A": "Column",
      "B": "Row",
      "C": "Grid",
      "D": "List"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Column、Row 通过 spacing 属性，Grid 通过 rowSpacing 和 columnSpacing，List 通过 space 属性设置子组件间距"
  },
  {
    "id": 554,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "如何阻止事件冒泡？",
    "options": {
      "A": "event.stopPropagation ()",
      "B": "event.preventDefault ()",
      "C": "return false",
      "D": "event.stopBubbling ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "调用事件对象的 stopPropagation () 方法可以阻止事件冒泡，防止事件向父组件传递"
  },
  {
    "id": 555,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示轮播图的组件是？",
    "options": {
      "A": "Swiper",
      "B": "Carousel",
      "C": "Slider",
      "D": "Banner"
    },
    "answer": [
      "A"
    ],
    "explanation": "Swiper 组件用于实现轮播图功能，支持自动播放、手势滑动等特性"
  },
  {
    "id": 556,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式数据管理支持哪些数据同步策略？",
    "options": {
      "A": "实时同步",
      "B": "按需同步",
      "C": "增量同步",
      "D": "全量同步"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "鸿蒙分布式数据管理支持实时同步、按需同步、增量同步和全量同步等多种数据同步策略"
  },
  {
    "id": 557,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.getState () 方法的作用是？",
    "options": {
      "A": "获取当前路由状态",
      "B": "获取路由历史记录",
      "C": "获取路由参数",
      "D": "获取路由配置"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.getState () 用于获取当前路由状态，包括当前页面路径、参数等信息"
  },
  {
    "id": 558,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的阴影？",
    "options": {
      "A": ".shadow ({ radius: 5, color: Color.Gray, offsetX: 2, offsetY: 2 })",
      "B": ".shadowRadius (5)",
      "C": ".shadowColor (Color.Gray)",
      "D": ".shadowOffset ({ x: 2, y: 2 })"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "可以通过 shadow () 方法设置综合阴影属性，也可以通过 shadowRadius ()、shadowColor () 等方法单独设置"
  },
  {
    "id": 559,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，Promise 的 reject () 方法的作用是？",
    "options": {
      "A": "标记异步操作失败",
      "B": "标记异步操作成功",
      "C": "终止异步操作",
      "D": "暂停异步操作"
    },
    "answer": [
      "A"
    ],
    "explanation": "Promise 的 reject () 方法用于标记异步操作失败，并传递错误信息，会触发.catch () 回调"
  },
  {
    "id": 560,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何定义一个全局可用的自定义组件？",
    "options": {
      "A": "在 entry/src/main/ets/components 目录下创建组件，并导出",
      "B": "使用 @Global 装饰器标记组件",
      "C": "在 App.js 中注册组件",
      "D": "将组件定义在 App.ets 中"
    },
    "answer": [
      "A"
    ],
    "explanation": "在 components 目录下创建的组件可通过导出供全局使用，是鸿蒙应用开发的规范做法"
  },
  {
    "id": 561,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "困难",
    "question": "以下哪些场景会触发组件的 onDestroy () 方法？",
    "options": {
      "A": "组件被从父组件中移除",
      "B": "页面跳转导致组件不可见",
      "C": "应用被关闭",
      "D": "设备旋转导致界面重绘"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "组件被移除或应用关闭时会触发 onDestroy ()；页面跳转只是不可见（触发 onDisappear），设备旋转会触发重新渲染但不会销毁"
  },
  {
    "id": 562,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@State 装饰的状态默认是？",
    "options": {
      "A": "私有的，只能在组件内部访问",
      "B": "公共的，可以被任何组件访问",
      "C": "受保护的，只能被子类访问",
      "D": "全局的，应用内所有组件可访问"
    },
    "answer": [
      "A"
    ],
    "explanation": "@State 装饰的状态是组件的私有状态，默认只能在组件内部访问和修改"
  },
  {
    "id": 563,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "List 组件的 cachedCount 属性的作用是？",
    "options": {
      "A": "设置预加载的列表项数量",
      "B": "设置列表项的最大数量",
      "C": "设置可见的列表项数量",
      "D": "设置列表项的缓存大小"
    },
    "answer": [
      "A"
    ],
    "explanation": "cachedCount 用于设置 List 组件在可见区域外预加载的列表项数量，优化滚动性能"
  },
  {
    "id": 564,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是输入框的事件？",
    "options": {
      "A": "onChange",
      "B": "onFocus",
      "C": "onBlur",
      "D": "onSubmit"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "输入框支持内容变化（onChange）、获取焦点（onFocus）、失去焦点（onBlur）和提交（onSubmit）等事件"
  },
  {
    "id": 565,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示分割线的组件是？",
    "options": {
      "A": "Divider",
      "B": "Separator",
      "C": "Line",
      "D": "SplitLine"
    },
    "answer": [
      "A"
    ],
    "explanation": "Divider 组件用于显示分割线，可设置方向、颜色、粗细等属性"
  },
  {
    "id": 566,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "如何获取分布式网络中的设备 ID？",
    "options": {
      "A": "deviceInfo.deviceId",
      "B": "getDeviceId ()",
      "C": "deviceManager.getDeviceId ()",
      "D": "DistributedDevice.getDeviceId ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过 deviceInfo 对象的 deviceId 属性可以获取分布式网络中设备的唯一标识符"
  },
  {
    "id": 567,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些方法可以关闭当前页面？",
    "options": {
      "A": "router.back ()",
      "B": "router.pop ()",
      "C": "router.close ()",
      "D": "router.exit ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "router.back () 和 router.pop () 都可以关闭当前页面并返回上一页，是路由管理的常用方法"
  },
  {
    "id": 568,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的旋转角度？",
    "options": {
      "A": ".rotate ({ angle: 90 })",
      "B": ".rotation (90)",
      "C": ".rotateAngle (90)",
      "D": ".setRotation (90)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.rotate () 方法设置组件的旋转角度，参数为包含 angle 属性的对象，单位为度"
  },
  {
    "id": 569,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 filter () 方法返回的是？",
    "options": {
      "A": "满足条件的元素组成的新数组",
      "B": "第一个满足条件的元素",
      "C": "元素是否满足条件的布尔值",
      "D": "原数组的引用"
    },
    "answer": [
      "A"
    ],
    "explanation": "filter () 方法创建一个新数组，包含所有通过指定测试函数的元素，不改变原数组"
  },
  {
    "id": 570,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的属性？",
    "options": {
      "A": "普通属性",
      "B": "事件属性",
      "C": "样式属性",
      "D": "状态属性"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "自定义组件的属性包括普通属性（数据传递）、事件属性（事件回调）和样式属性（样式设置）"
  },
  {
    "id": 571,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onCreate () 生命周期函数在组件的哪个阶段调用？",
    "options": {
      "A": "组件初始化阶段",
      "B": "组件渲染阶段",
      "C": "组件显示阶段",
      "D": "组件销毁阶段"
    },
    "answer": [
      "A"
    ],
    "explanation": "onCreate () 在组件初始化阶段调用，是组件生命周期的第一个函数，用于初始化数据"
  },
  {
    "id": 572,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何在非组件类中访问 AppStorage 中的状态？",
    "options": {
      "A": "使用 AppStorage.Get ('key')",
      "B": "使用 @StorageProp 装饰器",
      "C": "使用 @StorageLink 装饰器",
      "D": "无法访问"
    },
    "answer": [
      "A"
    ],
    "explanation": "非组件类中可以通过 AppStorage.Get ('key') 方法获取状态，装饰器仅在组件类中使用"
  },
  {
    "id": 573,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持嵌套使用？",
    "options": {
      "A": "Column",
      "B": "Row",
      "C": "Stack",
      "D": "Grid"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "所有布局容器都支持嵌套使用，通过嵌套可以实现复杂的界面布局"
  },
  {
    "id": 574,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "双击事件的处理方法是？",
    "options": {
      "A": ".onDoubleClick (() => {})",
      "B": ".onTap ({ count: 2 }, () => {})",
      "C": ".onClick ({ double: true }, () => {})",
      "D": ".onDblClick (() => {})"
    },
    "answer": [
      "B"
    ],
    "explanation": "双击事件通过 onTap () 方法实现，指定 count 参数为 2，如.onTap ({ count: 2 }, () => {})"
  },
  {
    "id": 575,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示加载状态的组件是？",
    "options": {
      "A": "Loading",
      "B": "Progress",
      "C": "Spinner",
      "D": "Indicator"
    },
    "answer": [
      "A"
    ],
    "explanation": "Loading 组件用于显示加载状态，通常为旋转的指示器，提示用户操作正在处理"
  },
  {
    "id": 576,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式任务调度的优势？",
    "options": {
      "A": "充分利用设备资源",
      "B": "提升任务执行效率",
      "C": "实现跨设备协同",
      "D": "降低开发复杂度"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式任务调度可充分利用各设备资源，提升效率，实现跨设备协同，同时简化开发者的跨设备开发复杂度"
  },
  {
    "id": 577,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.replaceUrl () 与 router.pushUrl () 的区别是？",
    "options": {
      "A": "replaceUrl 替换当前页面，pushUrl 添加新页面",
      "B": "replaceUrl 关闭当前页面，pushUrl 保留当前页面",
      "C": "replaceUrl 用于跨设备跳转，pushUrl 用于本地跳转",
      "D": "replaceUrl 不传递参数，pushUrl 传递参数"
    },
    "answer": [
      "A"
    ],
    "explanation": "replaceUrl 用新页面替换当前页面（路由栈长度不变），pushUrl 在路由栈添加新页面（长度 + 1）"
  },
  {
    "id": 578,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的缩放？",
    "options": {
      "A": ".scale ({ x: 1.5, y: 1.5 })",
      "B": ".scaleX (1.5)",
      "C": ".scaleY (1.5)",
      "D": ".scaling (1.5)"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "scale () 设置整体缩放，scaleX () 设置水平缩放，scaleY () 设置垂直缩放；ArkTS 中没有 scaling () 方法"
  },
  {
    "id": 579,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，async 函数的返回值是什么类型？",
    "options": {
      "A": "Promise",
      "B": "any",
      "C": "void",
      "D": "与函数内部返回值类型一致"
    },
    "answer": [
      "A"
    ],
    "explanation": "async 函数始终返回一个 Promise 对象，无论函数内部返回什么值都会被包装成 Promise"
  },
  {
    "id": 580,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何为自定义组件添加样式属性？",
    "options": {
      "A": "使用 @Styles 装饰器定义样式函数",
      "B": "在组件属性中声明样式参数",
      "C": "使用 CSS 文件定义样式",
      "D": "在 build () 方法中直接设置"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Styles 装饰器用于定义自定义样式函数，可作为组件的样式属性使用"
  },
  {
    "id": 581,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数可以用于资源清理？",
    "options": {
      "A": "onDestroy ()",
      "B": "onDisappear ()",
      "C": "onRelease ()",
      "D": "onClear ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onDestroy () 是组件销毁前的最后一个生命周期函数，适合进行资源清理、取消订阅等操作"
  },
  {
    "id": 582,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Link 装饰器需要与父组件的哪个状态关联？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Provide",
      "D": "@StorageProp"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Link 装饰的状态必须与父组件中 @State 装饰的状态建立双向绑定关系"
  },
  {
    "id": 583,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Row 容器的 justifyContent 属性的作用是？",
    "options": {
      "A": "设置子组件在主轴上的对齐方式",
      "B": "设置子组件在交叉轴上的对齐方式",
      "C": "设置子组件的间距",
      "D": "设置容器的对齐方式"
    },
    "answer": [
      "A"
    ],
    "explanation": "justifyContent 用于设置子组件在主轴（Row 的主轴为水平方向）上的对齐方式"
  },
  {
    "id": 584,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些事件可以用于处理键盘输入？",
    "options": {
      "A": "onKeyDown",
      "B": "onKeyUp",
      "C": "onKeyPress",
      "D": "onInput"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "onKeyDown（按键按下）、onKeyUp（按键释放）、onKeyPress（按键按压）用于处理键盘输入事件"
  },
  {
    "id": 585,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示图标和文本组合的组件是？",
    "options": {
      "A": "Button",
      "B": "Badge",
      "C": "Label",
      "D": "IconText"
    },
    "answer": [
      "A"
    ],
    "explanation": "Button 组件支持同时设置图标和文本，通过 icon 属性指定图标，是常用的图标文本组合组件"
  },
  {
    "id": 586,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式服务的调用方式是？",
    "options": {
      "A": "远程过程调用（RPC）",
      "B": "HTTP 请求",
      "C": "WebSocket",
      "D": "消息队列"
    },
    "answer": [
      "A"
    ],
    "explanation": "鸿蒙分布式服务基于远程过程调用（RPC）实现，允许跨设备调用服务接口"
  },
  {
    "id": 587,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由参数可以通过哪些方式获取？",
    "options": {
      "A": "router.getParams ()",
      "B": "$router.params",
      "C": "在组件的 onPageShow () 方法中获取",
      "D": "通过 @Prop 装饰器接收"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "可通过 router.getParams () 方法或在 onPageShow () 生命周期函数中获取路由参数"
  },
  {
    "id": 588,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的透明度为半透明？",
    "options": {
      "A": ".opacity (0.5)",
      "B": ".transparent (50%)",
      "C": ".alpha (0.5)",
      "D": ".transparency (0.5)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.opacity () 方法设置透明度，参数为 0 到 1 之间的数值，0.5 表示半透明"
  },
  {
    "id": 589,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 reduce () 方法的作用是？",
    "options": {
      "A": "对数组元素进行累加计算",
      "B": "对数组元素进行排序",
      "C": "对数组元素进行过滤",
      "D": "对数组元素进行映射转换"
    },
    "answer": [
      "A"
    ],
    "explanation": "reduce () 方法对数组中的每个元素执行回调函数，将其缩减为单个值（如求和、求积等）"
  },
  {
    "id": 590,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的组成部分？",
    "options": {
      "A": "属性定义",
      "B": "状态定义",
      "C": "生命周期函数",
      "D": "build () 方法"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "自定义组件通常包括属性定义、状态定义、生命周期函数和 build () 方法（UI 结构）"
  },
  {
    "id": 591,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onAppear () 与 onCreate () 的调用顺序是？",
    "options": {
      "A": "onCreate () 先调用，onAppear () 后调用",
      "B": "onAppear () 先调用，onCreate () 后调用",
      "C": "同时调用",
      "D": "没有固定顺序"
    },
    "answer": [
      "A"
    ],
    "explanation": "组件生命周期的调用顺序为：onCreate ()（初始化）→ onAppear ()（显示）"
  },
  {
    "id": 592,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "AppStorage 中的状态会在应用重启后保留吗？",
    "options": {
      "A": "不会，AppStorage 是内存存储",
      "B": "会，AppStorage 是持久化存储",
      "C": "部分保留，取决于状态类型",
      "D": "可以配置是否保留"
    },
    "answer": [
      "A"
    ],
    "explanation": "AppStorage 是内存中的状态存储，应用重启后状态会丢失，需配合 Preferences 实现持久化"
  },
  {
    "id": 593,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些属性可以用于设置组件的对齐方式？",
    "options": {
      "A": "alignItems",
      "B": "justifyContent",
      "C": "alignSelf",
      "D": "alignment"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "alignItems（交叉轴对齐）、justifyContent（主轴对齐）、alignSelf（自身对齐）用于设置对齐方式"
  },
  {
    "id": 594,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "捏合手势（Pinch）的事件参数包含哪些信息？",
    "options": {
      "A": "缩放比例和中心点",
      "B": "旋转角度和方向",
      "C": "滑动距离和方向",
      "D": "点击次数和坐标"
    },
    "answer": [
      "A"
    ],
    "explanation": "捏合手势事件参数包含缩放比例（scale）和中心点（center）等信息，用于处理缩放操作"
  },
  {
    "id": 595,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示提示气泡的组件是？",
    "options": {
      "A": "Tooltip",
      "B": "Bubble",
      "C": "Popup",
      "D": "Hint"
    },
    "answer": [
      "A"
    ],
    "explanation": "Tooltip 组件用于显示提示气泡，通常在用户长按或悬停时显示，提供额外信息"
  },
  {
    "id": 596,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式数据同步的触发条件？",
    "options": {
      "A": "数据发生变化时",
      "B": "设备连接时",
      "C": "应用启动时",
      "D": "手动触发同步"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式数据同步可由数据变化、设备连接、应用启动和手动触发等多种条件触发"
  },
  {
    "id": 597,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由拦截器的作用是？",
    "options": {
      "A": "在路由跳转前进行验证或处理",
      "B": "记录路由跳转历史",
      "C": "修改路由参数",
      "D": "设置路由动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "路由拦截器用于在路由跳转前进行验证（如登录状态检查）或预处理，可阻止不合理的跳转"
  },
  {
    "id": 598,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的字体？",
    "options": {
      "A": ".fontFamily ('sans-serif')",
      "B": ".font ('sans-serif')",
      "C": ".setFontFamily ('sans-serif')",
      "D": ".textFont ('sans-serif')"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.fontFamily () 方法设置文本的字体，参数为字体名称或字体族名称"
  },
  {
    "id": 599,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，如何捕获异步操作的异常？",
    "options": {
      "A": "使用 try/catch 语句",
      "B": "使用.catch () 方法",
      "C": "以上都是",
      "D": "以上都不是"
    },
    "answer": [
      "C"
    ],
    "explanation": "ArkTS 中可通过 try/catch（配合 async/await）或.catch () 方法（Promise 链式调用）捕获异步异常"
  },
  {
    "id": 600,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何实现组件的懒加载？",
    "options": {
      "A": "使用 LazyForEach 组件",
      "B": "使用 ForEach 组件的 lazy 属性",
      "C": "使用 lazy 关键字标记组件",
      "D": "设置组件的 lazyLoad 属性为 true"
    },
    "answer": [
      "A"
    ],
    "explanation": "LazyForEach 组件用于实现数据的懒加载，只渲染可见区域的组件，优化性能"
  },
  {
    "id": 601,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现装饰器的组合使用？",
    "options": {
      "A": "多个装饰器从上到下执行",
      "B": "多个装饰器从下到上执行",
      "C": "使用 @Compose 组合装饰器",
      "D": "TypeScript不支持装饰器组合"
    },
    "answer": [
      "A"
    ],
    "explanation": "多个装饰器从上到下执行，从外到内应用：@f @g x 等价于 f(g(x))"
  },
  {
    "id": 602,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextPicker 的滑动效果配置？",
    "options": {
      "A": "canLoop",
      "B": "disappearTextStyle",
      "C": "selectedTextStyle",
      "D": "textStyle"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextPicker 支持 canLoop（循环滑动）、disappearTextStyle（消失文本样式）、selectedTextStyle（选中文本样式）、textStyle（文本样式）等配置。"
  },
  {
    "id": 603,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的分形架构？",
    "options": {
      "A": "使用 @Fractal 装饰器",
      "B": "使用嵌套的状态管理结构",
      "C": "使用 FractalState 类",
      "D": "ArkTS不支持分形架构"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过嵌套的状态管理结构，每个组件管理自己的局部状态，形成分形架构。"
  },
  {
    "id": 604,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的日历组件？",
    "options": {
      "A": "使用 @Calendar 装饰器",
      "B": "使用 @BuilderParam 接收日历配置",
      "C": "使用 CalendarManager 类",
      "D": "ArkTS不支持日历组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收日历配置和自定义渲染，实现可配置的日历组件。"
  },
  {
    "id": 605,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 List 的滚动控制方法？",
    "options": {
      "A": "scrollToIndex",
      "B": "scrollBy",
      "C": "scrollTo",
      "D": "scrollPage"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "List 组件支持 scrollToIndex（滚动到索引）、scrollBy（相对滚动）、scrollTo（绝对滚动）等方法。"
  },
  {
    "id": 606,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建镜面反射动画？",
    "options": {
      "A": "使用 mirrorReflection()",
      "B": "使用变换矩阵和透明度渐变",
      "C": "使用 MirrorAnimation",
      "D": "ArkTS不支持镜面反射"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过变换矩阵实现镜像效果，配合透明度渐变创建逼真的镜面反射动画。"
  },
  {
    "id": 607,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的拓扑感知？",
    "options": {
      "A": "使用 http.topology() 方法",
      "B": "根据网络类型调整请求策略",
      "C": "使用 TopologyAware 类",
      "D": "ArkTS不支持拓扑感知"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据WiFi、4G等不同网络类型，动态调整请求的超时时间和重试策略。"
  },
  {
    "id": 608,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据分片的负载均衡策略？",
    "options": {
      "A": "轮询调度",
      "B": "最少连接",
      "C": "哈希分配",
      "D": "权重分配"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据分片的负载均衡支持轮询调度、最少连接、哈希分配和权重分配等策略。"
  },
  {
    "id": 609,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的过渡状态管理？",
    "options": {
      "A": "使用 Router.transitionState()",
      "B": "监听路由生命周期事件",
      "C": "使用 @TransitionState 装饰器",
      "D": "ArkTS不支持过渡状态管理"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过监听路由的生命周期事件，管理页面进入、离开等过渡状态。"
  },
  {
    "id": 610,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的按需编译？",
    "options": {
      "A": "使用 @OnDemand 装饰器",
      "B": "使用代码分割和动态导入",
      "C": "使用 OnDemandCompiler 类",
      "D": "ArkTS不支持按需编译"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过代码分割和动态导入技术，实现组件的按需编译和加载。"
  },
  {
    "id": 611,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的模式匹配？",
    "options": {
      "A": "使用 match 关键字",
      "B": "使用条件类型和 infer 关键字",
      "C": "使用 PatternMatch 类型",
      "D": "TypeScript不支持模式匹配"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件类型和 infer 关键字实现类型级别的模式匹配：type First<T> = T extends [infer U, ...any[]] ? U : never"
  },
  {
    "id": 612,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextInput 的输入限制属性？",
    "options": {
      "A": "maxLength",
      "B": "inputFilter",
      "C": "enterKeyType",
      "D": "showCounter"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "TextInput 支持 maxLength（最大长度）、inputFilter（输入过滤）等输入限制属性。"
  },
  {
    "id": 613,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的因果排序？",
    "options": {
      "A": "使用 @CausalOrder 装饰器",
      "B": "使用时间戳或序列号排序状态变更",
      "C": "使用 CausalOrderer 类",
      "D": "ArkTS不支持因果排序"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过时间戳或序列号对状态变更进行排序，确保因果一致性。"
  },
  {
    "id": 614,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的文件上传组件？",
    "options": {
      "A": "使用 @FileUpload 装饰器",
      "B": "使用 @BuilderParam 接收上传配置",
      "C": "使用 FileUploadManager 类",
      "D": "ArkTS不支持文件上传组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收文件类型、大小限制等上传配置，实现可配置的文件上传组件。"
  },
  {
    "id": 615,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridRow 的响应式断点配置？",
    "options": {
      "A": "breakpoints",
      "B": "direction",
      "C": "gutter",
      "D": "margin"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "GridRow 支持 breakpoints（断点）、direction（方向）、gutter（间隔）等响应式配置。"
  },
  {
    "id": 616,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建折叠展开动画？",
    "options": {
      "A": "使用 fold() 方法",
      "B": "使用高度或宽度的动态变化",
      "C": "使用 FoldAnimation",
      "D": "ArkTS不支持折叠动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过动态改变组件的高度或宽度，配合过渡动画实现折叠展开效果。"
  },
  {
    "id": 617,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的分布式追踪？",
    "options": {
      "A": "使用 http.trace() 方法",
      "B": "使用全局追踪ID和span",
      "C": "使用 DistributedTracer 类",
      "D": "ArkTS不支持分布式追踪"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过全局追踪ID和span记录请求链路，实现分布式系统下的请求追踪。"
  },
  {
    "id": 618,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据缓存的有效期策略？",
    "options": {
      "A": "固定时间",
      "B": "滑动时间",
      "C": "永久有效",
      "D": "依赖失效"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据缓存支持固定时间、滑动时间、永久有效和依赖失效等有效期策略。"
  },
  {
    "id": 619,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的并行加载？",
    "options": {
      "A": "使用 Router.parallelLoad()",
      "B": "使用 Promise.all 预加载多个路由",
      "C": "使用 @ParallelLoad 装饰器",
      "D": "ArkTS不支持并行加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 Promise.all 同时预加载多个路由组件，提升导航体验。"
  },
  {
    "id": 620,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的增量渲染？",
    "options": {
      "A": "使用 @IncrementalRender 装饰器",
      "B": "将组件拆分为多个渲染单元",
      "C": "使用 IncrementalRenderer 类",
      "D": "ArkTS不支持增量渲染"
    },
    "answer": [
      "B"
    ],
    "explanation": "将复杂组件拆分为多个渲染单元，分批次进行渲染，避免长时间阻塞UI线程。"
  },
  {
    "id": 621,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现函数的偏应用？",
    "options": {
      "A": "使用 partial 关键字",
      "B": "使用闭包固定部分参数",
      "C": "使用 @Partial 装饰器",
      "D": "TypeScript不支持偏应用"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过闭包固定函数的部分参数，返回接受剩余参数的新函数。"
  },
  {
    "id": 622,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextTimer 的倒计时配置？",
    "options": {
      "A": "countDown",
      "B": "controller",
      "C": "onTick",
      "D": "format"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextTimer 支持 countDown（倒计时）、controller（控制器）、onTick（计时事件）、format（格式）等配置。"
  },
  {
    "id": 623,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的版本控制？",
    "options": {
      "A": "使用 @Version 装饰器",
      "B": "为状态变更添加版本信息",
      "C": "使用 VersionControl 类",
      "D": "ArkTS不支持版本控制"
    },
    "answer": [
      "B"
    ],
    "explanation": "为每个状态变更添加版本号或时间戳，支持状态回滚和版本对比。"
  },
  {
    "id": 624,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的图片查看器组件？",
    "options": {
      "A": "使用 @ImageViewer 装饰器",
      "B": "使用 @BuilderParam 接收图片配置",
      "C": "使用 ImageViewerManager 类",
      "D": "ArkTS不支持图片查看器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收图片列表、缩放配置等，实现可配置的图片查看器。"
  },
  {
    "id": 625,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Stack 的层叠顺序属性？",
    "options": {
      "A": "zIndex",
      "B": "position",
      "C": "align",
      "D": "fit"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Stack 组件的 zIndex（层级）和 position（位置）属性用于控制子组件的层叠顺序。"
  },
  {
    "id": 626,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建体积光动画？",
    "options": {
      "A": "使用 volumetricLight()",
      "B": "使用渐变和模糊效果模拟光柱",
      "C": "使用 VolumetricLightAnimation",
      "D": "ArkTS不支持体积光动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过径向渐变和模糊效果模拟光线在介质中的散射，创建体积光效果。"
  },
  {
    "id": 627,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的压缩传输？",
    "options": {
      "A": "使用 http.compress() 方法",
      "B": "在请求头中设置压缩编码",
      "C": "使用 Compressor 类",
      "D": "ArkTS不支持压缩传输"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在请求头中设置 Accept-Encoding，支持gzip等压缩格式，减少传输数据量。"
  },
  {
    "id": 628,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据复制的同步模式？",
    "options": {
      "A": "同步复制",
      "B": "异步复制",
      "C": "半同步复制",
      "D": "级联复制"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据复制支持同步、异步、半同步和级联复制等同步模式。"
  },
  {
    "id": 629,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问统计？",
    "options": {
      "A": "使用 Router.analytics()",
      "B": "在路由守卫中记录访问数据",
      "C": "使用 @Analytics 装饰器",
      "D": "ArkTS不支持访问统计"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在路由守卫中记录页面访问时间、来源等数据，实现访问统计功能。"
  },
  {
    "id": 630,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染优先级？",
    "options": {
      "A": "使用 @RenderPriority 装饰器",
      "B": "使用调度器管理渲染队列",
      "C": "使用 RenderScheduler 类",
      "D": "ArkTS不支持渲染优先级"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过调度器管理组件的渲染队列，为重要组件分配更高的渲染优先级。"
  },
  {
    "id": 631,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归约束？",
    "options": {
      "A": "使用 recursive 关键字",
      "B": "在泛型约束中使用自身类型",
      "C": "使用 RecursiveConstraint 类型",
      "D": "TypeScript不支持递归约束"
    },
    "answer": [
      "B"
    ],
    "explanation": "在泛型约束中使用自身类型实现递归约束：interface Tree<T extends Tree<T>> { }"
  },
  {
    "id": 632,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextArea 的自动调整属性？",
    "options": {
      "A": "autoHeight",
      "B": "maxLines",
      "C": "minLines",
      "D": "adjustHeightToContent"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextArea 支持 autoHeight（自动高度）、maxLines（最大行数）、minLines（最小行数）等自动调整属性。"
  },
  {
    "id": 633,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的分片加载？",
    "options": {
      "A": "使用 @ChunkLoad 装饰器",
      "B": "将大状态拆分为多个分片按需加载",
      "C": "使用 ChunkLoader 类",
      "D": "ArkTS不支持分片加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "将大型状态数据拆分为多个分片，按需加载和更新，提升性能。"
  },
  {
    "id": 634,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的签名板组件？",
    "options": {
      "A": "使用 @SignaturePad 装饰器",
      "B": "使用 @BuilderParam 接收画板配置",
      "C": "使用 SignaturePadManager 类",
      "D": "ArkTS不支持签名板"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收画笔颜色、粗细等配置，实现可配置的签名板组件。"
  },
  {
    "id": 635,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Grid 的自动布局属性？",
    "options": {
      "A": "autoFit",
      "B": "autoFill",
      "C": "minColumnWidth",
      "D": "maxColumnWidth"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Grid 支持 autoFit（自动适应）、autoFill（自动填充）、minColumnWidth（最小列宽）、maxColumnWidth（最大列宽）等自动布局属性。"
  },
  {
    "id": 636,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建呼吸动画效果？",
    "options": {
      "A": "使用 breathe() 方法",
      "B": "使用缓动函数控制透明度变化",
      "C": "使用 BreatheAnimation",
      "D": "ArkTS不支持呼吸动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过缓动函数控制透明度的周期性变化，模拟呼吸的节奏感。"
  },
  {
    "id": 637,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的容错降级？",
    "options": {
      "A": "使用 http.fallback() 方法",
      "B": "提供多级备用方案和优雅降级",
      "C": "使用 FaultTolerance 类",
      "D": "ArkTS不支持容错降级"
    },
    "answer": [
      "B"
    ],
    "explanation": "为关键请求提供多级备用方案，在主方案失败时自动降级到备用方案。"
  },
  {
    "id": 638,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据索引的类型？",
    "options": {
      "A": "B树索引",
      "B": "哈希索引",
      "C": "全文索引",
      "D": "空间索引"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据索引支持B树索引、哈希索引、全文索引和空间索引等类型。"
  },
  {
    "id": 639,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的离线缓存？",
    "options": {
      "A": "使用 Router.cache()",
      "B": "使用Service Worker缓存路由资源",
      "C": "使用 @CacheRoute 装饰器",
      "D": "ArkTS不支持离线缓存"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Service Worker技术缓存路由相关的静态资源，支持离线访问。"
  },
  {
    "id": 640,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染缓存？",
    "options": {
      "A": "使用 @RenderCache 装饰器",
      "B": "使用keep-alive和状态保持",
      "C": "使用 RenderCacheManager 类",
      "D": "ArkTS不支持渲染缓存"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过keep-alive机制和状态保持，避免组件重复渲染，提升性能。"
  },
  {
    "id": 641,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现异步迭代的取消？",
    "options": {
      "A": "使用 AbortController",
      "B": "使用 cancel 方法",
      "C": "使用 @Cancelable 装饰器",
      "D": "TypeScript不支持异步迭代取消"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过 AbortController 和 AbortSignal 实现异步迭代的取消功能。"
  },
  {
    "id": 642,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Web 组件的加载控制方法？",
    "options": {
      "A": "loadUrl",
      "B": "refresh",
      "C": "stop",
      "D": "clearHistory"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Web 组件支持 loadUrl（加载网址）、refresh（刷新）、stop（停止）、clearHistory（清除历史）等方法。"
  },
  {
    "id": 643,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的最终一致性？",
    "options": {
      "A": "使用 @EventuallyConsistent 装饰器",
      "B": "使用冲突解决和状态同步机制",
      "C": "使用 EventuallyConsistentState 类",
      "D": "ArkTS不支持最终一致性"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过冲突解决算法和状态同步机制，保证分布式状态最终达到一致。"
  },
  {
    "id": 644,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的音频播放器组件？",
    "options": {
      "A": "使用 @AudioPlayer 装饰器",
      "B": "使用 @BuilderParam 接收音频配置",
      "C": "使用 AudioPlayerManager 类",
      "D": "ArkTS不支持音频播放器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收音频源、控制选项等配置，实现可配置的音频播放器。"
  },
  {
    "id": 645,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Flex 的基线对齐属性？",
    "options": {
      "A": "Baseline",
      "B": "FirstBaseline",
      "C": "LastBaseline",
      "D": "TextBaseline"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Flex 布局支持 Baseline（基线）、FirstBaseline（首行基线）、LastBaseline（末行基线）等对齐方式。"
  },
  {
    "id": 646,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建全息投影动画？",
    "options": {
      "A": "使用 hologram() 方法",
      "B": "使用多层渐变和扫描线效果",
      "C": "使用 HologramAnimation",
      "D": "ArkTS不支持全息投影"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过多层渐变叠加和扫描线效果，模拟全息投影的视觉特征。"
  },
  {
    "id": 647,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的带宽估计？",
    "options": {
      "A": "使用 http.bandwidth() 方法",
      "B": "通过下载测速和网络探测",
      "C": "使用 BandwidthEstimator 类",
      "D": "ArkTS不支持带宽估计"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过下载小文件测量速度，结合网络类型探测，估计可用带宽。"
  },
  {
    "id": 648,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据迁移的验证指标？",
    "options": {
      "A": "数据完整性",
      "B": "性能影响",
      "C": "业务连续性",
      "D": "回滚能力"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据迁移验证需要考察数据完整性、性能影响、业务连续性和回滚能力等指标。"
  },
  {
    "id": 649,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的渐进式注册？",
    "options": {
      "A": "使用 Router.progressiveRegister()",
      "B": "按模块动态注册路由配置",
      "C": "使用 @ProgressiveRegister 装饰器",
      "D": "ArkTS不支持渐进式注册"
    },
    "answer": [
      "B"
    ],
    "explanation": "按功能模块动态注册路由配置，减少初始加载时间。"
  },
  {
    "id": 650,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染预测？",
    "options": {
      "A": "使用 @RenderPredict 装饰器",
      "B": "基于用户行为预渲染组件",
      "C": "使用 RenderPredictor 类",
      "D": "ArkTS不支持渲染预测"
    },
    "answer": [
      "B"
    ],
    "explanation": "基于用户行为和交互模式，预测下一步可能需要的组件并进行预渲染。"
  },
  {
    "id": 651,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的路径查询？",
    "options": {
      "A": "使用 path 关键字",
      "B": "使用模板字面量类型和索引访问",
      "C": "使用 PathQuery 类型",
      "D": "TypeScript不支持路径查询"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过模板字面量类型和索引访问实现类型路径查询：type Path<T, K extends string> = K extends keyof T ? T[K] : never"
  },
  {
    "id": 652,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextClock 的时区配置？",
    "options": {
      "A": "timeZone",
      "B": "timeZoneOffset",
      "C": "timeZoneName",
      "D": "useSystemTimeZone"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "TextClock 支持 timeZone（时区）和 timeZoneOffset（时区偏移）等配置。"
  },
  {
    "id": 653,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的快照压缩？",
    "options": {
      "A": "使用 @SnapshotCompress 装饰器",
      "B": "使用差异算法压缩快照数据",
      "C": "使用 SnapshotCompressor 类",
      "D": "ArkTS不支持快照压缩"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过差异算法比较连续快照，只存储变化部分，压缩快照数据。"
  },
  {
    "id": 654,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的3D卡片组件？",
    "options": {
      "A": "使用 @3DCard 装饰器",
      "B": "使用变换和透视效果",
      "C": "使用 ThreeDCardManager 类",
      "D": "ArkTS不支持3D卡片"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过CSS变换和透视效果，创建具有3D视觉效果的卡片组件。"
  },
  {
    "id": 655,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 WaterFlow 的瀑布流属性？",
    "options": {
      "A": "columnsTemplate",
      "B": "rowsTemplate",
      "C": "itemLayout",
      "D": "layoutDirection"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "WaterFlow 组件支持 columnsTemplate（列模板）和 itemLayout（项布局）等瀑布流属性。"
  },
  {
    "id": 656,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建涟漪动画效果？",
    "options": {
      "A": "使用 ripple() 方法",
      "B": "使用圆形扩散和透明度变化",
      "C": "使用 RippleAnimation",
      "D": "ArkTS不支持涟漪动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过圆形从中心向外扩散，配合透明度渐变，创建涟漪扩散效果。"
  },
  {
    "id": 657,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的服务网格集成？",
    "options": {
      "A": "使用 http.mesh() 方法",
      "B": "通过Sidecar代理和服务发现",
      "C": "使用 ServiceMesh 类",
      "D": "ArkTS不支持服务网格"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Sidecar代理处理服务发现、负载均衡等，实现服务网格集成。"
  },
  {
    "id": 658,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据归档的存储格式？",
    "options": {
      "A": "压缩格式",
      "B": "列式存储",
      "C": "序列化格式",
      "D": "加密格式"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据归档支持压缩格式、列式存储、序列化格式和加密格式等存储方式。"
  },
  {
    "id": 659,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的A/B测试集成？",
    "options": {
      "A": "使用 Router.abTest()",
      "B": "根据用户分组动态渲染组件",
      "C": "使用 ABTestRouter 类",
      "D": "ArkTS不支持A/B测试"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据用户分组信息，在路由级别动态渲染不同版本的组件。"
  },
  {
    "id": 660,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染节流？",
    "options": {
      "A": "使用 @ThrottleRender 装饰器",
      "B": "使用防抖节流控制渲染频率",
      "C": "使用 RenderThrottler 类",
      "D": "ArkTS不支持渲染节流"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过防抖节流技术控制高频状态变化时的渲染频率，避免过度渲染。"
  },
  {
    "id": 661,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现Promise的竞态处理？",
    "options": {
      "A": "使用 Promise.race()",
      "B": "使用竞态条件检测",
      "C": "使用 @RaceCondition 装饰器",
      "D": "TypeScript不支持竞态处理"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Promise.race() 方法处理多个Promise的竞态情况。"
  },
  {
    "id": 662,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextInput 的键盘相关属性？",
    "options": {
      "A": "enterKeyType",
      "B": "caretColor",
      "C": "showCounter",
      "D": "maxLines"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "TextInput 支持 enterKeyType（回车键类型）、caretColor（光标颜色）等键盘相关属性。"
  },
  {
    "id": 663,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的事务回滚？",
    "options": {
      "A": "使用 @TransactionRollback 装饰器",
      "B": "使用命令模式和状态快照",
      "C": "使用 TransactionManager 类",
      "D": "ArkTS不支持事务回滚"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过命令模式记录状态操作，配合状态快照实现事务回滚功能。"
  },
  {
    "id": 664,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的图表组件？",
    "options": {
      "A": "使用 @Chart 装饰器",
      "B": "使用 @BuilderParam 接收图表配置",
      "C": "使用 ChartEngine 类",
      "D": "ArkTS不支持图表组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收图表类型、数据、样式等配置，实现可配置的图表组件。"
  },
  {
    "id": 665,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Column 的分布方式？",
    "options": {
      "A": "SpaceBetween",
      "B": "SpaceAround",
      "C": "SpaceEvenly",
      "D": "Stretch"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Column 组件支持 SpaceBetween（两端对齐）、SpaceAround（环绕对齐）、SpaceEvenly（均匀对齐）等分布方式。"
  },
  {
    "id": 666,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建粒子爆炸动画？",
    "options": {
      "A": "使用 particleExplosion()",
      "B": "使用粒子系统和物理引擎",
      "C": "使用 ExplosionAnimation",
      "D": "ArkTS不支持粒子爆炸"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过粒子系统模拟碎片，配合物理引擎计算运动轨迹，创建爆炸效果。"
  },
  {
    "id": 667,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的认证代理？",
    "options": {
      "A": "使用 http.proxy() 方法",
      "B": "使用中间件处理认证逻辑",
      "C": "使用 AuthProxy 类",
      "D": "ArkTS不支持认证代理"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过中间件统一处理认证逻辑，避免在每个请求中重复实现。"
  },
  {
    "id": 668,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据备份的存储策略？",
    "options": {
      "A": "本地存储",
      "B": "云存储",
      "C": "异地备份",
      "D": "冷热备份"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据备份支持本地存储、云存储、异地备份和冷热备份等存储策略。"
  },
  {
    "id": 669,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的深度链接处理？",
    "options": {
      "A": "使用 Router.handleDeepLink()",
      "B": "解析URL参数并导航到对应路由",
      "C": "使用 DeepLinkHandler 类",
      "D": "ArkTS不支持深度链接"
    },
    "answer": [
      "B"
    ],
    "explanation": "解析深度链接的URL参数，映射到对应的路由和状态。"
  },
  {
    "id": 670,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染隔离？",
    "options": {
      "A": "使用 @RenderIsolate 装饰器",
      "B": "使用Web Worker进行渲染计算",
      "C": "使用 RenderIsolator 类",
      "D": "ArkTS不支持渲染隔离"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Web Worker在后台线程进行复杂的渲染计算，避免阻塞主线程。"
  },
  {
    "id": 671,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归只读？",
    "options": {
      "A": "使用 DeepReadonly<T>",
      "B": "使用递归映射类型",
      "C": "使用 @DeepReadonly 装饰器",
      "D": "TypeScript不支持递归只读"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归映射类型实现深度只读：type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }"
  },
  {
    "id": 672,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Image 的加载优化属性？",
    "options": {
      "A": "alt",
      "B": "objectFit",
      "C": "loadStrategy",
      "D": "placeholder"
    },
    "answer": [
      "C",
      "D"
    ],
    "explanation": "Image 组件支持 loadStrategy（加载策略）和 placeholder（占位图）等加载优化属性。"
  },
  {
    "id": 673,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的事件溯源？",
    "options": {
      "A": "使用 @EventSourcing 装饰器",
      "B": "存储状态变更事件序列",
      "C": "使用 EventSourcer 类",
      "D": "ArkTS不支持事件溯源"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过存储完整的状态变更事件序列，支持状态重建和审计。"
  },
  {
    "id": 674,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的代码编辑器组件？",
    "options": {
      "A": "使用 @CodeEditor 装饰器",
      "B": "使用 @BuilderParam 接收编辑器配置",
      "C": "使用 CodeEditorManager 类",
      "D": "ArkTS不支持代码编辑器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收语法高亮、主题等配置，实现可配置的代码编辑器。"
  },
  {
    "id": 675,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridRow 的响应式配置？",
    "options": {
      "A": "breakpoints",
      "B": "columns",
      "C": "gutter",
      "D": "margin"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "GridRow 支持 breakpoints（断点）、columns（列数）、gutter（间隔）等响应式配置。"
  },
  {
    "id": 676,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建抖动动画效果？",
    "options": {
      "A": "使用 shake() 方法",
      "B": "使用快速的位置变化序列",
      "C": "使用 ShakeAnimation",
      "D": "ArkTS不支持抖动动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过快速的位置变化序列，创建元素的抖动效果。"
  },
  {
    "id": 677,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的智能重试？",
    "options": {
      "A": "使用 http.smartRetry() 方法",
      "B": "根据错误类型和网络状态调整重试策略",
      "C": "使用 SmartRetry 类",
      "D": "ArkTS不支持智能重试"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据错误类型、网络状态和服务端负载动态调整重试间隔和次数。"
  },
  {
    "id": 678,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据验证的规则类型？",
    "options": {
      "A": "必填验证",
      "B": "格式验证",
      "C": "范围验证",
      "D": "自定义验证"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据验证支持必填验证、格式验证、范围验证和自定义验证等规则类型。"
  },
  {
    "id": 679,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问控制列表？",
    "options": {
      "A": "使用 Router.acl()",
      "B": "基于角色和权限控制路由访问",
      "C": "使用 ACLRouter 类",
      "D": "ArkTS不支持访问控制"
    },
    "answer": [
      "B"
    ],
    "explanation": "基于用户角色和权限配置，控制对不同路由的访问权限。"
  },
  {
    "id": 680,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染流水线？",
    "options": {
      "A": "使用 @RenderPipeline 装饰器",
      "B": "将渲染过程分解为多个阶段",
      "C": "使用 RenderPipeline 类",
      "D": "ArkTS不支持渲染流水线"
    },
    "answer": [
      "B"
    ],
    "explanation": "将组件渲染过程分解为数据准备、虚拟DOM构建、差异计算等多个阶段，优化渲染性能。"
  },
  {
    "id": 681,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现Generator的错误处理？",
    "options": {
      "A": "使用 try-catch 包裹 yield",
      "B": "使用 throw 方法向Generator抛错",
      "C": "使用 @ErrorHandle 装饰器",
      "D": "TypeScript不支持Generator错误处理"
    },
    "answer": [
      "A"
    ],
    "explanation": "在Generator函数内部使用try-catch语句捕获和处理错误。"
  },
  {
    "id": 682,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextTimer 的格式化选项？",
    "options": {
      "A": "HH:mm:ss",
      "B": "mm:ss",
      "C": "ss",
      "D": "HH"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextTimer 支持 HH:mm:ss（时分秒）、mm:ss（分秒）、ss（秒）、HH（时）等格式化选项。"
  },
  {
    "id": 683,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的分阶段提交？",
    "options": {
      "A": "使用 @StagedCommit 装饰器",
      "B": "使用两阶段提交协议",
      "C": "使用 StagedCommitter 类",
      "D": "ArkTS不支持分阶段提交"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过两阶段提交协议，确保分布式状态变更的原子性。"
  },
  {
    "id": 684,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的 markdown 渲染组件？",
    "options": {
      "A": "使用 @Markdown 装饰器",
      "B": "使用 @BuilderParam 接收markdown配置",
      "C": "使用 MarkdownRenderer 类",
      "D": "ArkTS不支持markdown渲染"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收markdown文本和渲染配置，实现可配置的markdown渲染组件。"
  },
  {
    "id": 685,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Row 的交叉轴对齐方式？",
    "options": {
      "A": "Top",
      "B": "Center",
      "C": "Bottom",
      "D": "Stretch"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Row 组件支持 Top（顶部）、Center（居中）、Bottom（底部）、Stretch（拉伸）等交叉轴对齐方式。"
  },
  {
    "id": 686,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建 morphing 形状动画？",
    "options": {
      "A": "使用 morph() 方法",
      "B": "使用路径插值和形变算法",
      "C": "使用 MorphAnimation",
      "D": "ArkTS不支持形状动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过路径插值算法在不同形状之间平滑过渡，创建形状变形动画。"
  },
  {
    "id": 687,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的协议升级？",
    "options": {
      "A": "使用 http.upgrade() 方法",
      "B": "支持HTTP/2和WebSocket等协议",
      "C": "使用 ProtocolUpgrader 类",
      "D": "ArkTS不支持协议升级"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据服务端支持情况，自动升级到HTTP/2、WebSocket等更高效的协议。"
  },
  {
    "id": 688,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据同步的冲突检测方法？",
    "options": {
      "A": "版本向量",
      "B": "时间戳",
      "C": "操作转换",
      "D": "状态对比"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据同步冲突检测可以使用版本向量、时间戳、操作转换和状态对比等方法。"
  },
  {
    "id": 689,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问日志？",
    "options": {
      "A": "使用 Router.log()",
      "B": "在路由守卫中记录访问信息",
      "C": "使用 @AccessLog 装饰器",
      "D": "ArkTS不支持访问日志"
    },
    "answer": [
      "B"
    ],
    "explanation": "在路由守卫中记录用户访问路径、时间和参数等信息。"
  },
  {
    "id": 690,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染预热？",
    "options": {
      "A": "使用 @Warmup 装饰器",
      "B": "预加载和预渲染可能需要的组件",
      "C": "使用 WarmupManager 类",
      "D": "ArkTS不支持渲染预热"
    },
    "answer": [
      "B"
    ],
    "explanation": "基于用户行为预测，提前加载和渲染可能需要的组件，减少等待时间。"
  },
  {
    "id": 691,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归可选？",
    "options": {
      "A": "使用 DeepPartial<T>",
      "B": "使用递归映射类型和可选修饰符",
      "C": "使用 @DeepPartial 装饰器",
      "D": "TypeScript不支持递归可选"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归映射类型实现深度可选：type DeepPartial<T> = { [P in keyof T]?: DeepPartial<T[P]> }"
  },
  {
    "id": 692,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextArea 的滚动配置？",
    "options": {
      "A": "scrollable",
      "B": "scrollBar",
      "C": "onScroll",
      "D": "scrollTop"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextArea 支持 scrollable（可滚动）、scrollBar（滚动条）、onScroll（滚动事件）等配置。"
  },
  {
    "id": 693,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的增量同步？",
    "options": {
      "A": "使用 @IncrementalSync 装饰器",
      "B": "只同步发生变化的状态部分",
      "C": "使用 IncrementalSyncer 类",
      "D": "ArkTS不支持增量同步"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过差异检测算法，只同步状态的变化部分，减少网络传输量。"
  },
  {
    "id": 694,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的富文本编辑器组件？",
    "options": {
      "A": "使用 @RichTextEditor 装饰器",
      "B": "使用 @BuilderParam 接收编辑器配置",
      "C": "使用 RichTextEditorManager 类",
      "D": "ArkTS不支持富文本编辑器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收工具栏配置、内容格式等，实现可配置的富文本编辑器。"
  },
  {
    "id": 695,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Flex 的伸缩因子属性？",
    "options": {
      "A": "flexGrow",
      "B": "flexShrink",
      "C": "flexBasis",
      "D": "flexWrap"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Flex 布局支持 flexGrow（放大比例）、flexShrink（缩小比例）、flexBasis（初始大小）等伸缩因子属性。"
  },
  {
    "id": 696,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建旋转进入动画？",
    "options": {
      "A": "使用 rotateIn() 方法",
      "B": "使用旋转和透明度动画组合",
      "C": "使用 RotateInAnimation",
      "D": "ArkTS不支持旋转进入动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过旋转角度从0到目标值，配合透明度从0到1的变化，创建旋转进入效果。"
  },
  {
    "id": 697,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的负载 shedding？",
    "options": {
      "A": "使用 http.shed() 方法",
      "B": "在系统过载时拒绝低优先级请求",
      "C": "使用 LoadShedder 类",
      "D": "ArkTS不支持负载 shedding"
    },
    "answer": [
      "B"
    ],
    "explanation": "在系统资源紧张时，根据请求优先级拒绝部分低优先级请求，保证系统稳定性。"
  },
  {
    "id": 698,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据索引的维护操作？",
    "options": {
      "A": "创建索引",
      "B": "重建索引",
      "C": "删除索引",
      "D": "优化索引"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据索引支持创建、重建、删除和优化等维护操作。"
  },
  {
    "id": 699,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问频率限制？",
    "options": {
      "A": "使用 Router.rateLimit()",
      "B": "使用令牌桶算法限制路由访问",
      "C": "使用 RateLimitRouter 类",
      "D": "ArkTS不支持访问频率限制"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过令牌桶算法限制用户在一定时间内的路由访问次数。"
  },
  {
    "id": 700,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染合并？",
    "options": {
      "A": "使用 @MergeRender 装饰器",
      "B": "将多个组件渲染合并为单个操作",
      "C": "使用 RenderMerger 类",
      "D": "ArkTS不支持渲染合并"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过批处理技术将多个组件的渲染操作合并为单个操作，减少渲染开销。"
  },
  {
    "id": 701,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确声明一个只读变量？",
    "options": {
      "A": "const num: number = 10",
      "B": "let num: number = 10",
      "C": "var num: number = 10",
      "D": "readonly num: number = 10"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中使用 const 声明只读变量，声明后不能被重新赋值；let 声明可修改的变量，var 是兼容 JavaScript 的声明方式，readonly 用于类属性"
  },
  {
    "id": 702,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，以下哪些方法可以实现数据传递给子组件？",
    "options": {
      "A": "通过组件属性传递",
      "B": "通过 @Link 双向绑定",
      "C": "通过全局变量",
      "D": "通过事件回调传递"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "父组件向子组件传递数据的方式包括：属性传递（单向）、@Link 双向绑定、全局变量共享；事件回调通常用于子组件向父组件传递数据"
  },
  {
    "id": 703,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@StorageLink 装饰的状态与 AppStorage 的关系是？",
    "options": {
      "A": "双向绑定",
      "B": "单向绑定（从 AppStorage 到组件）",
      "C": "单向绑定（从组件到 AppStorage）",
      "D": "无绑定关系"
    },
    "answer": [
      "A"
    ],
    "explanation": "@StorageLink 与 AppStorage 建立双向绑定，组件修改状态会同步到 AppStorage，AppStorage 状态变化也会同步到组件"
  },
  {
    "id": 704,
    "type": "single",
    "category": "布局设计",
    "difficulty": "简单",
    "question": "以下哪种布局适合实现瀑布流效果？",
    "options": {
      "A": "WaterFlow",
      "B": "Grid",
      "C": "List",
      "D": "Masonry"
    },
    "answer": [
      "A"
    ],
    "explanation": "WaterFlow 组件专门用于实现瀑布流布局，支持不同高度的子组件按列排列，自动填充空白区域"
  },
  {
    "id": 705,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些事件属于组件尺寸变化事件？",
    "options": {
      "A": "onSizeChange",
      "B": "onLayout",
      "C": "onResize",
      "D": "onDimensionChange"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "onSizeChange 在组件尺寸变化时触发，onLayout 在组件布局完成时触发，均与组件尺寸变化相关；ArkTS 中没有 onResize 和 onDimensionChange 事件"
  },
  {
    "id": 706,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示可折叠列表的组件是？",
    "options": {
      "A": "Collapsible",
      "B": "ExpandableList",
      "C": "Accordion",
      "D": "FoldList"
    },
    "answer": [
      "C"
    ],
    "explanation": "Accordion 组件用于实现可折叠列表，由多个 AccordionItem 组成，支持展开 / 折叠交互"
  },
  {
    "id": 707,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "鸿蒙分布式设备发现主要通过哪个模块实现？",
    "options": {
      "A": "deviceManager",
      "B": "discovery",
      "C": "deviceDiscovery",
      "D": "distributedManager"
    },
    "answer": [
      "A"
    ],
    "explanation": "deviceManager 模块提供了分布式设备的发现、管理能力，支持获取周围可用的鸿蒙设备列表"
  },
  {
    "id": 708,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些路由操作会改变路由栈的长度？",
    "options": {
      "A": "router.pushUrl ()",
      "B": "router.replaceUrl ()",
      "C": "router.back ()",
      "D": "router.clear ()"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "pushUrl 增加栈长度，back 减少栈长度，clear 清空栈（长度变为 0）；replaceUrl 替换当前页面，栈长度不变"
  },
  {
    "id": 709,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置组件的圆角半径？",
    "options": {
      "A": ".borderRadius (10)",
      "B": ".radius (10)",
      "C": ".cornerRadius (10)",
      "D": ".round (10)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.borderRadius () 方法设置组件的圆角半径，参数为像素值，可统一设置四个角的半径"
  },
  {
    "id": 710,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确定义一个泛型函数？",
    "options": {
      "A": "function identity<T>(arg: T): T { return arg }",
      "B": "function identity(arg: any): any { return arg }",
      "C": "generic function identity<T>(arg: T): T { return arg }",
      "D": "function identity<T>(arg: T): any { return arg }"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中泛型函数的定义格式为在函数名后使用<T>声明类型参数，参数和返回值使用该类型参数 "
  },
  {
    "id": 711,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "页面级组件特有的生命周期函数是？",
    "options": {
      "A": "onPageShow ()",
      "B": "onAppear ()",
      "C": "onCreate ()",
      "D": "onDestroy ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onPageShow () 是页面级组件特有的生命周期函数，在页面显示时触发；其他为所有组件共有的生命周期"
  },
  {
    "id": 712,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "以下哪些状态管理方式支持跨页面共享数据？",
    "options": {
      "A": "AppStorage",
      "B": "Preferences",
      "C": "LocalStorage",
      "D": "@Provide/@Consume"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "AppStorage（内存全局状态）和 Preferences（持久化存储）支持跨页面共享数据；LocalStorage 和 @Provide/@Consume 局限于组件层级"
  },
  {
    "id": 713,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Flex 布局中，flexDirection 属性的默认值是？",
    "options": {
      "A": "Row",
      "B": "Column",
      "C": "RowReverse",
      "D": "ColumnReverse"
    },
    "answer": [
      "A"
    ],
    "explanation": "Flex 布局的 flexDirection 属性默认值为 Row，即子组件按水平方向排列"
  },
  {
    "id": 714,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "旋转手势（Rotate）的事件参数中，angle 表示什么？",
    "options": {
      "A": "旋转的角度",
      "B": "旋转的速度",
      "C": "旋转的方向",
      "D": "旋转的中心点"
    },
    "answer": [
      "A"
    ],
    "explanation": "旋转手势事件的 angle 参数表示旋转的角度，单位为度，正值表示顺时针旋转，负值表示逆时针旋转"
  },
  {
    "id": 715,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "以下哪些组件支持滑动操作？",
    "options": {
      "A": "Slider",
      "B": "SwipeItem",
      "C": "Scroll",
      "D": "Swiper"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Slider（滑动选择器）、SwipeItem（滑动操作项）、Scroll（滚动容器）、Swiper（轮播）均支持滑动操作"
  },
  {
    "id": 716,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式任务调度中，如何指定任务在特定类型的设备上执行？",
    "options": {
      "A": "通过 deviceType 参数指定",
      "B": "通过 deviceId 参数指定",
      "C": "通过 deviceName 参数指定",
      "D": "无法指定，自动分配"
    },
    "answer": [
      "A"
    ],
    "explanation": "分布式任务调度可通过 deviceType 参数指定任务执行的设备类型（如 'phone'、'tablet'、'tv' 等）"
  },
  {
    "id": 717,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "路由跳转时，如何设置页面切换动画？",
    "options": {
      "A": "在 router.pushUrl () 的 options 中设置 animation 参数",
      "B": "在 main_pages.json 中配置 animation 属性",
      "C": "使用 @Animation 装饰器",
      "D": "通过页面的 onTransition () 方法设置"
    },
    "answer": [
      "A"
    ],
    "explanation": "路由跳转时，可在 router.pushUrl () 或 router.replaceUrl () 的 options 参数中设置 animation 属性指定切换动画"
  },
  {
    "id": 718,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的边框？",
    "options": {
      "A": ".border ({ width: 2, color: Color.Black })",
      "B": ".borderWidth (2)",
      "C": ".borderColor (Color.Black)",
      "D": ".borderRadius (5)"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "border () 设置完整边框属性，borderWidth () 设置边框宽度，borderColor () 设置边框颜色；borderRadius () 设置圆角，与边框样式无关"
  },
  {
    "id": 719,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，typeof 运算符返回的值不包括以下哪项？",
    "options": {
      "A": "object",
      "B": "array",
      "C": "number",
      "D": "boolean"
    },
    "answer": [
      "B"
    ],
    "explanation": "typeof 运算符对数组返回 'object'，而不是 'array'；其他选项均为 typeof 可能返回的结果"
  },
  {
    "id": 720,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何定义可选属性？",
    "options": {
      "A": "在属性名后添加问号（?）",
      "B": "使用 optional 关键字",
      "C": "不指定属性类型",
      "D": "设置默认值"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中通过在属性名后添加问号（?）标记可选属性，如 'name?: string' 表示 name 属性可选"
  },
  {
    "id": 721,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数会在页面返回时触发？",
    "options": {
      "A": "onPageShow ()",
      "B": "onAppear ()",
      "C": "onPageHide ()",
      "D": "onDisappear ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "页面返回时，前一个页面会重新显示，触发 onPageShow () 和 onAppear () 生命周期函数"
  },
  {
    "id": 722,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 存储的数据类型不包括以下哪项？",
    "options": {
      "A": "函数",
      "B": "字符串",
      "C": "布尔值",
      "D": "数字"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 支持存储字符串、数字、布尔值等基本数据类型，不支持函数、对象等复杂类型"
  },
  {
    "id": 723,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "RelativeContainer 中，如何设置组件相对于父容器居中对齐？",
    "options": {
      "A": ".alignRules ({ center: { anchor: 'container', align: VerticalAlign.Center } })",
      "B": ".centerInParent (true)",
      "C": ".align (Alignment.Center)",
      "D": ".position ({ x: '50%', y: '50%' })"
    },
    "answer": [
      "A"
    ],
    "explanation": "RelativeContainer 中通过 alignRules 设置对齐规则，使用'container' 表示父容器，结合 VerticalAlign 和 HorizontalAlign 设置居中 "
  },
  {
    "id": 724,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "困难",
    "question": "以下哪些是触摸事件的事件对象属性？",
    "options": {
      "A": "touches",
      "B": "changedTouches",
      "C": "target",
      "D": "timestamp"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "触摸事件对象包含 touches（当前所有触摸点）、changedTouches（变化的触摸点）、target（事件源）、timestamp（时间戳）等属性"
  },
  {
    "id": 725,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示带有数字提示的组件是？",
    "options": {
      "A": "Badge",
      "B": "Label",
      "C": "Tag",
      "D": "Notice"
    },
    "answer": [
      "A"
    ],
    "explanation": "Badge 组件用于在其他组件上显示数字或文本提示，通常用于表示未读消息数量"
  },
  {
    "id": 726,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式数据对象的同步模式不包括以下哪项？",
    "options": {
      "A": "手动同步",
      "B": "自动同步",
      "C": "条件同步",
      "D": "定时同步"
    },
    "answer": [
      "D"
    ],
    "explanation": "分布式数据对象支持手动同步、自动同步和条件同步，不支持定时同步模式"
  },
  {
    "id": 727,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些方法可以获取当前页面的路径？",
    "options": {
      "A": "router.getState ().currentUrl",
      "B": "$router.currentUrl",
      "C": "getCurrentPageUrl ()",
      "D": "router.getCurrentUrl ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过 router.getState () 获取路由状态对象，其 currentUrl 属性表示当前页面的路径"
  },
  {
    "id": 728,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的背景图片平铺方式？",
    "options": {
      "A": ".backgroundImageSize (ImageSize.Cover)",
      "B": ".backgroundImageRepeat (ImageRepeat.Repeat)",
      "C": ".backgroundImagePosition (Alignment.Center)",
      "D": ".backgroundImageMode ('repeat')"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用.backgroundImageRepeat () 方法设置背景图片的平铺方式，参数为 ImageRepeat 枚举值（如 Repeat、NoRepeat 等）"
  },
  {
    "id": 729,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确解构对象？",
    "options": {
      "A": "const { name, age } = person",
      "B": "const [name, age] = person",
      "C": "const { 0: name, 1: age } = person",
      "D": "const { name: username, age } = person"
    },
    "answer": [
      "A"
    ],
    "explanation": "对象解构使用 {}，通过属性名匹配；数组解构使用 []，按索引匹配；选项 D 是重命名解构，但原问题问的是正确解构方式，A 更直接正确"
  },
  {
    "id": 730,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些方法可以实现组件的循环渲染？",
    "options": {
      "A": "ForEach",
      "B": "LazyForEach",
      "C": "map ()",
      "D": "loop ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "ArkTS 中通过 ForEach（立即渲染）和 LazyForEach（懒加载渲染）实现组件的循环渲染；map () 是数组方法，loop () 不存在"
  },
  {
    "id": 731,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onPageHide () 生命周期函数在什么时候调用？",
    "options": {
      "A": "页面被隐藏时",
      "B": "页面被销毁时",
      "C": "应用进入后台时",
      "D": "设备休眠时"
    },
    "answer": [
      "A"
    ],
    "explanation": "onPageHide () 在页面被隐藏时调用（如跳转到其他页面），但页面并未销毁，仍保留在路由栈中"
  },
  {
    "id": 732,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何监听 AppStorage 中某个状态的变化？",
    "options": {
      "A": "AppStorage.on ('change', 'key', callback)",
      "B": "@Watch ('onKeyChange') @StorageProp ('key') key",
      "C": "AppStorage.watch ('key', callback)",
      "D": "以上都可以"
    },
    "answer": [
      "B"
    ],
    "explanation": "在组件中通过 @Watch 装饰器结合 @StorageProp 或 @StorageLink 可以监听 AppStorage 中状态的变化；AppStorage 本身没有 on 或 watch 方法"
  },
  {
    "id": 733,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置内边距（padding）？",
    "options": {
      "A": "Column",
      "B": "Row",
      "C": "Stack",
      "D": "All 布局容器"
    },
    "answer": [
      "D"
    ],
    "explanation": "所有布局容器都支持通过 padding () 方法设置内边距，控制子组件与容器边缘的距离"
  },
  {
    "id": 734,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件不属于手势事件？",
    "options": {
      "A": "onClick",
      "B": "onLongPress",
      "C": "onSwipe",
      "D": "onTouchMove"
    },
    "answer": [
      "D"
    ],
    "explanation": "onTouchMove 属于触摸事件，其他选项（onClick、onLongPress、onSwipe）均属于手势事件"
  },
  {
    "id": 735,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示时间选择器的组件是？",
    "options": {
      "A": "TimePicker",
      "B": "ClockPicker",
      "C": "DateTimePicker",
      "D": "HourMinutePicker"
    },
    "answer": [
      "A"
    ],
    "explanation": "TimePicker 组件用于选择时间（时、分），DateTimePicker 用于选择日期和时间"
  },
  {
    "id": 736,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式服务的调用结果处理方式？",
    "options": {
      "A": "同步调用",
      "B": "异步回调",
      "C": "Promise",
      "D": "事件通知"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "分布式服务支持同步调用、异步回调和 Promise 三种结果处理方式，事件通知是另一种通信模式"
  },
  {
    "id": 737,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.enableAlertBeforeBackPage () 的作用是？",
    "options": {
      "A": "设置返回前是否显示确认对话框",
      "B": "启用返回页面的动画效果",
      "C": "设置返回页面的拦截器",
      "D": "记录返回页面的日志"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.enableAlertBeforeBackPage () 用于设置在返回前是否显示确认对话框，防止用户误操作"
  },
  {
    "id": 738,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的行高？",
    "options": {
      "A": ".lineHeight (24)",
      "B": ".textLineHeight (24)",
      "C": ".lineSpacing (24)",
      "D": ".textHeight (24)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.lineHeight () 方法设置文本的行高，即文本行之间的垂直距离"
  },
  {
    "id": 739,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，Promise 的 finally () 方法的作用是？",
    "options": {
      "A": "无论 Promise 成功或失败都会执行",
      "B": "仅当 Promise 成功时执行",
      "C": "仅当 Promise 失败时执行",
      "D": "终止 Promise 的执行"
    },
    "answer": [
      "A"
    ],
    "explanation": "finally () 方法用于指定无论 Promise 对象最后状态如何都会执行的回调函数，通常用于清理操作"
  },
  {
    "id": 740,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@Extend 装饰器的作用是？",
    "options": {
      "A": "扩展已有组件的功能",
      "B": "继承父组件的属性",
      "C": "实现组件的多态",
      "D": "创建组件的副本"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Extend 用于扩展已有组件，为其添加新的属性或方法，增强组件功能而无需修改原组件"
  },
  {
    "id": 741,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些情况会触发组件的 onUpdate () 方法？",
    "options": {
      "A": "父组件传递的属性值变化",
      "B": "组件内部状态变化",
      "C": "组件被重新渲染",
      "D": "组件从隐藏变为显示"
    },
    "answer": [
      "A"
    ],
    "explanation": "onUpdate () 仅在父组件传递给子组件的属性值发生变化时触发，用于处理属性更新逻辑"
  },
  {
    "id": 742,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 与 AppStorage 的主要区别是？",
    "options": {
      "A": "作用域不同，LocalStorage 是组件级，AppStorage 是应用级",
      "B": "存储介质不同，LocalStorage 是持久化，AppStorage 是内存",
      "C": "支持的数据类型不同",
      "D": "API 调用方式不同"
    },
    "answer": [
      "A"
    ],
    "explanation": "LocalStorage 和 AppStorage 的主要区别是作用域：LocalStorage 局限于组件及其子组件，AppStorage 是全应用可见"
  },
  {
    "id": 743,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "GridItem 组件的 colSpan 属性的作用是？",
    "options": {
      "A": "设置 GridItem 横跨的列数",
      "B": "设置 GridItem 的列索引",
      "C": "设置 GridItem 的列宽",
      "D": "设置 GridItem 的列间距"
    },
    "answer": [
      "A"
    ],
    "explanation": "colSpan 属性用于设置 GridItem 横跨的列数，如 colSpan=2 表示该 GridItem 占据 2 列的宽度"
  },
  {
    "id": 744,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些事件可以用于处理组件的滚动？",
    "options": {
      "A": "onScroll",
      "B": "onScrollStart",
      "C": "onScrollEnd",
      "D": "onScrolled"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "onScroll（滚动中）、onScrollStart（滚动开始）、onScrollEnd（滚动结束）用于处理组件的滚动事件"
  },
  {
    "id": 745,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示下拉菜单的组件是？",
    "options": {
      "A": "Menu",
      "B": "Dropdown",
      "C": "Select",
      "D": "PopupMenu"
    },
    "answer": [
      "A"
    ],
    "explanation": "Menu 组件用于实现下拉菜单功能，通常与 Button 等组件结合使用，点击时显示菜单选项"
  },
  {
    "id": 746,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式文件系统中，如何获取跨设备文件的 URI？",
    "options": {
      "A": "通过 fileUri.getDistributedUri () 方法",
      "B": "在本地 URI 前添加设备 ID 前缀",
      "C": "使用 distributedFileSystem.getUri () 方法",
      "D": "跨设备文件没有 URI，只能通过路径访问"
    },
    "answer": [
      "B"
    ],
    "explanation": " 分布式文件的 URI 格式为 'device://<deviceId>/<localPath>'，即在本地文件路径前添加设备 ID 前缀 "
  },
  {
    "id": 747,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由参数的传递方式？",
    "options": {
      "A": "通过 url 查询参数",
      "B": "通过 params 属性",
      "C": "通过 AppStorage",
      "D": "通过全局变量"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "路由参数可通过 url 查询参数、params 属性、AppStorage 和全局变量等多种方式传递"
  },
  {
    "id": 748,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的背景图片拉伸方式？",
    "options": {
      "A": ".backgroundImageSize (ImageSize.Contain)",
      "B": ".backgroundImageStretch (true)",
      "C": ".backgroundImageMode ('stretch')",
      "D": ".stretchBackgroundImage (ImageSize.Contain)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.backgroundImageSize () 方法设置背景图片的拉伸方式，参数为 ImageSize 枚举值（如 Contain、Cover 等）"
  },
  {
    "id": 749,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 find () 方法返回的是？",
    "options": {
      "A": "第一个满足条件的元素",
      "B": "所有满足条件的元素组成的数组",
      "C": "元素是否满足条件的布尔值",
      "D": "满足条件的元素的索引"
    },
    "answer": [
      "A"
    ],
    "explanation": "find () 方法返回数组中第一个满足测试函数的元素，若没有找到则返回 undefined"
  },
  {
    "id": 750,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的事件定义方式？",
    "options": {
      "A": "使用 ()=>void 类型声明事件属性",
      "B": "使用 @Event 装饰器",
      "C": "使用 EventEmitter",
      "D": "直接在组件内定义函数"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "自定义组件的事件可通过声明 ()=>void 类型的属性或使用 @Event 装饰器定义，用于子组件向父组件传递消息"
  },
  {
    "id": 751,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onDisappear () 与 onDestroy () 的区别是？",
    "options": {
      "A": "onDisappear () 组件仍存在，onDestroy () 组件被销毁",
      "B": "onDisappear () 在组件隐藏时调用，onDestroy () 在应用关闭时调用",
      "C": "onDisappear () 只用于页面组件，onDestroy () 用于所有组件",
      "D": "两者没有区别"
    },
    "answer": [
      "A"
    ],
    "explanation": "onDisappear () 在组件从界面消失时调用（组件仍存在于内存中），onDestroy () 在组件被销毁时调用（释放内存）"
  },
  {
    "id": 752,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的 flush () 方法的作用是？",
    "options": {
      "A": "将内存中的数据写入磁盘",
      "B": "清空存储的数据",
      "C": "读取磁盘中的数据到内存",
      "D": "同步数据到其他设备"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 的 flush () 方法用于将内存中的数据强制写入磁盘，确保数据持久化存储"
  },
  {
    "id": 753,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些属性可以用于控制组件的显示与隐藏？",
    "options": {
      "A": "visibility",
      "B": "display",
      "C": "opacity",
      "D": "hidden"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "visibility 控制组件是否可见（保留空间），display 控制组件是否显示（不保留空间）；opacity 设置透明度，hidden 不是 ArkTS 的属性"
  },
  {
    "id": 754,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种手势可以识别滑动的方向？",
    "options": {
      "A": "SwipeGesture",
      "B": "PanGesture",
      "C": "DragGesture",
      "D": "SlideGesture"
    },
    "answer": [
      "A"
    ],
    "explanation": "SwipeGesture（滑动手势）可以识别滑动的方向（上、下、左、右），常用于页面切换等场景"
  },
  {
    "id": 755,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示颜色选择器的组件是？",
    "options": {
      "A": "ColorPicker",
      "B": "ColorSelector",
      "C": "ColorChooser",
      "D": "ColorWheel"
    },
    "answer": [
      "A"
    ],
    "explanation": "ColorPicker 组件用于选择颜色，提供可视化的颜色选择界面，支持 RGB、HSV 等颜色模式"
  },
  {
    "id": 756,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式任务调度的约束条件？",
    "options": {
      "A": "设备类型",
      "B": "设备状态",
      "C": "网络质量",
      "D": "任务优先级"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式任务调度可根据设备类型、设备状态（如电量）、网络质量和任务优先级等约束条件分配任务"
  },
  {
    "id": 757,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.getLength () 方法的作用是？",
    "options": {
      "A": "获取路由栈的长度",
      "B": "获取当前页面的路径长度",
      "C": "获取路由参数的数量",
      "D": "获取路由历史记录的数量"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.getLength () 用于获取当前路由栈的长度，即已打开的页面数量"
  },
  {
    "id": 758,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的字体大小？",
    "options": {
      "A": ".fontSize (16)",
      "B": ".textSize (16)",
      "C": ".font ('size', 16)",
      "D": ".setTextSize (16)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.fontSize () 方法设置文本的字体大小，参数为像素值或字体大小枚举值"
  },
  {
    "id": 759,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现数组去重？",
    "options": {
      "A": "[...new Set (array)]",
      "B": "array.unique ()",
      "C": "array.distinct ()",
      "D": "Array.from (new Map (array.map (item => [item, item])).values ())"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Set（自动去重）结合扩展运算符是 ArkTS 中实现数组去重的简洁方式；ArkTS 数组没有 unique () 或 distinct () 方法"
  },
  {
    "id": 760,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何定义必填属性？",
    "options": {
      "A": "不添加问号（?）的属性",
      "B": "使用 required 关键字",
      "C": "在属性名前添加！",
      "D": "在属性描述中注明"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中，不添加问号（?）的属性默认为必填属性，父组件使用时必须传递该属性值"
  },
  {
    "id": 761,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数在组件首次渲染时会被调用？",
    "options": {
      "A": "onCreate ()",
      "B": "onAppear ()",
      "C": "onUpdate ()",
      "D": "onPageShow ()"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "组件首次渲染时会依次调用 onCreate ()（初始化）、onAppear ()（显示）、onPageShow ()（页面级显示）；onUpdate () 在属性更新时调用"
  },
  {
    "id": 762,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Prop 与 @Link 的主要区别是？",
    "options": {
      "A": "@Prop 是单向绑定，@Link 是双向绑定",
      "B": "@Prop 支持跨层级，@Link 只支持父子层级",
      "C": "@Prop 是应用级状态，@Link 是组件级状态",
      "D": "@Prop 是持久化状态，@Link 是内存状态"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Prop 实现父到子的单向绑定（子组件修改不影响父组件），@Link 实现父子组件的双向绑定（双方修改相互影响）"
  },
  {
    "id": 763,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "List 组件的 listDirection 属性的作用是？",
    "options": {
      "A": "设置列表的排列方向",
      "B": "设置列表的滚动方向",
      "C": "设置列表项的布局方向",
      "D": "设置列表的对齐方向"
    },
    "answer": [
      "A"
    ],
    "explanation": "listDirection 属性用于设置 List 组件的排列方向，可设置为 Vertical（垂直）或 Horizontal（水平）"
  },
  {
    "id": 764,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是长按手势的事件回调参数？",
    "options": {
      "A": "duration",
      "B": "x",
      "C": "y",
      "D": "timestamp"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "长按手势事件参数包含 duration（长按时间）、x/y（长按位置坐标）、timestamp（时间戳）等信息"
  },
  {
    "id": 765,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示图片的组件是？",
    "options": {
      "A": "Image",
      "B": "Picture",
      "C": "Img",
      "D": "Photo"
    },
    "answer": [
      "A"
    ],
    "explanation": "Image 组件用于显示图片，支持本地图片和网络图片，可设置缩放模式、边框等属性"
  },
  {
    "id": 766,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式服务的接口定义文件的扩展名是？",
    "options": {
      "A": ".idl",
      "B": ".service",
      "C": ".ds",
      "D": ".dist"
    },
    "answer": [
      "A"
    ],
    "explanation": "分布式服务的接口定义使用 IDL（接口定义语言），文件扩展名为.idl，用于定义跨设备调用的服务接口"
  },
  {
    "id": 767,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由动画的类型？",
    "options": {
      "A": "slide",
      "B": "fade",
      "C": "scale",
      "D": "rotate"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "路由动画支持 slide（滑动）、fade（淡入淡出）、scale（缩放）、rotate（旋转）等多种类型"
  },
  {
    "id": 768,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的投影效果？",
    "options": {
      "A": ".shadow ({ radius: 10, color: Color.Gray, offsetX: 5, offsetY: 5 })",
      "B": ".projection ({ radius: 10, color: 'gray' })",
      "C": ".dropShadow (10, 5, 5, 'gray')",
      "D": ".setShadow (10, 5, 5, Color.Gray)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.shadow () 方法设置组件的投影效果，参数包括模糊半径、颜色、水平偏移和垂直偏移"
  },
  {
    "id": 769,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，字符串的 includes () 方法返回的是？",
    "options": {
      "A": "布尔值，表示是否包含指定子串",
      "B": "指定子串的索引位置",
      "C": "包含指定子串的新字符串",
      "D": "指定子串的出现次数"
    },
    "answer": [
      "A"
    ],
    "explanation": "includes () 方法判断字符串是否包含指定的子串，返回 true 或 false"
  },
  {
    "id": 770,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的复用策略？",
    "options": {
      "A": "提取公共逻辑到工具类",
      "B": "使用 @Builder 封装 UI 片段",
      "C": "通过参数化配置实现多态",
      "D": "使用继承扩展组件功能"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "自定义组件的复用策略包括提取公共逻辑、@Builder 封装 UI、参数化配置；ArkTS 组件不支持继承扩展"
  },
  {
    "id": 771,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "应用从后台切换到前台时，页面组件会触发哪个生命周期函数？",
    "options": {
      "A": "onPageShow ()",
      "B": "onAppear ()",
      "C": "onResume ()",
      "D": "onForeground ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "应用从后台切换到前台时，当前显示的页面组件会触发 onPageShow () 生命周期函数"
  },
  {
    "id": 772,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "如何清除 AppStorage 中的某个状态？",
    "options": {
      "A": "AppStorage.Delete ('key')",
      "B": "AppStorage.remove ('key')",
      "C": "delete AppStorage ['key']",
      "D": "AppStorage.clear ('key')"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 AppStorage.Delete ('key') 方法清除 AppStorage 中指定键的状态"
  },
  {
    "id": 773,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置外边距（margin）？",
    "options": {
      "A": "Column",
      "B": "Row",
      "C": "Stack",
      "D": "所有组件都支持"
    },
    "answer": [
      "D"
    ],
    "explanation": "不仅布局容器，所有组件都支持通过 margin () 方法设置外边距，控制组件与其他组件的距离"
  },
  {
    "id": 774,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件用于处理组件的焦点变化？",
    "options": {
      "A": "onFocusChange",
      "B": "onFocus",
      "C": "onBlur",
      "D": "onFocusChangeEvent"
    },
    "answer": [
      "A"
    ],
    "explanation": "onFocusChange 事件在组件焦点状态变化时触发，通过事件参数可判断是获取焦点还是失去焦点"
  },
  {
    "id": 775,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示开关按钮的组件是？",
    "options": {
      "A": "Switch",
      "B": "Toggle",
      "C": "Checkbox",
      "D": "SwitchButton"
    },
    "answer": [
      "A"
    ],
    "explanation": "Switch 组件用于显示开关按钮，用户可通过点击切换开启 / 关闭状态，通常用于设置项"
  },
  {
    "id": 776,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式设备的连接状态？",
    "options": {
      "A": "online",
      "B": "offline",
      "C": "connecting",
      "D": "disconnecting"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "分布式设备的连接状态包括 online（在线）、offline（离线）、connecting（连接中），没有 disconnecting 状态"
  },
  {
    "id": 777,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.replaceUrl () 方法的动画默认值是？",
    "options": {
      "A": "无动画",
      "B": "滑动动画",
      "C": "淡入淡出动画",
      "D": "缩放动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.replaceUrl () 方法默认没有动画效果，需手动设置 animation 参数指定动画"
  },
  {
    "id": 778,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的粗细？",
    "options": {
      "A": ".fontWeight (FontWeight.Bold)",
      "B": ".fontWeight (700)",
      "C": ".textWeight ('bold')",
      "D": ".setFontWeight (FontWeight.Bold)"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "fontWeight () 方法可接受 FontWeight 枚举值（如 Bold）或数字（100-900）设置文本粗细"
  },
  {
    "id": 779,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确合并两个对象？",
    "options": {
      "A": "{ ...obj1, ...obj2 }",
      "B": "Object.merge (obj1, obj2)",
      "C": "obj1.concat (obj2)",
      "D": "Object.combine (obj1, obj2)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用扩展运算符（...）可以合并两个对象，后面对象的属性会覆盖前面的同名属性；ArkTS 没有 Object.merge () 等方法"
  },
  {
    "id": 780,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何为属性设置默认值？",
    "options": {
      "A": "使用等号（=）赋值",
      "B": "使用 default 关键字",
      "C": "在构造函数中设置",
      "D": "在 onCreate () 方法中设置"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中通过等号（=）为自定义组件的属性设置默认值，如 'count: number = 0'"
  },
  {
    "id": 781,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些情况会触发组件的 onCreate () 方法？",
    "options": {
      "A": "组件首次创建时",
      "B": "组件从隐藏变为显示时",
      "C": "组件被重新渲染时",
      "D": "应用重启后组件加载时"
    },
    "answer": [
      "A",
      "D"
    ],
    "explanation": "onCreate () 在组件首次创建和应用重启后组件加载时触发，组件隐藏后显示或重新渲染不会触发"
  },
  {
    "id": 782,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的 get () 方法如果获取不存在的键，会返回什么？",
    "options": {
      "A": "默认值",
      "B": "null",
      "C": "undefined",
      "D": "抛出异常"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 的 get () 方法接受第二个参数作为默认值，当键不存在时返回该默认值"
  },
  {
    "id": 783,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Flex 布局中，flexShrink 属性的作用是？",
    "options": {
      "A": "设置组件的收缩比例",
      "B": "设置组件的放大比例",
      "C": "设置组件的基准尺寸",
      "D": "设置组件的排列顺序"
    },
    "answer": [
      "A"
    ],
    "explanation": "flexShrink 用于设置当空间不足时，组件的收缩比例，决定组件缩小的程度"
  },
  {
    "id": 784,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是输入框的输入类型？",
    "options": {
      "A": "InputType.Number",
      "B": "InputType.Password",
      "C": "InputType.Email",
      "D": "InputType.Phone"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "输入框支持多种输入类型，包括数字（Number）、密码（Password）、邮箱（Email）、电话（Phone）等"
  },
  {
    "id": 785,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示复选框的组件是？",
    "options": {
      "A": "Checkbox",
      "B": "CheckButton",
      "C": "CheckBox",
      "D": "Checkable"
    },
    "answer": [
      "A"
    ],
    "explanation": "Checkbox 组件用于显示复选框，支持选中 / 未选中状态，通常用于多项选择场景"
  },
  {
    "id": 786,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式数据同步中，如何设置数据的同步范围？",
    "options": {
      "A": "通过 syncScope 参数设置",
      "B": "通过 deviceFilter 参数设置",
      "C": "通过 syncPolicy 参数设置",
      "D": "无法设置，默认同步所有设备"
    },
    "answer": [
      "B"
    ],
    "explanation": "分布式数据同步可通过 deviceFilter 参数设置设备过滤器，指定哪些设备参与数据同步"
  },
  {
    "id": 787,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些方法可以跳转到指定页面并关闭所有历史页面？",
    "options": {
      "A": "router.clear () + router.pushUrl ()",
      "B": "router.replaceUrl () + router.clear ()",
      "C": "router.pushUrl ({ url: 'page', params: { clearHistory: true } })",
      "D": "router.replaceUrl ({ url: 'page', params: { clearHistory: true } })"
    },
    "answer": [
      "A"
    ],
    "explanation": "先调用 router.clear () 清空路由栈，再调用 router.pushUrl () 跳转新页面，可实现关闭所有历史页面的效果"
  },
  {
    "id": 788,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的渐变方向为从左到右？",
    "options": {
      "A": ".backgroundGradient ({ type: GradientType.Linear, direction: GradientDirection.Left, colors: [...] })",
      "B": ".backgroundGradient ({ type: 'linear', direction: 'left', colors: [...] })",
      "C": ".linearGradient ({ from: 'left', to: 'right', colors: [...] })",
      "D": ".gradient ({ type: 'linear', angle: 0, colors: [...] })"
    },
    "answer": [
      "A"
    ],
    "explanation": "线性渐变通过 direction 参数设置方向，GradientDirection.Left 表示从左到右的渐变方向"
  },
  {
    "id": 789,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，数组的 some () 方法返回的是？",
    "options": {
      "A": "布尔值，表示是否至少有一个元素满足条件",
      "B": "第一个满足条件的元素",
      "C": "所有满足条件的元素组成的数组",
      "D": "满足条件的元素的数量"
    },
    "answer": [
      "A"
    ],
    "explanation": "some () 方法测试数组中是否至少有一个元素通过了测试函数，返回 true 或 false"
  },
  {
    "id": 790,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的属性校验方式？",
    "options": {
      "A": "类型校验",
      "B": "默认值校验",
      "C": "自定义函数校验",
      "D": "@Prop 装饰器校验"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "自定义组件的属性校验包括类型校验（声明属性类型）、默认值校验（设置默认值）和自定义函数校验（通过函数验证）"
  },
  {
    "id": 791,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onPageShow () 与 onAppear () 的区别是？",
    "options": {
      "A": "onPageShow () 是页面级，onAppear () 是组件级",
      "B": "onPageShow () 在页面显示时调用，onAppear () 在组件创建时调用",
      "C": "onPageShow () 只调用一次，onAppear () 可多次调用",
      "D": "两者没有区别"
    },
    "answer": [
      "A"
    ],
    "explanation": "onPageShow () 是页面级组件特有的生命周期，onAppear () 是所有组件共有的生命周期，均可在显示时调用多次"
  },
  {
    "id": 792,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "AppStorage 的最大存储容量是多少？",
    "options": {
      "A": "没有固定限制，取决于内存",
      "B": "1MB",
      "C": "5MB",
      "D": "10MB"
    },
    "answer": [
      "A"
    ],
    "explanation": "AppStorage 是内存中的状态存储，没有固定的容量限制，实际容量受设备内存大小限制"
  },
  {
    "id": 793,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持滚动？",
    "options": {
      "A": "Scroll",
      "B": "List",
      "C": "Grid",
      "D": "WaterFlow"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Scroll（通用滚动）、List（列表滚动）、Grid（网格滚动）、WaterFlow（瀑布流滚动）均支持滚动功能"
  },
  {
    "id": 794,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种手势可以识别拖动操作？",
    "options": {
      "A": "PanGesture",
      "B": "DragGesture",
      "C": "SwipeGesture",
      "D": "MoveGesture"
    },
    "answer": [
      "A"
    ],
    "explanation": "PanGesture（平移手势）用于识别拖动操作，可获取拖动的距离和方向，常用于拖拽组件"
  },
  {
    "id": 795,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示单选按钮的组件是？",
    "options": {
      "A": "Radio",
      "B": "RadioButton",
      "C": "SingleSelect",
      "D": "Option"
    },
    "answer": [
      "A"
    ],
    "explanation": "Radio 组件用于显示单选按钮，通常与 RadioGroup 配合使用，实现单项选择功能"
  },
  {
    "id": 796,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式任务的调度策略？",
    "options": {
      "A": "负载均衡",
      "B": "就近原则",
      "C": "设备能力优先",
      "D": "用户指定"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式任务调度支持负载均衡、就近原则、设备能力优先和用户指定等多种调度策略"
  },
  {
    "id": 797,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.back () 方法如果路由栈只有一个页面，会发生什么？",
    "options": {
      "A": "应用退出",
      "B": "无任何操作",
      "C": "抛出异常",
      "D": "返回首页"
    },
    "answer": [
      "A"
    ],
    "explanation": "当路由栈只有一个页面时，调用 router.back () 会导致应用退出"
  },
  {
    "id": 798,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的背景颜色？",
    "options": {
      "A": ".background (Color.Red)",
      "B": ".bgColor (Color.Red)",
      "C": ".backgroundColor (Color.Red)",
      "D": ".setBackground (Color.Red)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.background () 方法设置组件的背景颜色，参数为 Color 对象或颜色字符串"
  },
  {
    "id": 799,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现异步函数的串行执行？",
    "options": {
      "A": "使用 await 依次调用",
      "B": "使用 Promise.all ()",
      "C": "使用 Promise.race ()",
      "D": "直接并行调用"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 await 关键字依次调用异步函数，可以实现异步操作的串行执行（前一个完成后再执行下一个）"
  },
  {
    "id": 800,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何实现组件的递归调用？",
    "options": {
      "A": "在 build () 方法中条件调用自身",
      "B": "使用 recursive 关键字",
      "C": "通过 @Recursive 装饰器",
      "D": "ArkTS 不支持组件递归"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 支持自定义组件的递归调用，只需在 build () 方法中通过条件判断（如 if）递归引用自身即可，用于实现树形结构等"
  },
  {
    "id": 801,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现装饰器的参数化配置？",
    "options": {
      "A": "使用装饰器工厂函数",
      "B": "在装饰器内部读取元数据",
      "C": "使用 @Config 装饰器",
      "D": "TypeScript不支持参数化装饰器"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过装饰器工厂函数接收配置参数并返回装饰器函数：function configurable(value: boolean) { return function (target: any) { } }"
  },
  {
    "id": 802,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextPicker 的循环滚动配置？",
    "options": {
      "A": "canLoop",
      "B": "loop",
      "C": "cyclic",
      "D": "repeat"
    },
    "answer": [
      "A"
    ],
    "explanation": "TextPicker 支持 canLoop 属性配置是否开启循环滚动。"
  },
  {
    "id": 803,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的分形模式？",
    "options": {
      "A": "使用 @Fractal 装饰器",
      "B": "使用自相似的状态结构设计",
      "C": "使用 FractalState 类",
      "D": "ArkTS不支持分形模式"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过设计自相似的状态结构，使每个状态节点具有相同的操作接口，实现分形模式。"
  },
  {
    "id": 804,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的滑动选择器组件？",
    "options": {
      "A": "使用 @SliderPicker 装饰器",
      "B": "使用 @BuilderParam 接收选择器配置",
      "C": "使用 SliderPickerManager 类",
      "D": "ArkTS不支持滑动选择器"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收数值范围、步长等配置，实现可配置的滑动选择器组件。"
  },
  {
    "id": 805,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 List 的滚动事件？",
    "options": {
      "A": "onScroll",
      "B": "onScrollStart",
      "C": "onScrollStop",
      "D": "onScrollIndex"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "List 组件支持 onScroll（滚动中）、onScrollStart（滚动开始）、onScrollStop（滚动停止）等事件。"
  },
  {
    "id": 806,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建体积云动画？",
    "options": {
      "A": "使用 volumetricCloud()",
      "B": "使用噪声函数和光线步进算法",
      "C": "使用 CloudAnimation",
      "D": "ArkTS不支持体积云动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过噪声函数生成云密度场，使用光线步进算法渲染体积效果，创建逼真的云层动画。"
  },
  {
    "id": 807,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的拓扑发现？",
    "options": {
      "A": "使用 http.discover() 方法",
      "B": "通过服务注册中心发现可用节点",
      "C": "使用 TopologyDiscoverer 类",
      "D": "ArkTS不支持拓扑发现"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过服务注册中心动态发现可用的服务节点，实现请求的负载均衡和故障转移。"
  },
  {
    "id": 808,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据分片的重新平衡策略？",
    "options": {
      "A": "基于负载重新分配",
      "B": "基于容量重新分配",
      "C": "基于访问模式重新分配",
      "D": "基于一致性哈希重新分配"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据分片的重新平衡支持基于负载、容量、访问模式和一致性哈希等策略。"
  },
  {
    "id": 809,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的渐进式动画？",
    "options": {
      "A": "使用 Router.progressiveAnimation()",
      "B": "使用多个动画阶段组合",
      "C": "使用 @ProgressiveAnimation 装饰器",
      "D": "ArkTS不支持渐进式动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过将路由动画分解为多个阶段，逐步执行，创建更流畅的过渡效果。"
  },
  {
    "id": 810,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染预测优化？",
    "options": {
      "A": "使用 @RenderPredict 装饰器",
      "B": "基于用户行为预测渲染需求",
      "C": "使用 RenderPredictor 类",
      "D": "ArkTS不支持渲染预测"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过分析用户交互模式，预测下一步可能需要的组件并进行预渲染优化。"
  },
  {
    "id": 811,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归Required？",
    "options": {
      "A": "使用 DeepRequired<T>",
      "B": "使用递归映射类型移除可选修饰符",
      "C": "使用 @DeepRequired 装饰器",
      "D": "TypeScript不支持递归Required"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归映射类型实现深度Required：type DeepRequired<T> = { [P in keyof T]-?: DeepRequired<T[P]> }"
  },
  {
    "id": 812,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextInput 的输入事件？",
    "options": {
      "A": "onChange",
      "B": "onSubmit",
      "C": "onEditChange",
      "D": "onTextSelection"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "TextInput 支持 onChange（内容变化）和 onSubmit（提交）等输入事件。"
  },
  {
    "id": 813,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的因果一致性？",
    "options": {
      "A": "使用 @CausalConsistency 装饰器",
      "B": "使用向量时钟跟踪因果依赖",
      "C": "使用 CausalConsistency 类",
      "D": "ArkTS不支持因果一致性"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过向量时钟算法跟踪状态变更的因果依赖关系，确保因果一致性。"
  },
  {
    "id": 814,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的语音识别组件？",
    "options": {
      "A": "使用 @SpeechRecognition 装饰器",
      "B": "使用 @BuilderParam 接收识别配置",
      "C": "使用 SpeechRecognitionManager 类",
      "D": "ArkTS不支持语音识别"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收语言模型、识别参数等配置，实现可配置的语音识别组件。"
  },
  {
    "id": 815,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridRow 的断点配置属性？",
    "options": {
      "A": "breakpoints",
      "B": "direction",
      "C": "gutter",
      "D": "margin"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "GridRow 支持 breakpoints（断点）、direction（方向）、gutter（间隔）等断点配置属性。"
  },
  {
    "id": 816,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建弹跳进入动画？",
    "options": {
      "A": "使用 bounceIn() 方法",
      "B": "使用缩放和位移动画组合",
      "C": "使用 BounceInAnimation",
      "D": "ArkTS不支持弹跳进入动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过缩放从0到过度值再回弹，配合Y轴位移，创建弹跳进入效果。"
  },
  {
    "id": 817,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的故障注入测试？",
    "options": {
      "A": "使用 http.injectFault() 方法",
      "B": "模拟网络故障和服务异常",
      "C": "使用 FaultInjector 类",
      "D": "ArkTS不支持故障注入"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过模拟网络延迟、丢包和服务异常等故障，测试系统的容错能力。"
  },
  {
    "id": 818,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据缓存的淘汰策略？",
    "options": {
      "A": "LRU",
      "B": "LFU",
      "C": "FIFO",
      "D": "随机淘汰"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据缓存支持LRU（最近最少使用）、LFU（最不经常使用）、FIFO（先进先出）和随机淘汰等策略。"
  },
  {
    "id": 819,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问轨迹追踪？",
    "options": {
      "A": "使用 Router.track()",
      "B": "记录用户的完整导航路径",
      "C": "使用 @Track 装饰器",
      "D": "ArkTS不支持访问轨迹追踪"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过记录用户在应用中的完整导航路径，分析用户行为和使用模式。"
  },
  {
    "id": 820,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染优先级调度？",
    "options": {
      "A": "使用 @RenderPriority 装饰器",
      "B": "基于组件重要性分配渲染资源",
      "C": "使用 RenderScheduler 类",
      "D": "ArkTS不支持优先级调度"
    },
    "answer": [
      "B"
    ],
    "explanation": "根据组件在视图中的重要性和用户交互状态，动态分配渲染资源和执行顺序。"
  },
  {
    "id": 821,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现函数的记忆化缓存？",
    "options": {
      "A": "使用 memoize 库",
      "B": "使用闭包和Map缓存结果",
      "C": "使用 @Memoize 装饰器",
      "D": "TypeScript不支持记忆化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过闭包和Map数据结构缓存函数计算结果，避免重复计算：const memoize = (fn: Function) => { const cache = new Map(); return (...args: any[]) => { /* 缓存逻辑 */ } }"
  },
  {
    "id": 822,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextTimer 的控制器方法？",
    "options": {
      "A": "start",
      "B": "pause",
      "C": "reset",
      "D": "restart"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextTimer 的控制器支持 start（开始）、pause（暂停）、reset（重置）、restart（重新开始）等方法。"
  },
  {
    "id": 823,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的事务日志？",
    "options": {
      "A": "使用 @TransactionLog 装饰器",
      "B": "记录所有的状态变更操作",
      "C": "使用 TransactionLogger 类",
      "D": "ArkTS不支持事务日志"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过记录完整的状态变更操作序列，支持状态回滚、审计和重放功能。"
  },
  {
    "id": 824,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的指纹识别组件？",
    "options": {
      "A": "使用 @Fingerprint 装饰器",
      "B": "使用 @BuilderParam 接收生物识别配置",
      "C": "使用 FingerprintManager 类",
      "D": "ArkTS不支持指纹识别"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收生物识别参数和回调配置，实现可配置的指纹识别组件。"
  },
  {
    "id": 825,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Stack 的适应模式？",
    "options": {
      "A": "Fit",
      "B": "Stretch",
      "C": "AspectFit",
      "D": "AspectFill"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Stack 组件支持 Fit（适应）和 Stretch（拉伸）等适应模式。"
  },
  {
    "id": 826,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建体积雾动画？",
    "options": {
      "A": "使用 volumetricFog()",
      "B": "使用深度缓冲和雾效方程",
      "C": "使用 FogAnimation",
      "D": "ArkTS不支持体积雾动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过深度缓冲计算像素距离，应用雾效方程模拟大气透视效果，创建体积雾动画。"
  },
  {
    "id": 827,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的协议协商？",
    "options": {
      "A": "使用 http.negotiate() 方法",
      "B": "通过ALPN协议协商最佳协议",
      "C": "使用 ProtocolNegotiator 类",
      "D": "ArkTS不支持协议协商"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过ALPN（应用层协议协商）与服务器协商使用HTTP/2、HTTP/1.1等最佳协议。"
  },
  {
    "id": 828,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据复制的拓扑结构？",
    "options": {
      "A": "主从复制",
      "B": "多主复制",
      "C": "环形复制",
      "D": "星形复制"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据复制支持主从复制、多主复制、环形复制和星形复制等拓扑结构。"
  },
  {
    "id": 829,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问模式分析？",
    "options": {
      "A": "使用 Router.analyze()",
      "B": "分析用户的导航习惯和模式",
      "C": "使用 @Analyze 装饰器",
      "D": "ArkTS不支持访问模式分析"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过分析用户的导航路径和停留时间，识别使用习惯和优化导航结构。"
  },
  {
    "id": 830,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染时间切片？",
    "options": {
      "A": "使用 @TimeSlice 装饰器",
      "B": "将渲染任务分解为多个时间片",
      "C": "使用 TimeSlicer 类",
      "D": "ArkTS不支持时间切片"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过将复杂的渲染任务分解为多个时间片，避免长时间阻塞主线程，保证UI响应性。"
  },
  {
    "id": 831,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归Readonly数组？",
    "options": {
      "A": "使用 DeepReadonlyArray<T>",
      "B": "使用条件类型处理数组情况",
      "C": "使用 @DeepReadonlyArray 装饰器",
      "D": "TypeScript不支持递归Readonly数组"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过条件类型特殊处理数组情况：type DeepReadonly<T> = T extends Array<infer U> ? ReadonlyArray<DeepReadonly<U>> : { readonly [P in keyof T]: DeepReadonly<T[P]> }"
  },
  {
    "id": 832,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextArea 的选择功能属性？",
    "options": {
      "A": "copyOption",
      "B": "cutOption",
      "C": "pasteOption",
      "D": "selectAll"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextArea 支持 copyOption（复制）、cutOption（剪切）、pasteOption（粘贴）等选择功能属性。"
  },
  {
    "id": 833,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的向量时钟同步？",
    "options": {
      "A": "使用 @VectorClock 装饰器",
      "B": "使用向量时钟解决冲突和排序",
      "C": "使用 VectorClockSync 类",
      "D": "ArkTS不支持向量时钟"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过向量时钟算法为每个状态变更标记逻辑时间，解决分布式环境下的冲突和排序问题。"
  },
  {
    "id": 834,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的AR组件？",
    "options": {
      "A": "使用 @AR 装饰器",
      "B": "使用 @BuilderParam 接收AR配置",
      "C": "使用 ARManager 类",
      "D": "ArkTS不支持AR组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收AR场景、识别目标等配置，实现可配置的增强现实组件。"
  },
  {
    "id": 835,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Grid 的自动布局模式？",
    "options": {
      "A": "auto-fill",
      "B": "auto-fit",
      "C": "minmax",
      "D": "repeat"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "Grid 布局支持 auto-fill（自动填充）和 auto-fit（自动适应）等自动布局模式。"
  },
  {
    "id": 836,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建淡入淡出动画？",
    "options": {
      "A": "使用 fade() 方法",
      "B": "使用透明度的线性变化",
      "C": "使用 FadeAnimation",
      "D": "ArkTS不支持淡入淡出动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过线性改变组件的不透明度，从完全透明到完全不透明（淡入）或反之（淡出）。"
  },
  {
    "id": 837,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的零信任安全？",
    "options": {
      "A": "使用 http.zeroTrust() 方法",
      "B": "实施持续验证和最小权限原则",
      "C": "使用 ZeroTrust 类",
      "D": "ArkTS不支持零信任安全"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过持续验证请求身份、设备和环境，实施最小权限访问控制，实现零信任安全架构。"
  },
  {
    "id": 838,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据迁移的性能指标？",
    "options": {
      "A": "迁移速度",
      "B": "数据一致性",
      "C": "系统负载",
      "D": "迁移成功率"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据迁移需要监控迁移速度、数据一致性、系统负载和迁移成功率等性能指标。"
  },
  {
    "id": 839,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问频率分析？",
    "options": {
      "A": "使用 Router.frequency()",
      "B": "统计各路由的访问次数和模式",
      "C": "使用 @Frequency 装饰器",
      "D": "ArkTS不支持访问频率分析"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过统计各个路由的访问次数、时间和用户分布，分析热门路径和优化机会。"
  },
  {
    "id": 840,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染资源回收？",
    "options": {
      "A": "使用 @ResourceRecycle 装饰器",
      "B": "及时释放不再使用的渲染资源",
      "C": "使用 ResourceRecycler 类",
      "D": "ArkTS不支持资源回收"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过监控组件的生命周期，及时释放纹理、缓存等渲染资源，避免内存泄漏。"
  },
  {
    "id": 841,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现异步操作的超时控制？",
    "options": {
      "A": "使用 Promise.race() 和 setTimeout",
      "B": "使用 timeout 关键字",
      "C": "使用 @Timeout 装饰器",
      "D": "TypeScript不支持异步超时"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过 Promise.race() 竞速异步操作和setTimeout超时Promise，实现超时控制：Promise.race([asyncOp, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))])"
  },
  {
    "id": 842,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Web 组件的JavaScript交互方法？",
    "options": {
      "A": "runJavaScript",
      "B": "getHitTestResult",
      "C": "onConsole",
      "D": "onAlert"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Web 组件支持 runJavaScript（执行JS）、onConsole（控制台输出）、onAlert（弹窗）等交互方法。"
  },
  {
    "id": 843,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的CRDT算法？",
    "options": {
      "A": "使用 @CRDT 装饰器",
      "B": "使用无冲突复制数据类型",
      "C": "使用 CRDTManager 类",
      "D": "ArkTS不支持CRDT"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过CRDT（无冲突复制数据类型）算法，实现在无协调情况下状态的一致性收敛。"
  },
  {
    "id": 844,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的机器学习组件？",
    "options": {
      "A": "使用 @ML 装饰器",
      "B": "使用 @BuilderParam 接收模型配置",
      "C": "使用 MLManager 类",
      "D": "ArkTS不支持机器学习"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收机器学习模型、输入输出配置，实现可配置的AI组件。"
  },
  {
    "id": 845,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Flex 的基线对齐选项？",
    "options": {
      "A": "Baseline",
      "B": "FirstBaseline",
      "C": "LastBaseline",
      "D": "TextTop"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Flex 布局支持 Baseline（基线）、FirstBaseline（首行基线）、LastBaseline（末行基线）等对齐选项。"
  },
  {
    "id": 846,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建体积水动画？",
    "options": {
      "A": "使用 volumetricWater()",
      "B": "使用流体模拟和光线追踪",
      "C": "使用 WaterAnimation",
      "D": "ArkTS不支持体积水动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过流体动力学模拟水面波动，结合光线追踪计算折射反射，创建逼真的水体效果。"
  },
  {
    "id": 847,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的负载预测？",
    "options": {
      "A": "使用 http.predict() 方法",
      "B": "基于历史数据预测请求负载",
      "C": "使用 LoadPredictor 类",
      "D": "ArkTS不支持负载预测"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过分析历史请求模式和业务周期，预测未来的请求负载，优化资源分配。"
  },
  {
    "id": 848,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据备份的恢复策略？",
    "options": {
      "A": "全量恢复",
      "B": "增量恢复",
      "C": "时间点恢复",
      "D": "选择性恢复"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据备份支持全量恢复、增量恢复、时间点恢复和选择性恢复等策略。"
  },
  {
    "id": 849,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问权限动态更新？",
    "options": {
      "A": "使用 Router.updatePermissions()",
      "B": "根据用户权限变化更新路由守卫",
      "C": "使用 @DynamicPermission 装饰器",
      "D": "ArkTS不支持权限动态更新"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过监听用户权限变化，动态更新路由守卫逻辑，实现实时权限控制。"
  },
  {
    "id": 850,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染延迟加载？",
    "options": {
      "A": "使用 @LazyRender 装饰器",
      "B": "在组件进入视口时开始渲染",
      "C": "使用 LazyRenderer 类",
      "D": "ArkTS不支持延迟加载"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Intersection Observer API检测组件是否进入视口，延迟到需要显示时才开始渲染。"
  },
  {
    "id": 851,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归NonNullable？",
    "options": {
      "A": "使用 DeepNonNullable<T>",
      "B": "使用递归条件类型移除null和undefined",
      "C": "使用 @DeepNonNullable 装饰器",
      "D": "TypeScript不支持递归NonNullable"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归条件类型实现深度NonNullable：type DeepNonNullable<T> = T extends null | undefined ? never : { [P in keyof T]: DeepNonNullable<T[P]> }"
  },
  {
    "id": 852,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextClock 的本地化配置？",
    "options": {
      "A": "locale",
      "B": "format",
      "C": "timeZone",
      "D": "useSystemFormat"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "TextClock 支持 locale（区域设置）、format（格式）、timeZone（时区）等本地化配置。"
  },
  {
    "id": 853,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的事件驱动架构？",
    "options": {
      "A": "使用 @EventDriven 装饰器",
      "B": "使用事件总线和观察者模式",
      "C": "使用 EventDrivenState 类",
      "D": "ArkTS不支持事件驱动"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过事件总线发布状态变更事件，组件订阅感兴趣的事件，实现松耦合的事件驱动架构。"
  },
  {
    "id": 854,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的区块链组件？",
    "options": {
      "A": "使用 @Blockchain 装饰器",
      "B": "使用 @BuilderParam 接收链配置",
      "C": "使用 BlockchainManager 类",
      "D": "ArkTS不支持区块链组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收区块链网络、合约等配置，实现可配置的区块链交互组件。"
  },
  {
    "id": 855,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 WaterFlow 的性能优化属性？",
    "options": {
      "A": "cachedCount",
      "B": "editMode",
      "C": "layoutDirection",
      "D": "columnsTemplate"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "WaterFlow 组件的 cachedCount（缓存数量）和 editMode（编辑模式）可以用于性能优化。"
  },
  {
    "id": 856,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建缩放进入动画？",
    "options": {
      "A": "使用 scaleIn() 方法",
      "B": "使用缩放从0到1的动画",
      "C": "使用 ScaleInAnimation",
      "D": "ArkTS不支持缩放进入动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过缩放变换从0（不可见）到1（原始大小），创建元素从中心放大的进入效果。"
  },
  {
    "id": 857,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的混沌工程测试？",
    "options": {
      "A": "使用 http.chaos() 方法",
      "B": "模拟极端网络条件和故障",
      "C": "使用 ChaosEngine 类",
      "D": "ArkTS不支持混沌工程"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过模拟网络分区、高延迟、服务不可用等极端条件，测试系统的韧性和容错能力。"
  },
  {
    "id": 858,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据索引的维护时机？",
    "options": {
      "A": "数据插入时",
      "B": "数据更新时",
      "C": "数据删除时",
      "D": "定期维护"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据索引需要在数据插入、更新、删除时维护，也需要定期进行优化维护。"
  },
  {
    "id": 859,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问来源追踪？",
    "options": {
      "A": "使用 Router.trackSource()",
      "B": "记录用户进入路由的来源路径",
      "C": "使用 @TrackSource 装饰器",
      "D": "ArkTS不支持来源追踪"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过记录用户进入每个路由的前一个路径，分析导航流和用户行为路径。"
  },
  {
    "id": 860,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染并发优化？",
    "options": {
      "A": "使用 @ConcurrentRender 装饰器",
      "B": "使用Web Worker并行处理渲染任务",
      "C": "使用 ConcurrentRenderer 类",
      "D": "ArkTS不支持并发渲染"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Web Worker在多个线程中并行处理渲染计算，充分利用多核CPU性能。"
  },
  {
    "id": 861,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现Promise的错误传播？",
    "options": {
      "A": "使用 catch() 方法捕获错误",
      "B": "使用 throw 在链中传播错误",
      "C": "使用 @ErrorPropagate 装饰器",
      "D": "TypeScript不支持错误传播"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过Promise链中的catch()方法捕获和处理错误，或使用async/await的try-catch。"
  },
  {
    "id": 862,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextInput 的自动完成属性？",
    "options": {
      "A": "autoComplete",
      "B": "suggestions",
      "C": "autoCorrect",
      "D": "prediction"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "TextInput 支持 autoComplete（自动完成）和 suggestions（建议列表）等属性。"
  },
  {
    "id": 863,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的时间窗口聚合？",
    "options": {
      "A": "使用 @TimeWindow 装饰器",
      "B": "按时间窗口聚合状态变更",
      "C": "使用 TimeWindowAggregator 类",
      "D": "ArkTS不支持时间窗口聚合"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过按固定时间窗口聚合状态变更，减少状态同步频率和网络开销。"
  },
  {
    "id": 864,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的量子计算组件？",
    "options": {
      "A": "使用 @Quantum 装饰器",
      "B": "使用 @BuilderParam 接收量子电路配置",
      "C": "使用 QuantumManager 类",
      "D": "ArkTS不支持量子计算"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收量子比特数、门操作等配置，实现可配置的量子计算模拟组件。"
  },
  {
    "id": 865,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Column 的主轴尺寸属性？",
    "options": {
      "A": "width",
      "B": "height",
      "C": "minWidth",
      "D": "maxHeight"
    },
    "answer": [
      "B",
      "D"
    ],
    "explanation": "Column 组件的主轴是垂直方向，因此支持 height（高度）和 maxHeight（最大高度）等属性。"
  },
  {
    "id": 866,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建体积火动画？",
    "options": {
      "A": "使用 volumetricFire()",
      "B": "使用粒子系统和噪声纹理",
      "C": "使用 FireAnimation",
      "D": "ArkTS不支持体积火动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过粒子系统模拟火焰粒子，使用噪声纹理控制动态变化，创建逼真的火焰效果。"
  },
  {
    "id": 867,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的端到端加密？",
    "options": {
      "A": "使用 http.encrypt() 方法",
      "B": "使用TLS和客户端加密",
      "C": "使用 EndToEndEncryption 类",
      "D": "ArkTS不支持端到端加密"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过TLS传输层安全协议和客户端数据加密，实现从客户端到服务端的端到端数据保护。"
  },
  {
    "id": 868,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据同步的一致性模型？",
    "options": {
      "A": "强一致性",
      "B": "最终一致性",
      "C": "因果一致性",
      "D": "会话一致性"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据同步支持强一致性、最终一致性、因果一致性和会话一致性等模型。"
  },
  {
    "id": 869,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问热度分析？",
    "options": {
      "A": "使用 Router.heatmap()",
      "B": "分析各路由的访问频率和时长",
      "C": "使用 @Heatmap 装饰器",
      "D": "ArkTS不支持访问热度分析"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过统计路由的访问次数、停留时间和用户互动，生成访问热度分布图。"
  },
  {
    "id": 870,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染内存优化？",
    "options": {
      "A": "使用 @MemoryOptimize 装饰器",
      "B": "优化纹理和几何数据的内存使用",
      "C": "使用 MemoryOptimizer 类",
      "D": "ArkTS不支持内存优化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过压缩纹理、复用几何数据、及时释放资源等技术，优化渲染内存占用。"
  },
  {
    "id": 871,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归Pick？",
    "options": {
      "A": "使用 DeepPick<T, K>",
      "B": "使用递归条件类型和路径选择",
      "C": "使用 @DeepPick 装饰器",
      "D": "TypeScript不支持递归Pick"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归条件类型实现深度Pick：type DeepPick<T, K extends string> = K extends `${infer P}.${infer R}` ? { [Key in P]: DeepPick<T[Key], R> } : K extends keyof T ? T[K] : never"
  },
  {
    "id": 872,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 Image 的加载状态事件？",
    "options": {
      "A": "onComplete",
      "B": "onError",
      "C": "onProgress",
      "D": "onLoad"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Image 组件支持 onComplete（加载完成）、onError（加载错误）、onLoad（加载成功）等事件。"
  },
  {
    "id": 873,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的水印算法？",
    "options": {
      "A": "使用 @Watermark 装饰器",
      "B": "为状态变更添加逻辑时间戳",
      "C": "使用 WatermarkAlgorithm 类",
      "D": "ArkTS不支持水印算法"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过为状态变更添加逻辑时间戳（水印），支持基于事件时间的状态处理窗口。"
  },
  {
    "id": 874,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的脑机接口组件？",
    "options": {
      "A": "使用 @BCI 装饰器",
      "B": "使用 @BuilderParam 接收脑电信号配置",
      "C": "使用 BCIManager 类",
      "D": "ArkTS不支持脑机接口"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收信号处理、模式识别等配置，实现可配置的脑机接口组件。"
  },
  {
    "id": 875,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 GridRow 的响应式断点触发条件？",
    "options": {
      "A": "窗口宽度",
      "B": "设备方向",
      "C": "像素密度",
      "D": "系统主题"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "GridRow 的响应式断点主要基于窗口宽度和设备方向等条件触发。"
  },
  {
    "id": 876,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建滑动进入动画？",
    "options": {
      "A": "使用 slideIn() 方法",
      "B": "使用位移动画从屏幕外进入",
      "C": "使用 SlideInAnimation",
      "D": "ArkTS不支持滑动进入动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过位移动画将组件从屏幕左侧、右侧、顶部或底部滑动进入视口。"
  },
  {
    "id": 877,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的量子安全加密？",
    "options": {
      "A": "使用 http.quantumSafe() 方法",
      "B": "使用抗量子计算加密算法",
      "C": "使用 QuantumSafeEncryption 类",
      "D": "ArkTS不支持量子安全加密"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过使用格基加密、多变量加密等抗量子计算算法，保护数据免受未来量子计算机攻击。"
  },
  {
    "id": 878,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据验证的错误处理方式？",
    "options": {
      "A": "抛出异常",
      "B": "返回错误对象",
      "C": "记录日志",
      "D": "忽略错误"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "数据验证错误可以通过抛出异常、返回错误对象或记录日志等方式处理，不应忽略错误。"
  },
  {
    "id": 879,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问模式识别？",
    "options": {
      "A": "使用 Router.pattern()",
      "B": "使用机器学习识别用户导航模式",
      "C": "使用 @Pattern 装饰器",
      "D": "ArkTS不支持模式识别"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过机器学习算法分析用户导航数据，识别常见的访问模式和使用习惯。"
  },
  {
    "id": 880,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染流水线优化？",
    "options": {
      "A": "使用 @Pipeline 装饰器",
      "B": "优化渲染阶段的执行效率",
      "C": "使用 PipelineOptimizer 类",
      "D": "ArkTS不支持流水线优化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过分析渲染流水线的各个阶段（数据准备、布局、绘制等），针对性优化瓶颈阶段。"
  },
  {
    "id": 881,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "如何实现Generator的返回值？",
    "options": {
      "A": "使用 return 语句",
      "B": "使用 yield* 表达式",
      "C": "使用 @Return 装饰器",
      "D": "Generator不支持返回值"
    },
    "answer": [
      "A"
    ],
    "explanation": "在Generator函数中使用return语句指定返回值，通过迭代器的value属性获取。"
  },
  {
    "id": 882,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextTimer 的格式化占位符？",
    "options": {
      "A": "hh",
      "B": "mm",
      "C": "ss",
      "D": "SSS"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextTimer 支持 hh（时）、mm（分）、ss（秒）、SSS（毫秒）等格式化占位符。"
  },
  {
    "id": 883,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的Gossip协议？",
    "options": {
      "A": "使用 @Gossip 装饰器",
      "B": "使用流行病传播算法同步状态",
      "C": "使用 GossipProtocol 类",
      "D": "ArkTS不支持Gossip协议"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Gossip协议（流行病传播算法）在分布式节点间传播状态变更，实现最终一致性。"
  },
  {
    "id": 884,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的元宇宙组件？",
    "options": {
      "A": "使用 @Metaverse 装饰器",
      "B": "使用 @BuilderParam 接收虚拟世界配置",
      "C": "使用 MetaverseManager 类",
      "D": "ArkTS不支持元宇宙组件"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收3D场景、虚拟形象等配置，实现可配置的元宇宙体验组件。"
  },
  {
    "id": 885,
    "type": "multiple",
    "category": "布局",
    "difficulty": "中等",
    "question": "以下哪些是 Row 的主轴对齐方式？",
    "options": {
      "A": "Start",
      "B": "Center",
      "C": "End",
      "D": "SpaceBetween"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Row 组件支持 Start（起始）、Center（居中）、End（末尾）、SpaceBetween（两端对齐）等主轴对齐方式。"
  },
  {
    "id": 886,
    "type": "single",
    "category": "动画",
    "difficulty": "困难",
    "question": "如何创建体积烟雾动画？",
    "options": {
      "A": "使用 volumetricSmoke()",
      "B": "使用流体模拟和粒子系统",
      "C": "使用 SmokeAnimation",
      "D": "ArkTS不支持体积烟雾"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过流体动力学模拟烟雾运动，结合粒子系统渲染细节，创建逼真的体积烟雾效果。"
  },
  {
    "id": 887,
    "type": "single",
    "category": "网络请求",
    "difficulty": "中等",
    "question": "如何实现请求的意图识别？",
    "options": {
      "A": "使用 http.intent() 方法",
      "B": "基于请求模式识别用户意图",
      "C": "使用 IntentRecognizer 类",
      "D": "ArkTS不支持意图识别"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过分析请求参数、频率和上下文，识别用户的操作意图，优化服务响应。"
  },
  {
    "id": 888,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "困难",
    "question": "以下哪些是数据迁移的回滚策略？",
    "options": {
      "A": "全量回滚",
      "B": "增量回滚",
      "C": "时间点回滚",
      "D": "选择性回滚"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据迁移支持全量回滚、增量回滚、时间点回滚和选择性回滚等策略。"
  },
  {
    "id": 889,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问异常检测？",
    "options": {
      "A": "使用 Router.detectAnomaly()",
      "B": "监控异常的导航模式和频率",
      "C": "使用 @AnomalyDetection 装饰器",
      "D": "ArkTS不支持异常检测"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过监控异常的访问频率、路径序列和用户行为，检测潜在的安全威胁和系统异常。"
  },
  {
    "id": 890,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染预测缓存？",
    "options": {
      "A": "使用 @PredictiveCache 装饰器",
      "B": "预缓存可能需要的渲染结果",
      "C": "使用 PredictiveCacher 类",
      "D": "ArkTS不支持预测缓存"
    },
    "answer": [
      "B"
    ],
    "explanation": "基于用户行为预测，提前缓存可能需要的组件渲染结果，减少渲染延迟。"
  },
  {
    "id": 891,
    "type": "single",
    "category": "基础语法",
    "difficulty": "困难",
    "question": "如何实现类型的递归Omit？",
    "options": {
      "A": "使用 DeepOmit<T, K>",
      "B": "使用递归条件类型排除指定属性",
      "C": "使用 @DeepOmit 装饰器",
      "D": "TypeScript不支持递归Omit"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过递归条件类型实现深度Omit：type DeepOmit<T, K> = T extends object ? { [P in keyof T as P extends K ? never : P]: DeepOmit<T[P], K> } : T"
  },
  {
    "id": 892,
    "type": "multiple",
    "category": "UI开发",
    "difficulty": "中等",
    "question": "以下哪些是 TextArea 的键盘配置？",
    "options": {
      "A": "enterKeyType",
      "B": "textAlign",
      "C": "caretColor",
      "D": "maxLines"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "TextArea 支持 enterKeyType（回车键类型）和 caretColor（光标颜色）等键盘配置。"
  },
  {
    "id": 893,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何实现状态管理的Paxos算法？",
    "options": {
      "A": "使用 @Paxos 装饰器",
      "B": "使用分布式共识算法确定状态",
      "C": "使用 PaxosAlgorithm 类",
      "D": "ArkTS不支持Paxos算法"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过Paxos分布式共识算法，在多个节点间就状态值达成一致，保证强一致性。"
  },
  {
    "id": 894,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "如何创建可配置的神经形态计算组件？",
    "options": {
      "A": "使用 @Neuromorphic 装饰器",
      "B": "使用 @BuilderParam 接收脉冲神经网络配置",
      "C": "使用 NeuromorphicManager 类",
      "D": "ArkTS不支持神经形态计算"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过 @BuilderParam 接收神经元模型、连接权重等配置，实现可配置的神经形态计算组件。"
  },
  {
    "id": 895,
    "type": "multiple",
    "category": "布局",
    "difficulty": "困难",
    "question": "以下哪些是 Flex 的换行对齐属性？",
    "options": {
      "A": "alignContent",
      "B": "justifyContent",
      "C": "alignItems",
      "D": "flexWrap"
    },
    "answer": [
      "A"
    ],
    "explanation": "Flex 布局的 alignContent 属性用于控制多行flex容器中行的对齐方式。"
  },
  {
    "id": 896,
    "type": "single",
    "category": "动画",
    "difficulty": "中等",
    "question": "如何创建旋转退出动画？",
    "options": {
      "A": "使用 rotateOut() 方法",
      "B": "使用旋转和透明度动画组合",
      "C": "使用 RotateOutAnimation",
      "D": "ArkTS不支持旋转退出动画"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过旋转角度从当前值到目标值，配合透明度从1到0的变化，创建旋转退出效果。"
  },
  {
    "id": 897,
    "type": "single",
    "category": "网络请求",
    "difficulty": "困难",
    "question": "如何实现请求的联邦学习集成？",
    "options": {
      "A": "使用 http.federated() 方法",
      "B": "使用分布式机器学习训练模型",
      "C": "使用 FederatedLearning 类",
      "D": "ArkTS不支持联邦学习"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过在客户端本地训练模型，仅上传模型更新而非原始数据，实现隐私保护的分布式机器学习。"
  },
  {
    "id": 898,
    "type": "multiple",
    "category": "数据存储",
    "difficulty": "中等",
    "question": "以下哪些是数据压缩的评估指标？",
    "options": {
      "A": "压缩比",
      "B": "压缩速度",
      "C": "解压速度",
      "D": "CPU占用"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "数据压缩需要评估压缩比、压缩速度、解压速度和CPU占用等性能指标。"
  },
  {
    "id": 899,
    "type": "single",
    "category": "路由导航",
    "difficulty": "中等",
    "question": "如何实现路由的访问预测优化？",
    "options": {
      "A": "使用 Router.predict()",
      "B": "基于历史数据预测用户导航路径",
      "C": "使用 @Predict 装饰器",
      "D": "ArkTS不支持访问预测"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过分析用户历史导航数据，预测下一步可能访问的路由，进行预加载优化。"
  },
  {
    "id": 900,
    "type": "single",
    "category": "性能优化",
    "difficulty": "困难",
    "question": "如何实现组件的渲染自适应优化？",
    "options": {
      "A": "使用 @AdaptiveRender 装饰器",
      "B": "根据设备能力动态调整渲染质量",
      "C": "使用 AdaptiveRenderer 类",
      "D": "ArkTS不支持自适应优化"
    },
    "answer": [
      "B"
    ],
    "explanation": "通过检测设备性能、电量和网络条件，动态调整渲染分辨率、帧率和效果质量。"
  },
  {
    "id": 901,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确定义一个空数组？",
    "options": {
      "A": "const arr: number [] = []",
      "B": "const arr = new Array ()",
      "C": "const arr: Array<string> = [null]",
      "D": "const arr = {}"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中定义空数组的标准方式是使用 [] 并指定类型，如 number [] 表示数字数组；new Array () 虽能创建数组，但类型不明确；[null] 不是空数组；{} 是对象"
  },
  {
    "id": 902,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些方法可以实现组件的条件渲染？",
    "options": {
      "A": "使用 if-else 语句",
      "B": "使用三目运算符",
      "C": "使用 switch-case 语句",
      "D": "使用 visibility 属性"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "ArkTS 支持通过 if-else、三目运算符、switch-case 实现条件渲染；visibility 属性控制显示隐藏但仍占据布局空间，不属于条件渲染"
  },
  {
    "id": 903,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "@Provide 与 @Consume 的作用范围是？",
    "options": {
      "A": "跨任意层级的组件",
      "B": "仅父子组件",
      "C": "仅兄弟组件",
      "D": "全应用范围"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Provide 与 @Consume 实现跨层级的状态共享，无论组件层级深度如何，只要在同一组件树中即可共享状态"
  },
  {
    "id": 904,
    "type": "single",
    "category": "布局设计",
    "difficulty": "简单",
    "question": "以下哪种布局适合实现水平或垂直排列的线性布局？",
    "options": {
      "A": "Row/Column",
      "B": "Stack",
      "C": "Grid",
      "D": "RelativeContainer"
    },
    "answer": [
      "A"
    ],
    "explanation": "Row 用于水平排列组件，Column 用于垂直排列组件，是实现线性布局的基础组件"
  },
  {
    "id": 905,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是触摸事件的类型？",
    "options": {
      "A": "onTouchStart",
      "B": "onTouchMove",
      "C": "onTouchEnd",
      "D": "onTouchCancel"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "触摸事件包括 onTouchStart（触摸开始）、onTouchMove（触摸移动）、onTouchEnd（触摸结束）、onTouchCancel（触摸中断）四种类型"
  },
  {
    "id": 906,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示进度条的组件是？",
    "options": {
      "A": "Progress",
      "B": "Slider",
      "C": "ProgressBar",
      "D": "ProgressIndicator"
    },
    "answer": [
      "A"
    ],
    "explanation": "Progress 组件用于显示操作的进度，支持线性进度条和环形进度条，可设置进度值和样式"
  },
  {
    "id": 907,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "鸿蒙分布式服务框架的核心协议是？",
    "options": {
      "A": "DDSP（Distributed Data Sharing Protocol）",
      "B": "HDSP（Harmony Distributed Service Protocol）",
      "C": "DMS（Distributed Management Service）",
      "D": "HDFS（Harmony Distributed File System）"
    },
    "answer": [
      "A"
    ],
    "explanation": "DDSP（分布式数据共享协议）是鸿蒙分布式服务框架的核心协议，用于实现跨设备的数据共享和服务调用"
  },
  {
    "id": 908,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些方法可以获取路由参数？",
    "options": {
      "A": "router.getParams ()",
      "B": "\\(route.params",
      "C": "router.getState().params",
      "D": "this.routeParams"
    },
    "answer": [
      "B",
      "C"
    ],
    "explanation": "获取路由参数的方式包括：通过\\)route.params 直接访问，或通过 router.getState ().params 获取；router.getParams () 和 this.routeParams 不是标准 API"
  },
  {
    "id": 909,
    "type": "single",
    "category": "样式设置",
    "difficulty": "简单",
    "question": "如何设置组件的宽度为父容器的 50%？",
    "options": {
      "A": ".width ('50%')",
      "B": ".width (0.5)",
      "C": ".width ('half')",
      "D": ".width ({ percent: 50 })"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.width ('50%') 设置组件宽度为父容器的 50%，百分比字符串是设置相对宽度的标准方式"
  },
  {
    "id": 910,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现数组的映射转换？",
    "options": {
      "A": "array.map (item => item * 2)",
      "B": "array.convert (item => item * 2)",
      "C": "array.transform (item => item * 2)",
      "D": "array.change (item => item * 2)"
    },
    "answer": [
      "A"
    ],
    "explanation": "map () 方法用于对数组中的每个元素执行回调函数，并返回新的转换后数组，是 ArkTS 中数组映射的标准方法"
  },
  {
    "id": 911,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "组件从 DOM 树中移除时会触发哪个生命周期函数？",
    "options": {
      "A": "onDestroy ()",
      "B": "onDisappear ()",
      "C": "onRemove ()",
      "D": "onDelete ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "onDestroy () 在组件从 DOM 树中移除并销毁时触发，用于释放资源和清理操作"
  },
  {
    "id": 912,
    "type": "multiple",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "以下哪些状态装饰器支持状态变化通知？",
    "options": {
      "A": "@State",
      "B": "@Prop",
      "C": "@Link",
      "D": "@StorageProp"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "@State、@Prop、@Link、@StorageProp 均为状态装饰器，当状态变化时会通知组件重新渲染"
  },
  {
    "id": 913,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Stack 布局中，子组件的默认对齐方式是？",
    "options": {
      "A": "左上角对齐",
      "B": "居中对齐",
      "C": "右下角对齐",
      "D": "拉伸填充"
    },
    "answer": [
      "A"
    ],
    "explanation": "Stack 布局中，子组件默认左上角对齐，可通过 alignContent 属性修改对齐方式"
  },
  {
    "id": 914,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "双击手势（DoubleClick）的默认触发时间间隔是多少？",
    "options": {
      "A": "300ms",
      "B": "500ms",
      "C": "1000ms",
      "D": "自定义，无默认值"
    },
    "answer": [
      "B"
    ],
    "explanation": "双击手势默认在 500ms 内连续点击两次触发，可通过 interval 参数自定义时间间隔"
  },
  {
    "id": 915,
    "type": "multiple",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "以下哪些组件支持输入功能？",
    "options": {
      "A": "TextInput",
      "B": "TextArea",
      "C": "Search",
      "D": "Picker"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "TextInput（单行输入）、TextArea（多行输入）、Search（搜索输入）、Picker（选择输入）均支持用户输入功能"
  },
  {
    "id": 916,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式设备的认证级别不包括以下哪项？",
    "options": {
      "A": "设备级认证",
      "B": "用户级认证",
      "C": "应用级认证",
      "D": "数据级认证"
    },
    "answer": [
      "D"
    ],
    "explanation": "分布式设备认证包括设备级、用户级和应用级认证，没有数据级认证这一分类"
  },
  {
    "id": 917,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "如何设置路由的默认页面？",
    "options": {
      "A": "在 main_pages.json 中设置第一个页面",
      "B": "在 app.json 中配置 defaultRoute",
      "C": "使用 router.setDefaultUrl () 方法",
      "D": "在 EntryAbility 中指定"
    },
    "answer": [
      "A"
    ],
    "explanation": "路由的默认页面是 main_pages.json 配置文件中列出的第一个页面，应用启动时默认加载该页面"
  },
  {
    "id": 918,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的对齐方式？",
    "options": {
      "A": ".textAlign (TextAlign.Center)",
      "B": ".align (Alignment.Center)",
      "C": ".textAlignment (TextAlign.Right)",
      "D": ".setAlignment (TextAlign.Left)"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "文本对齐可通过.textAlign () 直接设置，或通过.align () 设置组件的对齐方式影响文本；其他选项不是标准 API"
  },
  {
    "id": 919,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确判断变量是否为 null 或 undefined？",
    "options": {
      "A": "if (value == null)",
      "B": "if (value === null || value === undefined)",
      "C": "if (isNull (value))",
      "D": "if (isEmpty (value))"
    },
    "answer": [
      "B"
    ],
    "explanation": "使用严格相等运算符（===）分别判断 null 和 undefined 是最准确的方式；== 会进行类型转换，可能导致误判；ArkTS 没有 isNull () 或 isEmpty () 全局函数"
  },
  {
    "id": 920,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@Builder 装饰器的作用是？",
    "options": {
      "A": "封装可复用的 UI 片段",
      "B": "定义组件的构造函数",
      "C": "实现组件的异步加载",
      "D": "优化组件的渲染性能"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Builder 用于定义可复用的 UI 片段（构建函数），可以在组件的 build () 方法中多次调用，提高代码复用性"
  },
  {
    "id": 921,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数在组件被销毁时会被调用？",
    "options": {
      "A": "onDestroy ()",
      "B": "onDisappear ()",
      "C": "onPageHide ()",
      "D": "onFinalize ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "组件被销毁时会先触发 onDisappear ()（消失），再触发 onDestroy ()（销毁）；onPageHide () 用于页面隐藏，onFinalize () 不存在"
  },
  {
    "id": 922,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的 delete () 方法的作用是？",
    "options": {
      "A": "删除指定键的数据",
      "B": "清空所有数据",
      "C": "删除 Preferences 文件",
      "D": "取消上次修改"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 的 delete () 方法用于删除指定键的数据，清空所有数据使用 clear () 方法"
  },
  {
    "id": 923,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Grid 布局中，columnsTemplate 属性的作用是？",
    "options": {
      "A": "定义列的数量和宽度比例",
      "B": "定义列的间距",
      "C": "定义列的对齐方式",
      "D": "定义列的最大宽度"
    },
    "answer": [
      "A"
    ],
    "explanation": "columnsTemplate 用于定义 Grid 的列结构，如 '1fr 1fr 1fr' 表示 3 列，每列宽度相等"
  },
  {
    "id": 924,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "困难",
    "question": "以下哪些是手势事件的传播阶段？",
    "options": {
      "A": "捕获阶段",
      "B": "目标阶段",
      "C": "冒泡阶段",
      "D": "处理阶段"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "手势事件传播分为三个阶段：捕获阶段（从父到子）、目标阶段（到达目标组件）、冒泡阶段（从子到父）"
  },
  {
    "id": 925,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示标签页的组件是？",
    "options": {
      "A": "Tabs",
      "B": "TabView",
      "C": "TabBar",
      "D": "PageIndicator"
    },
    "answer": [
      "A"
    ],
    "explanation": "Tabs 组件用于实现标签页切换功能，包含 TabContent 子组件和可选的 TabBar 导航栏"
  },
  {
    "id": 926,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式数据对象的同步优先级不包括以下哪项？",
    "options": {
      "A": "High",
      "B": "Medium",
      "C": "Low",
      "D": "Immediate"
    },
    "answer": [
      "D"
    ],
    "explanation": "分布式数据对象的同步优先级包括 High（高）、Medium（中）、Low（低），没有 Immediate 优先级"
  },
  {
    "id": 927,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些情况会导致路由栈长度增加？",
    "options": {
      "A": "调用 router.pushUrl ()",
      "B": "调用 router.replaceUrl ()",
      "C": "从子页面返回父页面",
      "D": "应用首次启动"
    },
    "answer": [
      "A",
      "D"
    ],
    "explanation": "router.pushUrl () 会添加新页面到路由栈；应用首次启动会创建初始页面，栈长度从 0 变为 1；replaceUrl 不改变栈长度；返回会减少栈长度"
  },
  {
    "id": 928,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的边框为虚线？",
    "options": {
      "A": ".borderStyle (BorderStyle.Dashed)",
      "B": ".border ({ style: 'dashed' })",
      "C": ".dashedBorder (true)",
      "D": ".borderDash ([5, 3])"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.borderStyle () 方法设置边框样式，BorderStyle.Dashed 表示虚线边框；其他选项不是标准 API"
  },
  {
    "id": 929,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现对象的深拷贝？",
    "options": {
      "A": "JSON.parse (JSON.stringify (obj))",
      "B": "{ ...obj }",
      "C": "Object.assign ({}, obj)",
      "D": "obj.copy ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 JSON 序列化与反序列化是实现对象深拷贝的常用方式；扩展运算符和 Object.assign () 仅实现浅拷贝；ArkTS 对象没有 copy () 方法"
  },
  {
    "id": 930,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的属性类型？",
    "options": {
      "A": "基本数据类型（number、string 等）",
      "B": "对象类型",
      "C": "函数类型",
      "D": "组件类型"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "自定义组件的属性支持基本数据类型、对象类型、函数类型（事件回调）和组件类型（子组件）"
  },
  {
    "id": 931,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onAppear () 生命周期函数在什么时候调用？",
    "options": {
      "A": "组件显示在界面上时",
      "B": "组件被创建时",
      "C": "组件属性更新时",
      "D": "应用启动时"
    },
    "answer": [
      "A"
    ],
    "explanation": "onAppear () 在组件显示在界面上时调用，包括首次显示和从隐藏状态变为显示状态"
  },
  {
    "id": 932,
    "type": "single",
    "category": "状态管理",
    "difficulty": "困难",
    "question": "如何在非组件类中访问 AppStorage 中的状态？",
    "options": {
      "A": "通过 AppStorage.Get () 方法",
      "B": "使用 @StorageProp 装饰器",
      "C": "使用 @StorageLink 装饰器",
      "D": "非组件类无法访问 AppStorage"
    },
    "answer": [
      "A"
    ],
    "explanation": "非组件类可通过 AppStorage.Get ('key') 方法获取状态，通过 AppStorage.Set ('key', value) 修改状态；装饰器仅用于组件类"
  },
  {
    "id": 933,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置滚动方向？",
    "options": {
      "A": "Scroll",
      "B": "List",
      "C": "Grid",
      "D": "WaterFlow"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Scroll（scrollDirection）、List（listDirection）、Grid（scrollDirection）、WaterFlow（scrollDirection）均支持设置滚动方向"
  },
  {
    "id": 934,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件用于处理键盘输入？",
    "options": {
      "A": "onKeyEvent",
      "B": "onKeyboard",
      "C": "onInput",
      "D": "onKeyPress"
    },
    "answer": [
      "A"
    ],
    "explanation": "onKeyEvent 用于处理键盘事件，可获取按键类型、按键码等信息；onInput 用于输入框内容变化"
  },
  {
    "id": 935,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示加载状态的组件是？",
    "options": {
      "A": "LoadingProgress",
      "B": "Spinner",
      "C": "Loading",
      "D": "Indicator"
    },
    "answer": [
      "B"
    ],
    "explanation": "Spinner 组件用于显示加载状态，提供多种动画样式，通常在数据加载时使用"
  },
  {
    "id": 936,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式文件系统的操作？",
    "options": {
      "A": "文件创建",
      "B": "文件读取",
      "C": "文件复制",
      "D": "文件权限管理"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式文件系统支持文件创建、读取、复制、权限管理等基本文件操作，与本地文件系统操作类似"
  },
  {
    "id": 937,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.getState () 方法返回的对象不包含以下哪项？",
    "options": {
      "A": "currentUrl",
      "B": "params",
      "C": "history",
      "D": "length"
    },
    "answer": [
      "C"
    ],
    "explanation": "router.getState () 返回的状态对象包含 currentUrl（当前页面）、params（参数）、length（栈长度），不包含 history（历史记录）"
  },
  {
    "id": 938,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的字体样式？",
    "options": {
      "A": ".fontStyle (FontStyle.Italic)",
      "B": ".font ({ style: FontStyle.Italic })",
      "C": ".textStyle ('italic')",
      "D": ".setFontStyle (FontStyle.Normal)"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "可通过.fontStyle () 直接设置或.font () 传入样式对象设置文本字体样式（正常 / 斜体）；其他选项不是标准 API"
  },
  {
    "id": 939,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现数组的过滤？",
    "options": {
      "A": "array.filter (item => item > 0)",
      "B": "array.select (item => item > 0)",
      "C": "array.find (item => item > 0)",
      "D": "array.search (item => item > 0)"
    },
    "answer": [
      "A"
    ],
    "explanation": "filter () 方法用于过滤数组，返回所有满足条件的元素组成的新数组；find () 只返回第一个满足条件的元素"
  },
  {
    "id": 940,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@BuilderParam 装饰器的作用是？",
    "options": {
      "A": "传递 UI 片段作为参数",
      "B": "定义组件的构造参数",
      "C": "标记必选参数",
      "D": "优化参数传递性能"
    },
    "answer": [
      "A"
    ],
    "explanation": "@BuilderParam 用于将 @Builder 定义的 UI 片段作为参数传递给子组件，实现组件 UI 内容的定制化"
  },
  {
    "id": 941,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些情况会触发组件的 onAppear () 方法？",
    "options": {
      "A": "组件首次渲染显示",
      "B": "组件从隐藏状态变为显示状态",
      "C": "组件属性更新后重新渲染",
      "D": "应用从后台切换到前台"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "onAppear () 在组件显示时触发，包括首次显示、从隐藏变为显示、应用从后台切换到前台导致组件重新显示"
  },
  {
    "id": 942,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 的 create () 方法的作用是？",
    "options": {
      "A": "创建新的 LocalStorage 实例",
      "B": "创建新的存储键值对",
      "C": "创建持久化存储文件",
      "D": "创建与 AppStorage 的绑定关系"
    },
    "answer": [
      "A"
    ],
    "explanation": "LocalStorage.create () 用于创建新的 LocalStorage 实例，可用于组件树内的状态共享"
  },
  {
    "id": 943,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "RelativeContainer 中，如何设置组件 A 在组件 B 的右侧？",
    "options": {
      "A": "A 的 alignRules 设置 { left: { anchor: 'B', align: HorizontalAlign.End } }",
      "B": "A 的 alignRules 设置 { right: { anchor: 'B', align: HorizontalAlign.Start } }",
      "C": "B 的 alignRules 设置 { right: { anchor: 'A', align: HorizontalAlign.Start } }",
      "D": "A 的 alignRules 设置 { left: { anchor: 'B', align: HorizontalAlign.Start } }"
    },
    "answer": [
      "A"
    ],
    "explanation": "要使 A 在 B 右侧，需设置 A 的左边缘与 B 的右边缘对齐，即 A 的 left 锚定 B 的 HorizontalAlign.End（右边缘）"
  },
  {
    "id": 944,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是捏合手势（PinchGesture）的事件参数？",
    "options": {
      "A": "scale",
      "B": "angle",
      "C": "centerX",
      "D": "centerY"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "捏合手势参数包括 scale（缩放比例）、centerX/centerY（中心点坐标）；angle 是旋转手势的参数"
  },
  {
    "id": 945,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示底部导航栏的组件是？",
    "options": {
      "A": "TabContent",
      "B": "Navigation",
      "C": "BottomTabBar",
      "D": "TabBar"
    },
    "answer": [
      "D"
    ],
    "explanation": "TabBar 组件可用于实现底部导航栏，通常与 Tabs 组件配合使用，提供页面切换功能"
  },
  {
    "id": 946,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式服务的发现模式不包括以下哪项？",
    "options": {
      "A": "主动发现",
      "B": "被动发现",
      "C": "广播发现",
      "D": "定向发现"
    },
    "answer": [
      "C"
    ],
    "explanation": "分布式服务的发现模式包括主动发现（主动搜索）、被动发现（等待被发现）、定向发现（指定设备），没有广播发现模式"
  },
  {
    "id": 947,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些方法可以关闭当前页面？",
    "options": {
      "A": "router.back ()",
      "B": "router.pop ()",
      "C": "router.close ()",
      "D": "router.exit ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "router.back () 和 router.pop () 均用于关闭当前页面并返回上一页；router.close () 和 router.exit () 不是标准 API"
  },
  {
    "id": 948,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的透明度为 50%？",
    "options": {
      "A": ".opacity (0.5)",
      "B": ".alpha (50%)",
      "C": ".transparent (0.5)",
      "D": ".setOpacity (50)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.opacity () 方法设置组件透明度，参数为 0-1 之间的数值，0.5 表示 50% 透明度"
  },
  {
    "id": 949,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确获取数组的长度？",
    "options": {
      "A": "array.length",
      "B": "array.size ()",
      "C": "array.getLength ()",
      "D": "length (array)"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中通过数组的 length 属性获取数组长度，这是标准的 ECMAScript 规范"
  },
  {
    "id": 950,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的样式设置方式？",
    "options": {
      "A": "通过链式方法（如.width ()）",
      "B": "通过 @Styles 装饰器",
      "C": "通过 CSS 文件",
      "D": "通过 style 属性"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "ArkTS 自定义组件通过链式方法和 @Styles 装饰器设置样式；不支持 CSS 文件，也没有 style 属性"
  },
  {
    "id": 951,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onPageHide () 与 onDisappear () 的执行顺序是？",
    "options": {
      "A": "onPageHide () 先执行，onDisappear () 后执行",
      "B": "onDisappear () 先执行，onPageHide () 后执行",
      "C": "同时执行",
      "D": "没有固定顺序"
    },
    "answer": [
      "A"
    ],
    "explanation": "页面隐藏时，先执行页面级的 onPageHide ()，再执行组件级的 onDisappear ()"
  },
  {
    "id": 952,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的 getAll () 方法返回的是什么？",
    "options": {
      "A": "所有键值对组成的对象",
      "B": "所有键组成的数组",
      "C": "所有值组成的数组",
      "D": "存储的条目数量"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 的 getAll () 方法返回一个包含所有键值对的对象，可用于遍历所有存储的数据"
  },
  {
    "id": 953,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置子组件间距？",
    "options": {
      "A": "Row",
      "B": "Column",
      "C": "Grid",
      "D": "List"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Row/Column（spacing）、Grid（rowSpacing/columnSpacing）、List（space）均支持设置子组件间距"
  },
  {
    "id": 954,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件用于处理组件的尺寸变化？",
    "options": {
      "A": "onSizeChange",
      "B": "onResize",
      "C": "onDimensionChange",
      "D": "onLayoutChange"
    },
    "answer": [
      "A"
    ],
    "explanation": "onSizeChange 事件在组件尺寸发生变化时触发，可获取组件的新宽度和高度"
  },
  {
    "id": 955,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示提示消息的组件是？",
    "options": {
      "A": "Toast",
      "B": "Message",
      "C": "Tip",
      "D": "Alert"
    },
    "answer": [
      "A"
    ],
    "explanation": "Toast 组件用于显示短暂的提示消息，通常在一段时间后自动消失，不阻断用户操作"
  },
  {
    "id": 956,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式任务的执行结果状态？",
    "options": {
      "A": "SUCCESS",
      "B": "FAILURE",
      "C": "TIMEOUT",
      "D": "CANCELLED"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式任务执行结果状态包括成功（SUCCESS）、失败（FAILURE）、超时（TIMEOUT）、已取消（CANCELLED）"
  },
  {
    "id": 957,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.clear () 方法的作用是？",
    "options": {
      "A": "清空路由栈",
      "B": "清除当前页面的参数",
      "C": "清除路由历史记录",
      "D": "重置路由配置"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.clear () 用于清空路由栈中的所有页面，通常与 router.pushUrl () 配合使用，实现跳转到新页面并清除历史"
  },
  {
    "id": 958,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的背景图片？",
    "options": {
      "A": ".backgroundImage (\\(r('app.media.bg'))",
      "B": ".backgroundImage('https://example.com/bg.png')",
      "C": ".imageBackground(\\)r('app.media.bg'))",
      "D": ".setBackgroundImage(\\(r('app.media.bg'))"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "使用.backgroundImage()方法设置背景图片，支持本地资源（\\)r）和网络图片 URL；其他选项不是标准 API"
  },
  {
    "id": 959,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现数组的排序？",
    "options": {
      "A": "array.sort ((a, b) => a - b)",
      "B": "array.orderBy ((a, b) => a - b)",
      "C": "array.arrange ((a, b) => a - b)",
      "D": "sorted (array, (a, b) => a - b)"
    },
    "answer": [
      "A"
    ],
    "explanation": "sort () 方法用于对数组进行排序，接受比较函数作为参数；其他选项不是 ArkTS 的数组排序方法"
  },
  {
    "id": 960,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "@Extend 与 @Styles 的主要区别是？",
    "options": {
      "A": "@Extend 用于扩展组件，@Styles 用于定义样式片段",
      "B": "@Extend 支持参数，@Styles 不支持",
      "C": "@Extend 是全局的，@Styles 是局部的",
      "D": "@Extend 用于组件，@Styles 用于页面"
    },
    "answer": [
      "A"
    ],
    "explanation": "@Extend 用于扩展特定组件，为其添加新的样式方法；@Styles 用于定义可复用的样式片段，可应用于多个组件"
  },
  {
    "id": 961,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数在应用退出时会被调用？",
    "options": {
      "A": "onDestroy ()",
      "B": "onDisappear ()",
      "C": "onPageHide ()",
      "D": "onExit ()"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "应用退出时，当前页面组件会依次触发 onPageHide ()、onDisappear ()、onDestroy () 生命周期函数；onExit () 不存在"
  },
  {
    "id": 962,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "AppStorage 与 LocalStorage 的同步方式是？",
    "options": {
      "A": "通过 link 方法建立单向同步",
      "B": "自动双向同步",
      "C": "需要手动同步",
      "D": "无法同步"
    },
    "answer": [
      "A"
    ],
    "explanation": "可通过 LocalStorage.link ('key') 方法将 LocalStorage 的状态与 AppStorage 同步，建立从 AppStorage 到 LocalStorage 的单向同步"
  },
  {
    "id": 963,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Flex 布局中，justifyContent 属性的作用是？",
    "options": {
      "A": "设置主轴方向上的对齐方式",
      "B": "设置交叉轴方向上的对齐方式",
      "C": "设置子组件的换行方式",
      "D": "设置子组件的排列顺序"
    },
    "answer": [
      "A"
    ],
    "explanation": "justifyContent 用于设置 Flex 容器中子组件在主轴方向上的对齐方式，如居中、两端对齐等"
  },
  {
    "id": 964,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是滑动手势（SwipeGesture）的方向？",
    "options": {
      "A": "SwipeDirection.Up",
      "B": "SwipeDirection.Down",
      "C": "SwipeDirection.Left",
      "D": "SwipeDirection.Right"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "滑动手势支持上（Up）、下（Down）、左（Left）、右（Right）四个方向，可单独或组合设置"
  },
  {
    "id": 965,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示对话框的组件是？",
    "options": {
      "A": "Dialog",
      "B": "AlertDialog",
      "C": "Popup",
      "D": "Modal"
    },
    "answer": [
      "A"
    ],
    "explanation": "Dialog 组件用于创建自定义对话框，支持自定义内容和按钮，可阻断用户操作直到关闭"
  },
  {
    "id": 966,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式数据同步的冲突解决策略不包括以下哪项？",
    "options": {
      "A": "覆盖策略",
      "B": "合并策略",
      "C": "忽略策略",
      "D": "重试策略"
    },
    "answer": [
      "D"
    ],
    "explanation": "分布式数据同步的冲突解决策略包括覆盖、合并、忽略，没有重试策略（重试是解决网络问题的机制）"
  },
  {
    "id": 967,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由配置文件 main_pages.json 的作用？",
    "options": {
      "A": "定义应用的页面路径",
      "B": "设置默认启动页面",
      "C": "配置页面的路由参数",
      "D": "指定页面的生命周期"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "main_pages.json 用于定义应用的所有页面路径和设置默认启动页面（第一个页面）；不负责配置参数或生命周期"
  },
  {
    "id": 968,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的阴影模糊半径？",
    "options": {
      "A": ".shadow ({ radius: 10 })",
      "B": ".shadowRadius (10)",
      "C": ".setShadowBlur (10)",
      "D": ".shadow ({ blur: 10 })"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过.shadow () 方法的 radius 参数设置阴影模糊半径，值越大阴影越模糊"
  },
  {
    "id": 969,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确创建一个 Promise 对象？",
    "options": {
      "A": "new Promise ((resolve, reject) => { ... })",
      "B": "Promise.create ((resolve, reject) => { ... })",
      "C": "Promise ((resolve, reject) => { ... })",
      "D": "createPromise ((resolve, reject) => { ... })"
    },
    "answer": [
      "A"
    ],
    "explanation": "创建 Promise 对象的标准方式是使用 new Promise () 构造函数，传入执行器函数"
  },
  {
    "id": 970,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的事件传递方式？",
    "options": {
      "A": "通过函数参数传递",
      "B": "通过 @Event 装饰器",
      "C": "通过 EventEmitter",
      "D": "通过全局事件总线"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "自定义组件的事件传递方式包括函数参数、@Event 装饰器、EventEmitter 和全局事件总线等多种方式"
  },
  {
    "id": 971,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onUpdate () 生命周期函数的参数是什么？",
    "options": {
      "A": "更新前后的属性值",
      "B": "更新的时间戳",
      "C": "更新的属性名称",
      "D": "没有参数"
    },
    "answer": [
      "A"
    ],
    "explanation": "onUpdate () 接收一个对象参数，包含更新前（prev）和更新后（curr）的属性值，用于比较属性变化"
  },
  {
    "id": 972,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的 flush () 方法是同步还是异步操作？",
    "options": {
      "A": "同步操作",
      "B": "异步操作",
      "C": "既可同步也可异步",
      "D": "根据数据量自动决定"
    },
    "answer": [
      "B"
    ],
    "explanation": "Preferences 的 flush () 方法是异步操作，将内存中的数据写入磁盘，返回 Promise 对象"
  },
  {
    "id": 973,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置滚动条？",
    "options": {
      "A": "Scroll",
      "B": "List",
      "C": "Grid",
      "D": "WaterFlow"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Scroll（scrollBar）、List（scrollBar）、Grid（scrollBar）、WaterFlow（scrollBar）均支持设置滚动条显示方式"
  },
  {
    "id": 974,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件用于处理组件的点击操作？",
    "options": {
      "A": "onClick",
      "B": "onTap",
      "C": "onPress",
      "D": "onSelect"
    },
    "answer": [
      "A"
    ],
    "explanation": "onClick 事件用于处理组件的点击操作，是最常用的交互事件之一"
  },
  {
    "id": 975,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示滑块选择器的组件是？",
    "options": {
      "A": "Slider",
      "B": "Range",
      "C": "Selector",
      "D": "SliderPicker"
    },
    "answer": [
      "A"
    ],
    "explanation": "Slider 组件用于通过滑动选择一个范围内的值，可设置最小值、最大值和步长"
  },
  {
    "id": 976,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式设备的类型？",
    "options": {
      "A": "phone",
      "B": "tablet",
      "C": "tv",
      "D": "wearable"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "鸿蒙分布式设备类型包括手机（phone）、平板（tablet）、电视（tv）、可穿戴设备（wearable）等"
  },
  {
    "id": 977,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.enableAlertBeforeBackPage () 的参数类型是什么？",
    "options": {
      "A": "boolean",
      "B": "string",
      "C": "object",
      "D": "function"
    },
    "answer": [
      "C"
    ],
    "explanation": "router.enableAlertBeforeBackPage () 接受一个对象参数，包含 message（提示消息）和 confirm（确认回调）等属性"
  },
  {
    "id": 978,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的颜色？",
    "options": {
      "A": ".fontColor (Color.Red)",
      "B": ".textColor (Color.Red)",
      "C": ".color (Color.Red)",
      "D": ".setTextColor (Color.Red)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.fontColor () 方法设置文本颜色，参数为 Color 对象或颜色字符串；其他选项不是标准 API"
  },
  {
    "id": 979,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现数组的归约（累加）？",
    "options": {
      "A": "array.reduce ((sum, item) => sum + item, 0)",
      "B": "array.sum ((sum, item) => sum + item)",
      "C": "array.accumulate ((sum, item) => sum + item)",
      "D": "reduce (array, (sum, item) => sum + item, 0)"
    },
    "answer": [
      "A"
    ],
    "explanation": "reduce () 方法用于对数组进行归约操作，接受回调函数和初始值，可实现累加等功能"
  },
  {
    "id": 980,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何引用子组件的方法？",
    "options": {
      "A": "通过 ref 属性获取组件实例",
      "B": "通过 @Child 装饰器",
      "C": "通过 getChild () 方法",
      "D": "ArkTS 不支持引用子组件方法"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过为子组件设置 ref 属性，可在父组件中获取子组件实例，进而调用子组件的方法"
  },
  {
    "id": 981,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数在组件属性更新时会被调用？",
    "options": {
      "A": "onUpdate ()",
      "B": "onAppear ()",
      "C": "build ()",
      "D": "onRefresh ()"
    },
    "answer": [
      "A",
      "C"
    ],
    "explanation": "组件属性更新时会调用 onUpdate ()（处理更新逻辑）和 build ()（重新渲染）；onAppear () 在显示时调用，onRefresh () 不存在"
  },
  {
    "id": 982,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 的容量限制是？",
    "options": {
      "A": "没有固定限制，取决于内存",
      "B": "1MB",
      "C": "5MB",
      "D": "与 AppStorage 共享容量"
    },
    "answer": [
      "A"
    ],
    "explanation": "LocalStorage 是内存中的状态存储，没有固定容量限制，实际受设备内存大小限制"
  },
  {
    "id": 983,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Flex 布局中，flexWrap 属性的作用是？",
    "options": {
      "A": "设置子组件是否换行",
      "B": "设置子组件的排列方向",
      "C": "设置子组件的对齐方式",
      "D": "设置子组件的缩放比例"
    },
    "answer": [
      "A"
    ],
    "explanation": "flexWrap 用于设置当子组件总宽度超过容器宽度时是否换行，可选值为 NoWrap（不换行）、Wrap（换行）等"
  },
  {
    "id": 984,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是长按手势（LongPressGesture）的事件回调？",
    "options": {
      "A": "onActionStart",
      "B": "onActionUpdate",
      "C": "onActionEnd",
      "D": "onActionCancel"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "长按手势支持 onActionStart（开始）、onActionUpdate（更新）、onActionEnd（结束）、onActionCancel（取消）四个阶段的回调"
  },
  {
    "id": 985,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示日期选择器的组件是？",
    "options": {
      "A": "DatePicker",
      "B": "CalendarPicker",
      "C": "DateSelector",
      "D": "Calendar"
    },
    "answer": [
      "A"
    ],
    "explanation": "DatePicker 组件用于选择日期（年、月、日），支持设置日期范围和默认选中日期"
  },
  {
    "id": 986,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式服务的调用超时时间默认是多少？",
    "options": {
      "A": "3 秒",
      "B": "5 秒",
      "C": "10 秒",
      "D": "无默认超时"
    },
    "answer": [
      "B"
    ],
    "explanation": "分布式服务调用的默认超时时间为 5 秒，可通过 timeout 参数自定义超时时间"
  },
  {
    "id": 987,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由动画的配置属性？",
    "options": {
      "A": "duration",
      "B": "curve",
      "C": "delay",
      "D": "direction"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "路由动画配置包括 duration（时长）、curve（曲线）、delay（延迟）；direction 是手势方向，不是动画属性"
  },
  {
    "id": 988,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的边框宽度？",
    "options": {
      "A": ".borderWidth (2)",
      "B": ".border ({ width: 2 })",
      "C": ".setBorderWidth (2)",
      "D": ".borderWidth ('2px')"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用.borderWidth () 方法设置组件的边框宽度，参数为数字（像素值）；.border () 也可设置，但选项 A 更直接"
  },
  {
    "id": 989,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确判断数组是否包含某个元素？",
    "options": {
      "A": "array.includes (item)",
      "B": "array.contains (item)",
      "C": "array.has (item)",
      "D": "includes (array, item)"
    },
    "answer": [
      "A"
    ],
    "explanation": "includes () 方法用于判断数组是否包含指定元素，返回布尔值；其他选项不是 ArkTS 的数组方法"
  },
  {
    "id": 990,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的复用场景？",
    "options": {
      "A": "列表项组件",
      "B": "按钮组件",
      "C": "表单输入组件",
      "D": "页面级组件"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "列表项、按钮、表单输入等具有通用性的组件适合复用；页面级组件通常具有独特性，复用场景较少"
  },
  {
    "id": 991,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onCreate () 生命周期函数的主要作用是？",
    "options": {
      "A": "初始化组件状态和数据",
      "B": "渲染组件 UI",
      "C": "处理组件属性更新",
      "D": "释放组件资源"
    },
    "answer": [
      "A"
    ],
    "explanation": "onCreate () 在组件创建时调用，主要用于初始化组件的状态、数据和事件监听等"
  },
  {
    "id": 992,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的文件存储路径在哪个目录下？",
    "options": {
      "A": "应用沙箱目录下的 preferences",
      "B": "应用的 cache 目录",
      "C": "应用的 files 目录",
      "D": "系统的 preferences 目录"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 数据存储在应用沙箱目录下的 preferences 子目录中，确保数据隔离和安全性"
  },
  {
    "id": 993,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置权重？",
    "options": {
      "A": "Row",
      "B": "Column",
      "C": "Grid",
      "D": "Flex"
    },
    "answer": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Row、Column（通过 flexWeight ()）和 Flex（通过 flex ()）支持设置权重，控制子组件的空间分配；Grid 不支持权重设置"
  },
  {
    "id": 994,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件用于处理输入框内容变化？",
    "options": {
      "A": "onChange",
      "B": "onInput",
      "C": "onTextChange",
      "D": "onValueChange"
    },
    "answer": [
      "D"
    ],
    "explanation": "onValueChange 事件在输入框内容变化时触发，可获取输入的最新值"
  },
  {
    "id": 995,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示下拉刷新控件的组件是？",
    "options": {
      "A": "Refresh",
      "B": "PullToRefresh",
      "C": "SwipeRefresh",
      "D": "RefreshControl"
    },
    "answer": [
      "A"
    ],
    "explanation": "Refresh 组件用于实现下拉刷新功能，包裹在可滚动组件外部，下拉时触发刷新回调"
  },
  {
    "id": 996,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式安全机制？",
    "options": {
      "A": "设备认证",
      "B": "数据加密",
      "C": "权限控制",
      "D": "访问审计"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式安全机制包括设备认证、数据加密、权限控制和访问审计等，确保跨设备交互的安全性"
  },
  {
    "id": 997,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.pushUrl () 的 options 参数中，url 属性的格式是？",
    "options": {
      "A": "页面在 main_pages.json 中的路径",
      "B": "页面的绝对路径",
      "C": "页面的相对路径",
      "D": "页面的类名"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.pushUrl () 的 url 属性应填写页面在 main_pages.json 中配置的路径，如 'pages/DetailPage'"
  },
  {
    "id": 998,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置组件的高度？",
    "options": {
      "A": ".height (100)",
      "B": ".height ('100%')",
      "C": ".height (Length.FILL)",
      "D": ".setHeight (100)"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": ".height () 支持数字（像素）、百分比字符串和 Length.FILL（填充父容器）；.setHeight () 不是标准 API"
  },
  {
    "id": 999,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现对象的属性遍历？",
    "options": {
      "A": "for (const key in obj) { ... }",
      "B": "obj.forEach ((key, value) => { ... })",
      "C": "for (const [key, value] of obj) { ... }",
      "D": "Object.each (obj, (key, value) => { ... })"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 for...in 循环可遍历对象的可枚举属性；forEach () 是数组方法，对象不能直接使用；其他选项不是标准方式"
  },
  {
    "id": 1000,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何定义插槽（slot）？",
    "options": {
      "A": "使用 Slot 组件",
      "B": "使用 @Slot 装饰器",
      "C": " 使用<slot>标签 ",
      "D": "ArkTS 不支持插槽"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 中通过 Slot 组件定义插槽，允许父组件传入自定义内容，实现组件的内容定制"
  },
  {
    "id": 1001,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数是页面级组件特有的？",
    "options": {
      "A": "onPageShow ()",
      "B": "onPageHide ()",
      "C": "onBackPress ()",
      "D": "onCreate ()"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "onPageShow ()、onPageHide ()、onBackPress () 是页面级组件特有的生命周期；onCreate () 是所有组件共有的"
  },
  {
    "id": 1002,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "AppStorage 的 Set () 方法是否会触发组件重新渲染？",
    "options": {
      "A": "是，会触发所有绑定该状态的组件重新渲染",
      "B": "否，需要手动触发",
      "C": "仅触发当前组件重新渲染",
      "D": "仅触发父组件重新渲染"
    },
    "answer": [
      "A"
    ],
    "explanation": "AppStorage 的 Set () 方法修改状态后，会自动通知所有通过 @StorageProp 或 @StorageLink 绑定该状态的组件重新渲染"
  },
  {
    "id": 1003,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Grid 布局中，rowsTemplate 属性的作用是？",
    "options": {
      "A": "定义行的数量和高度比例",
      "B": "定义行的间距",
      "C": "定义行的对齐方式",
      "D": "定义行的最大高度"
    },
    "answer": [
      "A"
    ],
    "explanation": "rowsTemplate 用于定义 Grid 的行结构，如 '1fr 1fr' 表示 2 行，每行高度相等"
  },
  {
    "id": 1004,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是旋转手势（RotateGesture）的事件参数？",
    "options": {
      "A": "angle",
      "B": "rotation",
      "C": "centerX",
      "D": "centerY"
    },
    "answer": [
      "A",
      "C",
      "D"
    ],
    "explanation": "旋转手势参数包括 angle（旋转角度）、centerX/centerY（旋转中心点坐标）；rotation 不是标准参数"
  },
  {
    "id": 1005,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示图片轮播的组件是？",
    "options": {
      "A": "Swiper",
      "B": "Carousel",
      "C": "SlideShow",
      "D": "ImageSlider"
    },
    "answer": [
      "A"
    ],
    "explanation": "Swiper 组件用于实现图片轮播或内容切换，支持自动播放、指示器等功能"
  },
  {
    "id": 1006,
    "type": "single",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "分布式数据对象的同步频率单位是？",
    "options": {
      "A": "毫秒",
      "B": "秒",
      "C": "分钟",
      "D": "自定义单位"
    },
    "answer": [
      "A"
    ],
    "explanation": "分布式数据对象的同步频率以毫秒为单位，如设置为 1000 表示每 1000 毫秒同步一次"
  },
  {
    "id": 1007,
    "type": "multiple",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "以下哪些是路由参数的类型？",
    "options": {
      "A": "字符串",
      "B": "数字",
      "C": "布尔值",
      "D": "对象"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "路由参数支持字符串、数字、布尔值等基本类型，以及对象等复杂类型"
  },
  {
    "id": 1008,
    "type": "single",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "如何设置组件的背景为径向渐变？",
    "options": {
      "A": ".backgroundGradient ({ type: GradientType.Radial, colors: [...] })",
      "B": ".radialGradient ({ colors: [...] })",
      "C": ".background ({ gradient: { type: 'radial', colors: [...] } })",
      "D": ".setBackgroundGradient ('radial', [...])"
    },
    "answer": [
      "A"
    ],
    "explanation": "通过.backgroundGradient () 方法设置径向渐变，指定 type 为 GradientType.Radial"
  },
  {
    "id": 1009,
    "type": "single",
    "category": "基础语法",
    "difficulty": "简单",
    "question": "ArkTS 中，以下哪种方式可以正确将字符串转换为数字？",
    "options": {
      "A": "Number (str)",
      "B": "parseInt (str)",
      "C": "str.toNumber ()",
      "D": "toNumber (str)"
    },
    "answer": [
      "A"
    ],
    "explanation": "使用 Number () 构造函数可将字符串转换为数字，支持整数和小数；parseInt () 仅转换为整数；其他选项不是标准方式"
  },
  {
    "id": 1010,
    "type": "multiple",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "以下哪些是自定义组件的属性验证规则？",
    "options": {
      "A": "类型验证",
      "B": "范围验证",
      "C": "必填验证",
      "D": "格式验证"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "自定义组件的属性验证包括类型、范围（如数值范围）、必填（是否必须传递）、格式（如邮箱格式）等规则"
  },
  {
    "id": 1011,
    "type": "single",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "onBackPress () 生命周期函数的作用是？",
    "options": {
      "A": "处理返回键事件",
      "B": "页面返回前的清理操作",
      "C": "返回上一页",
      "D": "记录返回历史"
    },
    "answer": [
      "A"
    ],
    "explanation": "onBackPress () 用于处理返回键事件，返回 true 可阻止默认返回行为，实现自定义返回逻辑"
  },
  {
    "id": 1012,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "Preferences 的 clear () 方法的作用是？",
    "options": {
      "A": "清空所有存储的数据",
      "B": "删除 Preferences 文件",
      "C": "清除内存中的数据，保留磁盘数据",
      "D": "重置 Preferences 配置"
    },
    "answer": [
      "A"
    ],
    "explanation": "Preferences 的 clear () 方法用于清空所有存储的数据，包括内存和磁盘中的数据"
  },
  {
    "id": 1013,
    "type": "multiple",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "以下哪些布局容器支持设置对齐方式？",
    "options": {
      "A": "Row",
      "B": "Column",
      "C": "Stack",
      "D": "RelativeContainer"
    },
    "answer": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Row/Column（justifyContent/alignItems）、Stack（alignContent）支持设置对齐方式；RelativeContainer 通过锚点设置对齐"
  },
  {
    "id": 1014,
    "type": "single",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪种事件用于处理组件的长按操作？",
    "options": {
      "A": "onLongPress",
      "B": "onLongClick",
      "C": "onPressLong",
      "D": "onLongTouch"
    },
    "answer": [
      "A"
    ],
    "explanation": "onLongPress 事件用于处理组件的长按操作，可设置长按时间阈值"
  },
  {
    "id": 1015,
    "type": "single",
    "category": "UI 组件",
    "difficulty": "简单",
    "question": "用于显示进度环的组件是？",
    "options": {
      "A": "Progress",
      "B": "CircleProgress",
      "C": "RingProgress",
      "D": "ArcProgress"
    },
    "answer": [
      "A"
    ],
    "explanation": "Progress 组件通过设置 type 为 ProgressType.Ring 可显示环形进度条（进度环）"
  },
  {
    "id": 1016,
    "type": "multiple",
    "category": "分布式能力",
    "difficulty": "困难",
    "question": "以下哪些是分布式任务的类型？",
    "options": {
      "A": "计算任务",
      "B": "媒体任务",
      "C": "通信任务",
      "D": "存储任务"
    },
    "answer": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "分布式任务包括计算、媒体、通信、存储等多种类型，可根据任务性质分配到不同设备执行"
  },
  {
    "id": 1017,
    "type": "single",
    "category": "路由管理",
    "difficulty": "中等",
    "question": "router.replaceUrl () 与 router.pushUrl () 的主要区别是？",
    "options": {
      "A": "replaceUrl 替换当前页面，pushUrl 添加新页面",
      "B": "replaceUrl 不保留历史记录，pushUrl 保留",
      "C": "replaceUrl 用于返回，pushUrl 用于前进",
      "D": "replaceUrl 有动画，pushUrl 无动画"
    },
    "answer": [
      "A"
    ],
    "explanation": "router.replaceUrl () 用新页面替换当前页面，路由栈长度不变；router.pushUrl () 在栈顶添加新页面，栈长度增加"
  },
  {
    "id": 1018,
    "type": "multiple",
    "category": "样式设置",
    "difficulty": "中等",
    "question": "以下哪些方法可以设置文本的字体家族？",
    "options": {
      "A": ".fontFamily ('sans-serif')",
      "B": ".font ({ family: 'serif' })",
      "C": ".setFontFamily ('monospace')",
      "D": ".textFont ('sans-serif')"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "可通过.fontFamily () 直接设置或.font () 传入家族名称设置文本字体；其他选项不是标准 API"
  },
  {
    "id": 1019,
    "type": "single",
    "category": "基础语法",
    "difficulty": "中等",
    "question": "ArkTS 中，以下哪种方式可以正确实现数组的扁平化？",
    "options": {
      "A": "array.flat ()",
      "B": "array.flatten ()",
      "C": "flat (array)",
      "D": "array.expand ()"
    },
    "answer": [
      "A"
    ],
    "explanation": "flat () 方法用于将多维数组扁平化，返回一个新的一维数组；其他选项不是 ArkTS 的数组方法"
  },
  {
    "id": 1020,
    "type": "single",
    "category": "组件开发",
    "difficulty": "中等",
    "question": "自定义组件中，如何实现组件的样式继承？",
    "options": {
      "A": "通过 @Extend 装饰器扩展父组件样式",
      "B": "使用 extends 关键字继承",
      "C": "通过 style 属性传递",
      "D": "ArkTS 不支持样式继承"
    },
    "answer": [
      "A"
    ],
    "explanation": "ArkTS 通过 @Extend 装饰器扩展已有组件的样式，实现样式的复用和继承；不支持类的继承方式"
  },
  {
    "id": 1021,
    "type": "multiple",
    "category": "组件生命周期",
    "difficulty": "中等",
    "question": "以下哪些生命周期函数在应用从后台切换到前台时会被调用？",
    "options": {
      "A": "onPageShow ()",
      "B": "onAppear ()",
      "C": "onForeground ()",
      "D": "onResume ()"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "应用从后台切换到前台时，当前页面组件会触发 onPageShow () 和 onAppear ()；onForeground () 和 onResume () 不存在"
  },
  {
    "id": 1022,
    "type": "single",
    "category": "状态管理",
    "difficulty": "中等",
    "question": "LocalStorage 的 get () 方法如果获取不存在的键，会返回什么？",
    "options": {
      "A": "undefined",
      "B": "null",
      "C": "默认值",
      "D": "抛出异常"
    },
    "answer": [
      "A"
    ],
    "explanation": "LocalStorage 的 get () 方法获取不存在的键时返回 undefined，与 AppStorage 不同（需指定默认值）"
  },
  {
    "id": 1023,
    "type": "single",
    "category": "布局设计",
    "difficulty": "中等",
    "question": "Flex 布局中，alignItems 属性的作用是？",
    "options": {
      "A": "设置交叉轴方向上的对齐方式",
      "B": "设置主轴方向上的对齐方式",
      "C": "设置单个子组件的对齐方式",
      "D": "设置子组件的换行方式"
    },
    "answer": [
      "A"
    ],
    "explanation": "alignItems 用于设置 Flex 容器中所有子组件在交叉轴方向上的对齐方式"
  },
  {
    "id": 1024,
    "type": "multiple",
    "category": "事件处理",
    "difficulty": "中等",
    "question": "以下哪些是输入框的状态变化事件？",
    "options": {
      "A": "onFocus",
      "B": "onBlur",
      "C": "onSelect",
      "D": "onEdit"
    },
    "answer": [
      "A",
      "B"
    ],
    "explanation": "输入框的状态变化事件包括 onFocus（获取焦点）和 onBlur（失去焦点）；onSelect 用于选择事件，onEdit 不存在"
  }
]